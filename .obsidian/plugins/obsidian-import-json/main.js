/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value2) => {
      try {
        step(generator.next(value2));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value2) => {
      try {
        step(generator.throw(value2));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// node_modules/papaparse/papaparse.min.js
var require_papaparse_min = __commonJS({
  "node_modules/papaparse/papaparse.min.js"(exports, module2) {
    !function(e, t) {
      typeof define == "function" && define.amd ? define([], t) : typeof module2 == "object" && typeof exports != "undefined" ? module2.exports = t() : e.Papa = t();
    }(exports, function s() {
      "use strict";
      var f = typeof self != "undefined" ? self : typeof window != "undefined" ? window : f !== void 0 ? f : {};
      var n = !f.document && !!f.postMessage, o = n && /blob:/i.test((f.location || {}).protocol), a = {}, h = 0, b = { parse: function(e, t) {
        var i2 = (t = t || {}).dynamicTyping || false;
        M(i2) && (t.dynamicTypingFunction = i2, i2 = {});
        if (t.dynamicTyping = i2, t.transform = !!M(t.transform) && t.transform, t.worker && b.WORKERS_SUPPORTED) {
          var r = function() {
            if (!b.WORKERS_SUPPORTED)
              return false;
            var e2 = (i3 = f.URL || f.webkitURL || null, r2 = s.toString(), b.BLOB_URL || (b.BLOB_URL = i3.createObjectURL(new Blob(["(", r2, ")();"], { type: "text/javascript" })))), t2 = new f.Worker(e2);
            var i3, r2;
            return t2.onmessage = _, t2.id = h++, a[t2.id] = t2;
          }();
          return r.userStep = t.step, r.userChunk = t.chunk, r.userComplete = t.complete, r.userError = t.error, t.step = M(t.step), t.chunk = M(t.chunk), t.complete = M(t.complete), t.error = M(t.error), delete t.worker, void r.postMessage({ input: e, config: t, workerId: r.id });
        }
        var n2 = null;
        b.NODE_STREAM_INPUT, typeof e == "string" ? n2 = t.download ? new l(t) : new p(t) : e.readable === true && M(e.read) && M(e.on) ? n2 = new g(t) : (f.File && e instanceof File || e instanceof Object) && (n2 = new c(t));
        return n2.stream(e);
      }, unparse: function(e, t) {
        var n2 = false, _2 = true, m2 = ",", y2 = "\r\n", s2 = '"', a2 = s2 + s2, i2 = false, r = null, o2 = false;
        !function() {
          if (typeof t != "object")
            return;
          typeof t.delimiter != "string" || b.BAD_DELIMITERS.filter(function(e2) {
            return t.delimiter.indexOf(e2) !== -1;
          }).length || (m2 = t.delimiter);
          (typeof t.quotes == "boolean" || typeof t.quotes == "function" || Array.isArray(t.quotes)) && (n2 = t.quotes);
          typeof t.skipEmptyLines != "boolean" && typeof t.skipEmptyLines != "string" || (i2 = t.skipEmptyLines);
          typeof t.newline == "string" && (y2 = t.newline);
          typeof t.quoteChar == "string" && (s2 = t.quoteChar);
          typeof t.header == "boolean" && (_2 = t.header);
          if (Array.isArray(t.columns)) {
            if (t.columns.length === 0)
              throw new Error("Option columns is empty");
            r = t.columns;
          }
          t.escapeChar !== void 0 && (a2 = t.escapeChar + s2);
          (typeof t.escapeFormulae == "boolean" || t.escapeFormulae instanceof RegExp) && (o2 = t.escapeFormulae instanceof RegExp ? t.escapeFormulae : /^[=+\-@\t\r].*$/);
        }();
        var h2 = new RegExp(j(s2), "g");
        typeof e == "string" && (e = JSON.parse(e));
        if (Array.isArray(e)) {
          if (!e.length || Array.isArray(e[0]))
            return u2(null, e, i2);
          if (typeof e[0] == "object")
            return u2(r || Object.keys(e[0]), e, i2);
        } else if (typeof e == "object")
          return typeof e.data == "string" && (e.data = JSON.parse(e.data)), Array.isArray(e.data) && (e.fields || (e.fields = e.meta && e.meta.fields || r), e.fields || (e.fields = Array.isArray(e.data[0]) ? e.fields : typeof e.data[0] == "object" ? Object.keys(e.data[0]) : []), Array.isArray(e.data[0]) || typeof e.data[0] == "object" || (e.data = [e.data])), u2(e.fields || [], e.data || [], i2);
        throw new Error("Unable to serialize unrecognized input");
        function u2(e2, t2, i3) {
          var r2 = "";
          typeof e2 == "string" && (e2 = JSON.parse(e2)), typeof t2 == "string" && (t2 = JSON.parse(t2));
          var n3 = Array.isArray(e2) && 0 < e2.length, s3 = !Array.isArray(t2[0]);
          if (n3 && _2) {
            for (var a3 = 0; a3 < e2.length; a3++)
              0 < a3 && (r2 += m2), r2 += v2(e2[a3], a3);
            0 < t2.length && (r2 += y2);
          }
          for (var o3 = 0; o3 < t2.length; o3++) {
            var h3 = n3 ? e2.length : t2[o3].length, u3 = false, f2 = n3 ? Object.keys(t2[o3]).length === 0 : t2[o3].length === 0;
            if (i3 && !n3 && (u3 = i3 === "greedy" ? t2[o3].join("").trim() === "" : t2[o3].length === 1 && t2[o3][0].length === 0), i3 === "greedy" && n3) {
              for (var d2 = [], l2 = 0; l2 < h3; l2++) {
                var c2 = s3 ? e2[l2] : l2;
                d2.push(t2[o3][c2]);
              }
              u3 = d2.join("").trim() === "";
            }
            if (!u3) {
              for (var p2 = 0; p2 < h3; p2++) {
                0 < p2 && !f2 && (r2 += m2);
                var g2 = n3 && s3 ? e2[p2] : p2;
                r2 += v2(t2[o3][g2], p2);
              }
              o3 < t2.length - 1 && (!i3 || 0 < h3 && !f2) && (r2 += y2);
            }
          }
          return r2;
        }
        function v2(e2, t2) {
          if (e2 == null)
            return "";
          if (e2.constructor === Date)
            return JSON.stringify(e2).slice(1, 25);
          var i3 = false;
          o2 && typeof e2 == "string" && o2.test(e2) && (e2 = "'" + e2, i3 = true);
          var r2 = e2.toString().replace(h2, a2);
          return (i3 = i3 || n2 === true || typeof n2 == "function" && n2(e2, t2) || Array.isArray(n2) && n2[t2] || function(e3, t3) {
            for (var i4 = 0; i4 < t3.length; i4++)
              if (-1 < e3.indexOf(t3[i4]))
                return true;
            return false;
          }(r2, b.BAD_DELIMITERS) || -1 < r2.indexOf(m2) || r2.charAt(0) === " " || r2.charAt(r2.length - 1) === " ") ? s2 + r2 + s2 : r2;
        }
      } };
      if (b.RECORD_SEP = String.fromCharCode(30), b.UNIT_SEP = String.fromCharCode(31), b.BYTE_ORDER_MARK = "\uFEFF", b.BAD_DELIMITERS = ["\r", "\n", '"', b.BYTE_ORDER_MARK], b.WORKERS_SUPPORTED = !n && !!f.Worker, b.NODE_STREAM_INPUT = 1, b.LocalChunkSize = 10485760, b.RemoteChunkSize = 5242880, b.DefaultDelimiter = ",", b.Parser = E, b.ParserHandle = i, b.NetworkStreamer = l, b.FileStreamer = c, b.StringStreamer = p, b.ReadableStreamStreamer = g, f.jQuery) {
        var d = f.jQuery;
        d.fn.parse = function(o2) {
          var i2 = o2.config || {}, h2 = [];
          return this.each(function(e2) {
            if (!(d(this).prop("tagName").toUpperCase() === "INPUT" && d(this).attr("type").toLowerCase() === "file" && f.FileReader) || !this.files || this.files.length === 0)
              return true;
            for (var t = 0; t < this.files.length; t++)
              h2.push({ file: this.files[t], inputElem: this, instanceConfig: d.extend({}, i2) });
          }), e(), this;
          function e() {
            if (h2.length !== 0) {
              var e2, t, i3, r, n2 = h2[0];
              if (M(o2.before)) {
                var s2 = o2.before(n2.file, n2.inputElem);
                if (typeof s2 == "object") {
                  if (s2.action === "abort")
                    return e2 = "AbortError", t = n2.file, i3 = n2.inputElem, r = s2.reason, void (M(o2.error) && o2.error({ name: e2 }, t, i3, r));
                  if (s2.action === "skip")
                    return void u2();
                  typeof s2.config == "object" && (n2.instanceConfig = d.extend(n2.instanceConfig, s2.config));
                } else if (s2 === "skip")
                  return void u2();
              }
              var a2 = n2.instanceConfig.complete;
              n2.instanceConfig.complete = function(e3) {
                M(a2) && a2(e3, n2.file, n2.inputElem), u2();
              }, b.parse(n2.file, n2.instanceConfig);
            } else
              M(o2.complete) && o2.complete();
          }
          function u2() {
            h2.splice(0, 1), e();
          }
        };
      }
      function u(e) {
        this._handle = null, this._finished = false, this._completed = false, this._halted = false, this._input = null, this._baseIndex = 0, this._partialLine = "", this._rowCount = 0, this._start = 0, this._nextChunk = null, this.isFirstChunk = true, this._completeResults = { data: [], errors: [], meta: {} }, function(e2) {
          var t = w(e2);
          t.chunkSize = parseInt(t.chunkSize), e2.step || e2.chunk || (t.chunkSize = null);
          this._handle = new i(t), (this._handle.streamer = this)._config = t;
        }.call(this, e), this.parseChunk = function(e2, t) {
          if (this.isFirstChunk && M(this._config.beforeFirstChunk)) {
            var i2 = this._config.beforeFirstChunk(e2);
            i2 !== void 0 && (e2 = i2);
          }
          this.isFirstChunk = false, this._halted = false;
          var r = this._partialLine + e2;
          this._partialLine = "";
          var n2 = this._handle.parse(r, this._baseIndex, !this._finished);
          if (!this._handle.paused() && !this._handle.aborted()) {
            var s2 = n2.meta.cursor;
            this._finished || (this._partialLine = r.substring(s2 - this._baseIndex), this._baseIndex = s2), n2 && n2.data && (this._rowCount += n2.data.length);
            var a2 = this._finished || this._config.preview && this._rowCount >= this._config.preview;
            if (o)
              f.postMessage({ results: n2, workerId: b.WORKER_ID, finished: a2 });
            else if (M(this._config.chunk) && !t) {
              if (this._config.chunk(n2, this._handle), this._handle.paused() || this._handle.aborted())
                return void (this._halted = true);
              n2 = void 0, this._completeResults = void 0;
            }
            return this._config.step || this._config.chunk || (this._completeResults.data = this._completeResults.data.concat(n2.data), this._completeResults.errors = this._completeResults.errors.concat(n2.errors), this._completeResults.meta = n2.meta), this._completed || !a2 || !M(this._config.complete) || n2 && n2.meta.aborted || (this._config.complete(this._completeResults, this._input), this._completed = true), a2 || n2 && n2.meta.paused || this._nextChunk(), n2;
          }
          this._halted = true;
        }, this._sendError = function(e2) {
          M(this._config.error) ? this._config.error(e2) : o && this._config.error && f.postMessage({ workerId: b.WORKER_ID, error: e2, finished: false });
        };
      }
      function l(e) {
        var r;
        (e = e || {}).chunkSize || (e.chunkSize = b.RemoteChunkSize), u.call(this, e), this._nextChunk = n ? function() {
          this._readChunk(), this._chunkLoaded();
        } : function() {
          this._readChunk();
        }, this.stream = function(e2) {
          this._input = e2, this._nextChunk();
        }, this._readChunk = function() {
          if (this._finished)
            this._chunkLoaded();
          else {
            if (r = new XMLHttpRequest(), this._config.withCredentials && (r.withCredentials = this._config.withCredentials), n || (r.onload = v(this._chunkLoaded, this), r.onerror = v(this._chunkError, this)), r.open(this._config.downloadRequestBody ? "POST" : "GET", this._input, !n), this._config.downloadRequestHeaders) {
              var e2 = this._config.downloadRequestHeaders;
              for (var t in e2)
                r.setRequestHeader(t, e2[t]);
            }
            if (this._config.chunkSize) {
              var i2 = this._start + this._config.chunkSize - 1;
              r.setRequestHeader("Range", "bytes=" + this._start + "-" + i2);
            }
            try {
              r.send(this._config.downloadRequestBody);
            } catch (e3) {
              this._chunkError(e3.message);
            }
            n && r.status === 0 && this._chunkError();
          }
        }, this._chunkLoaded = function() {
          r.readyState === 4 && (r.status < 200 || 400 <= r.status ? this._chunkError() : (this._start += this._config.chunkSize ? this._config.chunkSize : r.responseText.length, this._finished = !this._config.chunkSize || this._start >= function(e2) {
            var t = e2.getResponseHeader("Content-Range");
            if (t === null)
              return -1;
            return parseInt(t.substring(t.lastIndexOf("/") + 1));
          }(r), this.parseChunk(r.responseText)));
        }, this._chunkError = function(e2) {
          var t = r.statusText || e2;
          this._sendError(new Error(t));
        };
      }
      function c(e) {
        var r, n2;
        (e = e || {}).chunkSize || (e.chunkSize = b.LocalChunkSize), u.call(this, e);
        var s2 = typeof FileReader != "undefined";
        this.stream = function(e2) {
          this._input = e2, n2 = e2.slice || e2.webkitSlice || e2.mozSlice, s2 ? ((r = new FileReader()).onload = v(this._chunkLoaded, this), r.onerror = v(this._chunkError, this)) : r = new FileReaderSync(), this._nextChunk();
        }, this._nextChunk = function() {
          this._finished || this._config.preview && !(this._rowCount < this._config.preview) || this._readChunk();
        }, this._readChunk = function() {
          var e2 = this._input;
          if (this._config.chunkSize) {
            var t = Math.min(this._start + this._config.chunkSize, this._input.size);
            e2 = n2.call(e2, this._start, t);
          }
          var i2 = r.readAsText(e2, this._config.encoding);
          s2 || this._chunkLoaded({ target: { result: i2 } });
        }, this._chunkLoaded = function(e2) {
          this._start += this._config.chunkSize, this._finished = !this._config.chunkSize || this._start >= this._input.size, this.parseChunk(e2.target.result);
        }, this._chunkError = function() {
          this._sendError(r.error);
        };
      }
      function p(e) {
        var i2;
        u.call(this, e = e || {}), this.stream = function(e2) {
          return i2 = e2, this._nextChunk();
        }, this._nextChunk = function() {
          if (!this._finished) {
            var e2, t = this._config.chunkSize;
            return t ? (e2 = i2.substring(0, t), i2 = i2.substring(t)) : (e2 = i2, i2 = ""), this._finished = !i2, this.parseChunk(e2);
          }
        };
      }
      function g(e) {
        u.call(this, e = e || {});
        var t = [], i2 = true, r = false;
        this.pause = function() {
          u.prototype.pause.apply(this, arguments), this._input.pause();
        }, this.resume = function() {
          u.prototype.resume.apply(this, arguments), this._input.resume();
        }, this.stream = function(e2) {
          this._input = e2, this._input.on("data", this._streamData), this._input.on("end", this._streamEnd), this._input.on("error", this._streamError);
        }, this._checkIsFinished = function() {
          r && t.length === 1 && (this._finished = true);
        }, this._nextChunk = function() {
          this._checkIsFinished(), t.length ? this.parseChunk(t.shift()) : i2 = true;
        }, this._streamData = v(function(e2) {
          try {
            t.push(typeof e2 == "string" ? e2 : e2.toString(this._config.encoding)), i2 && (i2 = false, this._checkIsFinished(), this.parseChunk(t.shift()));
          } catch (e3) {
            this._streamError(e3);
          }
        }, this), this._streamError = v(function(e2) {
          this._streamCleanUp(), this._sendError(e2);
        }, this), this._streamEnd = v(function() {
          this._streamCleanUp(), r = true, this._streamData("");
        }, this), this._streamCleanUp = v(function() {
          this._input.removeListener("data", this._streamData), this._input.removeListener("end", this._streamEnd), this._input.removeListener("error", this._streamError);
        }, this);
      }
      function i(m2) {
        var a2, o2, h2, r = Math.pow(2, 53), n2 = -r, s2 = /^\s*-?(\d+\.?|\.\d+|\d+\.\d+)([eE][-+]?\d+)?\s*$/, u2 = /^(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))$/, t = this, i2 = 0, f2 = 0, d2 = false, e = false, l2 = [], c2 = { data: [], errors: [], meta: {} };
        if (M(m2.step)) {
          var p2 = m2.step;
          m2.step = function(e2) {
            if (c2 = e2, _2())
              g2();
            else {
              if (g2(), c2.data.length === 0)
                return;
              i2 += e2.data.length, m2.preview && i2 > m2.preview ? o2.abort() : (c2.data = c2.data[0], p2(c2, t));
            }
          };
        }
        function y2(e2) {
          return m2.skipEmptyLines === "greedy" ? e2.join("").trim() === "" : e2.length === 1 && e2[0].length === 0;
        }
        function g2() {
          return c2 && h2 && (k("Delimiter", "UndetectableDelimiter", "Unable to auto-detect delimiting character; defaulted to '" + b.DefaultDelimiter + "'"), h2 = false), m2.skipEmptyLines && (c2.data = c2.data.filter(function(e2) {
            return !y2(e2);
          })), _2() && function() {
            if (!c2)
              return;
            function e2(e3, t3) {
              M(m2.transformHeader) && (e3 = m2.transformHeader(e3, t3)), l2.push(e3);
            }
            if (Array.isArray(c2.data[0])) {
              for (var t2 = 0; _2() && t2 < c2.data.length; t2++)
                c2.data[t2].forEach(e2);
              c2.data.splice(0, 1);
            } else
              c2.data.forEach(e2);
          }(), function() {
            if (!c2 || !m2.header && !m2.dynamicTyping && !m2.transform)
              return c2;
            function e2(e3, t3) {
              var i3, r2 = m2.header ? {} : [];
              for (i3 = 0; i3 < e3.length; i3++) {
                var n3 = i3, s3 = e3[i3];
                m2.header && (n3 = i3 >= l2.length ? "__parsed_extra" : l2[i3]), m2.transform && (s3 = m2.transform(s3, n3)), s3 = v2(n3, s3), n3 === "__parsed_extra" ? (r2[n3] = r2[n3] || [], r2[n3].push(s3)) : r2[n3] = s3;
              }
              return m2.header && (i3 > l2.length ? k("FieldMismatch", "TooManyFields", "Too many fields: expected " + l2.length + " fields but parsed " + i3, f2 + t3) : i3 < l2.length && k("FieldMismatch", "TooFewFields", "Too few fields: expected " + l2.length + " fields but parsed " + i3, f2 + t3)), r2;
            }
            var t2 = 1;
            !c2.data.length || Array.isArray(c2.data[0]) ? (c2.data = c2.data.map(e2), t2 = c2.data.length) : c2.data = e2(c2.data, 0);
            m2.header && c2.meta && (c2.meta.fields = l2);
            return f2 += t2, c2;
          }();
        }
        function _2() {
          return m2.header && l2.length === 0;
        }
        function v2(e2, t2) {
          return i3 = e2, m2.dynamicTypingFunction && m2.dynamicTyping[i3] === void 0 && (m2.dynamicTyping[i3] = m2.dynamicTypingFunction(i3)), (m2.dynamicTyping[i3] || m2.dynamicTyping) === true ? t2 === "true" || t2 === "TRUE" || t2 !== "false" && t2 !== "FALSE" && (function(e3) {
            if (s2.test(e3)) {
              var t3 = parseFloat(e3);
              if (n2 < t3 && t3 < r)
                return true;
            }
            return false;
          }(t2) ? parseFloat(t2) : u2.test(t2) ? new Date(t2) : t2 === "" ? null : t2) : t2;
          var i3;
        }
        function k(e2, t2, i3, r2) {
          var n3 = { type: e2, code: t2, message: i3 };
          r2 !== void 0 && (n3.row = r2), c2.errors.push(n3);
        }
        this.parse = function(e2, t2, i3) {
          var r2 = m2.quoteChar || '"';
          if (m2.newline || (m2.newline = function(e3, t3) {
            e3 = e3.substring(0, 1048576);
            var i4 = new RegExp(j(t3) + "([^]*?)" + j(t3), "gm"), r3 = (e3 = e3.replace(i4, "")).split("\r"), n4 = e3.split("\n"), s4 = 1 < n4.length && n4[0].length < r3[0].length;
            if (r3.length === 1 || s4)
              return "\n";
            for (var a3 = 0, o3 = 0; o3 < r3.length; o3++)
              r3[o3][0] === "\n" && a3++;
            return a3 >= r3.length / 2 ? "\r\n" : "\r";
          }(e2, r2)), h2 = false, m2.delimiter)
            M(m2.delimiter) && (m2.delimiter = m2.delimiter(e2), c2.meta.delimiter = m2.delimiter);
          else {
            var n3 = function(e3, t3, i4, r3, n4) {
              var s4, a3, o3, h3;
              n4 = n4 || [",", "	", "|", ";", b.RECORD_SEP, b.UNIT_SEP];
              for (var u3 = 0; u3 < n4.length; u3++) {
                var f3 = n4[u3], d3 = 0, l3 = 0, c3 = 0;
                o3 = void 0;
                for (var p3 = new E({ comments: r3, delimiter: f3, newline: t3, preview: 10 }).parse(e3), g3 = 0; g3 < p3.data.length; g3++)
                  if (i4 && y2(p3.data[g3]))
                    c3++;
                  else {
                    var _3 = p3.data[g3].length;
                    l3 += _3, o3 !== void 0 ? 0 < _3 && (d3 += Math.abs(_3 - o3), o3 = _3) : o3 = _3;
                  }
                0 < p3.data.length && (l3 /= p3.data.length - c3), (a3 === void 0 || d3 <= a3) && (h3 === void 0 || h3 < l3) && 1.99 < l3 && (a3 = d3, s4 = f3, h3 = l3);
              }
              return { successful: !!(m2.delimiter = s4), bestDelimiter: s4 };
            }(e2, m2.newline, m2.skipEmptyLines, m2.comments, m2.delimitersToGuess);
            n3.successful ? m2.delimiter = n3.bestDelimiter : (h2 = true, m2.delimiter = b.DefaultDelimiter), c2.meta.delimiter = m2.delimiter;
          }
          var s3 = w(m2);
          return m2.preview && m2.header && s3.preview++, a2 = e2, o2 = new E(s3), c2 = o2.parse(a2, t2, i3), g2(), d2 ? { meta: { paused: true } } : c2 || { meta: { paused: false } };
        }, this.paused = function() {
          return d2;
        }, this.pause = function() {
          d2 = true, o2.abort(), a2 = M(m2.chunk) ? "" : a2.substring(o2.getCharIndex());
        }, this.resume = function() {
          t.streamer._halted ? (d2 = false, t.streamer.parseChunk(a2, true)) : setTimeout(t.resume, 3);
        }, this.aborted = function() {
          return e;
        }, this.abort = function() {
          e = true, o2.abort(), c2.meta.aborted = true, M(m2.complete) && m2.complete(c2), a2 = "";
        };
      }
      function j(e) {
        return e.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
      }
      function E(e) {
        var S, O = (e = e || {}).delimiter, x = e.newline, I = e.comments, T = e.step, D = e.preview, A = e.fastMode, L = S = e.quoteChar === void 0 || e.quoteChar === null ? '"' : e.quoteChar;
        if (e.escapeChar !== void 0 && (L = e.escapeChar), (typeof O != "string" || -1 < b.BAD_DELIMITERS.indexOf(O)) && (O = ","), I === O)
          throw new Error("Comment character same as delimiter");
        I === true ? I = "#" : (typeof I != "string" || -1 < b.BAD_DELIMITERS.indexOf(I)) && (I = false), x !== "\n" && x !== "\r" && x !== "\r\n" && (x = "\n");
        var F = 0, z = false;
        this.parse = function(r, t, i2) {
          if (typeof r != "string")
            throw new Error("Input must be a string");
          var n2 = r.length, e2 = O.length, s2 = x.length, a2 = I.length, o2 = M(T), h2 = [], u2 = [], f2 = [], d2 = F = 0;
          if (!r)
            return C();
          if (A || A !== false && r.indexOf(S) === -1) {
            for (var l2 = r.split(x), c2 = 0; c2 < l2.length; c2++) {
              if (f2 = l2[c2], F += f2.length, c2 !== l2.length - 1)
                F += x.length;
              else if (i2)
                return C();
              if (!I || f2.substring(0, a2) !== I) {
                if (o2) {
                  if (h2 = [], k(f2.split(O)), R(), z)
                    return C();
                } else
                  k(f2.split(O));
                if (D && D <= c2)
                  return h2 = h2.slice(0, D), C(true);
              }
            }
            return C();
          }
          for (var p2 = r.indexOf(O, F), g2 = r.indexOf(x, F), _2 = new RegExp(j(L) + j(S), "g"), m2 = r.indexOf(S, F); ; )
            if (r[F] !== S)
              if (I && f2.length === 0 && r.substring(F, F + a2) === I) {
                if (g2 === -1)
                  return C();
                F = g2 + s2, g2 = r.indexOf(x, F), p2 = r.indexOf(O, F);
              } else if (p2 !== -1 && (p2 < g2 || g2 === -1))
                f2.push(r.substring(F, p2)), F = p2 + e2, p2 = r.indexOf(O, F);
              else {
                if (g2 === -1)
                  break;
                if (f2.push(r.substring(F, g2)), w2(g2 + s2), o2 && (R(), z))
                  return C();
                if (D && h2.length >= D)
                  return C(true);
              }
            else
              for (m2 = F, F++; ; ) {
                if ((m2 = r.indexOf(S, m2 + 1)) === -1)
                  return i2 || u2.push({ type: "Quotes", code: "MissingQuotes", message: "Quoted field unterminated", row: h2.length, index: F }), E2();
                if (m2 === n2 - 1)
                  return E2(r.substring(F, m2).replace(_2, S));
                if (S !== L || r[m2 + 1] !== L) {
                  if (S === L || m2 === 0 || r[m2 - 1] !== L) {
                    p2 !== -1 && p2 < m2 + 1 && (p2 = r.indexOf(O, m2 + 1)), g2 !== -1 && g2 < m2 + 1 && (g2 = r.indexOf(x, m2 + 1));
                    var y2 = b2(g2 === -1 ? p2 : Math.min(p2, g2));
                    if (r.substr(m2 + 1 + y2, e2) === O) {
                      f2.push(r.substring(F, m2).replace(_2, S)), r[F = m2 + 1 + y2 + e2] !== S && (m2 = r.indexOf(S, F)), p2 = r.indexOf(O, F), g2 = r.indexOf(x, F);
                      break;
                    }
                    var v2 = b2(g2);
                    if (r.substring(m2 + 1 + v2, m2 + 1 + v2 + s2) === x) {
                      if (f2.push(r.substring(F, m2).replace(_2, S)), w2(m2 + 1 + v2 + s2), p2 = r.indexOf(O, F), m2 = r.indexOf(S, F), o2 && (R(), z))
                        return C();
                      if (D && h2.length >= D)
                        return C(true);
                      break;
                    }
                    u2.push({ type: "Quotes", code: "InvalidQuotes", message: "Trailing quote on quoted field is malformed", row: h2.length, index: F }), m2++;
                  }
                } else
                  m2++;
              }
          return E2();
          function k(e3) {
            h2.push(e3), d2 = F;
          }
          function b2(e3) {
            var t2 = 0;
            if (e3 !== -1) {
              var i3 = r.substring(m2 + 1, e3);
              i3 && i3.trim() === "" && (t2 = i3.length);
            }
            return t2;
          }
          function E2(e3) {
            return i2 || (e3 === void 0 && (e3 = r.substring(F)), f2.push(e3), F = n2, k(f2), o2 && R()), C();
          }
          function w2(e3) {
            F = e3, k(f2), f2 = [], g2 = r.indexOf(x, F);
          }
          function C(e3) {
            return { data: h2, errors: u2, meta: { delimiter: O, linebreak: x, aborted: z, truncated: !!e3, cursor: d2 + (t || 0) } };
          }
          function R() {
            T(C()), h2 = [], u2 = [];
          }
        }, this.abort = function() {
          z = true;
        }, this.getCharIndex = function() {
          return F;
        };
      }
      function _(e) {
        var t = e.data, i2 = a[t.workerId], r = false;
        if (t.error)
          i2.userError(t.error, t.file);
        else if (t.results && t.results.data) {
          var n2 = { abort: function() {
            r = true, m(t.workerId, { data: [], errors: [], meta: { aborted: true } });
          }, pause: y, resume: y };
          if (M(i2.userStep)) {
            for (var s2 = 0; s2 < t.results.data.length && (i2.userStep({ data: t.results.data[s2], errors: t.results.errors, meta: t.results.meta }, n2), !r); s2++)
              ;
            delete t.results;
          } else
            M(i2.userChunk) && (i2.userChunk(t.results, n2, t.file), delete t.results);
        }
        t.finished && !r && m(t.workerId, t.results);
      }
      function m(e, t) {
        var i2 = a[e];
        M(i2.userComplete) && i2.userComplete(t), i2.terminate(), delete a[e];
      }
      function y() {
        throw new Error("Not implemented.");
      }
      function w(e) {
        if (typeof e != "object" || e === null)
          return e;
        var t = Array.isArray(e) ? [] : {};
        for (var i2 in e)
          t[i2] = w(e[i2]);
        return t;
      }
      function v(e, t) {
        return function() {
          e.apply(t, arguments);
        };
      }
      function M(e) {
        return typeof e == "function";
      }
      return o && (f.onmessage = function(e) {
        var t = e.data;
        b.WORKER_ID === void 0 && t && (b.WORKER_ID = t.workerId);
        if (typeof t.input == "string")
          f.postMessage({ workerId: b.WORKER_ID, results: b.parse(t.input, t.config), finished: true });
        else if (f.File && t.input instanceof File || t.input instanceof Object) {
          var i2 = b.parse(t.input, t.config);
          i2 && f.postMessage({ workerId: b.WORKER_ID, results: i2, finished: true });
        }
      }), (l.prototype = Object.create(u.prototype)).constructor = l, (c.prototype = Object.create(u.prototype)).constructor = c, (p.prototype = Object.create(p.prototype)).constructor = p, (g.prototype = Object.create(u.prototype)).constructor = g, b;
    });
  }
});

// node_modules/handlebars/dist/cjs/handlebars/utils.js
var require_utils = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars/utils.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.extend = extend;
    exports.indexOf = indexOf;
    exports.escapeExpression = escapeExpression;
    exports.isEmpty = isEmpty;
    exports.createFrame = createFrame;
    exports.blockParams = blockParams;
    exports.appendContextPath = appendContextPath;
    var escape = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#x27;",
      "`": "&#x60;",
      "=": "&#x3D;"
    };
    var badChars = /[&<>"'`=]/g;
    var possible = /[&<>"'`=]/;
    function escapeChar(chr) {
      return escape[chr];
    }
    function extend(obj) {
      for (var i = 1; i < arguments.length; i++) {
        for (var key in arguments[i]) {
          if (Object.prototype.hasOwnProperty.call(arguments[i], key)) {
            obj[key] = arguments[i][key];
          }
        }
      }
      return obj;
    }
    var toString = Object.prototype.toString;
    exports.toString = toString;
    var isFunction = function isFunction2(value2) {
      return typeof value2 === "function";
    };
    if (isFunction(/x/)) {
      exports.isFunction = isFunction = function(value2) {
        return typeof value2 === "function" && toString.call(value2) === "[object Function]";
      };
    }
    exports.isFunction = isFunction;
    var isArray = Array.isArray || function(value2) {
      return value2 && typeof value2 === "object" ? toString.call(value2) === "[object Array]" : false;
    };
    exports.isArray = isArray;
    function indexOf(array, value2) {
      for (var i = 0, len = array.length; i < len; i++) {
        if (array[i] === value2) {
          return i;
        }
      }
      return -1;
    }
    function escapeExpression(string) {
      if (typeof string !== "string") {
        if (string && string.toHTML) {
          return string.toHTML();
        } else if (string == null) {
          return "";
        } else if (!string) {
          return string + "";
        }
        string = "" + string;
      }
      if (!possible.test(string)) {
        return string;
      }
      return string.replace(badChars, escapeChar);
    }
    function isEmpty(value2) {
      if (!value2 && value2 !== 0) {
        return true;
      } else if (isArray(value2) && value2.length === 0) {
        return true;
      } else {
        return false;
      }
    }
    function createFrame(object) {
      var frame = extend({}, object);
      frame._parent = object;
      return frame;
    }
    function blockParams(params, ids) {
      params.path = ids;
      return params;
    }
    function appendContextPath(contextPath, id) {
      return (contextPath ? contextPath + "." : "") + id;
    }
  }
});

// node_modules/handlebars/dist/cjs/handlebars/exception.js
var require_exception = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars/exception.js"(exports, module2) {
    "use strict";
    exports.__esModule = true;
    var errorProps = ["description", "fileName", "lineNumber", "endLineNumber", "message", "name", "number", "stack"];
    function Exception(message, node) {
      var loc = node && node.loc, line = void 0, endLineNumber = void 0, column = void 0, endColumn = void 0;
      if (loc) {
        line = loc.start.line;
        endLineNumber = loc.end.line;
        column = loc.start.column;
        endColumn = loc.end.column;
        message += " - " + line + ":" + column;
      }
      var tmp = Error.prototype.constructor.call(this, message);
      for (var idx = 0; idx < errorProps.length; idx++) {
        this[errorProps[idx]] = tmp[errorProps[idx]];
      }
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, Exception);
      }
      try {
        if (loc) {
          this.lineNumber = line;
          this.endLineNumber = endLineNumber;
          if (Object.defineProperty) {
            Object.defineProperty(this, "column", {
              value: column,
              enumerable: true
            });
            Object.defineProperty(this, "endColumn", {
              value: endColumn,
              enumerable: true
            });
          } else {
            this.column = column;
            this.endColumn = endColumn;
          }
        }
      } catch (nop) {
      }
    }
    Exception.prototype = new Error();
    exports["default"] = Exception;
    module2.exports = exports["default"];
  }
});

// node_modules/handlebars/dist/cjs/handlebars/helpers/block-helper-missing.js
var require_block_helper_missing = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars/helpers/block-helper-missing.js"(exports, module2) {
    "use strict";
    exports.__esModule = true;
    var _utils = require_utils();
    exports["default"] = function(instance) {
      instance.registerHelper("blockHelperMissing", function(context, options) {
        var inverse = options.inverse, fn = options.fn;
        if (context === true) {
          return fn(this);
        } else if (context === false || context == null) {
          return inverse(this);
        } else if (_utils.isArray(context)) {
          if (context.length > 0) {
            if (options.ids) {
              options.ids = [options.name];
            }
            return instance.helpers.each(context, options);
          } else {
            return inverse(this);
          }
        } else {
          if (options.data && options.ids) {
            var data = _utils.createFrame(options.data);
            data.contextPath = _utils.appendContextPath(options.data.contextPath, options.name);
            options = { data };
          }
          return fn(context, options);
        }
      });
    };
    module2.exports = exports["default"];
  }
});

// node_modules/handlebars/dist/cjs/handlebars/helpers/each.js
var require_each = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars/helpers/each.js"(exports, module2) {
    "use strict";
    exports.__esModule = true;
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var _utils = require_utils();
    var _exception = require_exception();
    var _exception2 = _interopRequireDefault(_exception);
    exports["default"] = function(instance) {
      instance.registerHelper("each", function(context, options) {
        if (!options) {
          throw new _exception2["default"]("Must pass iterator to #each");
        }
        var fn = options.fn, inverse = options.inverse, i = 0, ret = "", data = void 0, contextPath = void 0;
        if (options.data && options.ids) {
          contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]) + ".";
        }
        if (_utils.isFunction(context)) {
          context = context.call(this);
        }
        if (options.data) {
          data = _utils.createFrame(options.data);
        }
        function execIteration(field, index, last) {
          if (data) {
            data.key = field;
            data.index = index;
            data.first = index === 0;
            data.last = !!last;
            if (contextPath) {
              data.contextPath = contextPath + field;
            }
          }
          ret = ret + fn(context[field], {
            data,
            blockParams: _utils.blockParams([context[field], field], [contextPath + field, null])
          });
        }
        if (context && typeof context === "object") {
          if (_utils.isArray(context)) {
            for (var j = context.length; i < j; i++) {
              if (i in context) {
                execIteration(i, i, i === context.length - 1);
              }
            }
          } else if (global.Symbol && context[global.Symbol.iterator]) {
            var newContext = [];
            var iterator = context[global.Symbol.iterator]();
            for (var it = iterator.next(); !it.done; it = iterator.next()) {
              newContext.push(it.value);
            }
            context = newContext;
            for (var j = context.length; i < j; i++) {
              execIteration(i, i, i === context.length - 1);
            }
          } else {
            (function() {
              var priorKey = void 0;
              Object.keys(context).forEach(function(key) {
                if (priorKey !== void 0) {
                  execIteration(priorKey, i - 1);
                }
                priorKey = key;
                i++;
              });
              if (priorKey !== void 0) {
                execIteration(priorKey, i - 1, true);
              }
            })();
          }
        }
        if (i === 0) {
          ret = inverse(this);
        }
        return ret;
      });
    };
    module2.exports = exports["default"];
  }
});

// node_modules/handlebars/dist/cjs/handlebars/helpers/helper-missing.js
var require_helper_missing = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars/helpers/helper-missing.js"(exports, module2) {
    "use strict";
    exports.__esModule = true;
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var _exception = require_exception();
    var _exception2 = _interopRequireDefault(_exception);
    exports["default"] = function(instance) {
      instance.registerHelper("helperMissing", function() {
        if (arguments.length === 1) {
          return void 0;
        } else {
          throw new _exception2["default"]('Missing helper: "' + arguments[arguments.length - 1].name + '"');
        }
      });
    };
    module2.exports = exports["default"];
  }
});

// node_modules/handlebars/dist/cjs/handlebars/helpers/if.js
var require_if = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars/helpers/if.js"(exports, module2) {
    "use strict";
    exports.__esModule = true;
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var _utils = require_utils();
    var _exception = require_exception();
    var _exception2 = _interopRequireDefault(_exception);
    exports["default"] = function(instance) {
      instance.registerHelper("if", function(conditional, options) {
        if (arguments.length != 2) {
          throw new _exception2["default"]("#if requires exactly one argument");
        }
        if (_utils.isFunction(conditional)) {
          conditional = conditional.call(this);
        }
        if (!options.hash.includeZero && !conditional || _utils.isEmpty(conditional)) {
          return options.inverse(this);
        } else {
          return options.fn(this);
        }
      });
      instance.registerHelper("unless", function(conditional, options) {
        if (arguments.length != 2) {
          throw new _exception2["default"]("#unless requires exactly one argument");
        }
        return instance.helpers["if"].call(this, conditional, {
          fn: options.inverse,
          inverse: options.fn,
          hash: options.hash
        });
      });
    };
    module2.exports = exports["default"];
  }
});

// node_modules/handlebars/dist/cjs/handlebars/helpers/log.js
var require_log = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars/helpers/log.js"(exports, module2) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = function(instance) {
      instance.registerHelper("log", function() {
        var args = [void 0], options = arguments[arguments.length - 1];
        for (var i = 0; i < arguments.length - 1; i++) {
          args.push(arguments[i]);
        }
        var level = 1;
        if (options.hash.level != null) {
          level = options.hash.level;
        } else if (options.data && options.data.level != null) {
          level = options.data.level;
        }
        args[0] = level;
        instance.log.apply(instance, args);
      });
    };
    module2.exports = exports["default"];
  }
});

// node_modules/handlebars/dist/cjs/handlebars/helpers/lookup.js
var require_lookup = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars/helpers/lookup.js"(exports, module2) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = function(instance) {
      instance.registerHelper("lookup", function(obj, field, options) {
        if (!obj) {
          return obj;
        }
        return options.lookupProperty(obj, field);
      });
    };
    module2.exports = exports["default"];
  }
});

// node_modules/handlebars/dist/cjs/handlebars/helpers/with.js
var require_with = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars/helpers/with.js"(exports, module2) {
    "use strict";
    exports.__esModule = true;
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var _utils = require_utils();
    var _exception = require_exception();
    var _exception2 = _interopRequireDefault(_exception);
    exports["default"] = function(instance) {
      instance.registerHelper("with", function(context, options) {
        if (arguments.length != 2) {
          throw new _exception2["default"]("#with requires exactly one argument");
        }
        if (_utils.isFunction(context)) {
          context = context.call(this);
        }
        var fn = options.fn;
        if (!_utils.isEmpty(context)) {
          var data = options.data;
          if (options.data && options.ids) {
            data = _utils.createFrame(options.data);
            data.contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]);
          }
          return fn(context, {
            data,
            blockParams: _utils.blockParams([context], [data && data.contextPath])
          });
        } else {
          return options.inverse(this);
        }
      });
    };
    module2.exports = exports["default"];
  }
});

// node_modules/handlebars/dist/cjs/handlebars/helpers.js
var require_helpers = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars/helpers.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.registerDefaultHelpers = registerDefaultHelpers;
    exports.moveHelperToHooks = moveHelperToHooks;
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var _helpersBlockHelperMissing = require_block_helper_missing();
    var _helpersBlockHelperMissing2 = _interopRequireDefault(_helpersBlockHelperMissing);
    var _helpersEach = require_each();
    var _helpersEach2 = _interopRequireDefault(_helpersEach);
    var _helpersHelperMissing = require_helper_missing();
    var _helpersHelperMissing2 = _interopRequireDefault(_helpersHelperMissing);
    var _helpersIf = require_if();
    var _helpersIf2 = _interopRequireDefault(_helpersIf);
    var _helpersLog = require_log();
    var _helpersLog2 = _interopRequireDefault(_helpersLog);
    var _helpersLookup = require_lookup();
    var _helpersLookup2 = _interopRequireDefault(_helpersLookup);
    var _helpersWith = require_with();
    var _helpersWith2 = _interopRequireDefault(_helpersWith);
    function registerDefaultHelpers(instance) {
      _helpersBlockHelperMissing2["default"](instance);
      _helpersEach2["default"](instance);
      _helpersHelperMissing2["default"](instance);
      _helpersIf2["default"](instance);
      _helpersLog2["default"](instance);
      _helpersLookup2["default"](instance);
      _helpersWith2["default"](instance);
    }
    function moveHelperToHooks(instance, helperName, keepHelper) {
      if (instance.helpers[helperName]) {
        instance.hooks[helperName] = instance.helpers[helperName];
        if (!keepHelper) {
          delete instance.helpers[helperName];
        }
      }
    }
  }
});

// node_modules/handlebars/dist/cjs/handlebars/decorators/inline.js
var require_inline = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars/decorators/inline.js"(exports, module2) {
    "use strict";
    exports.__esModule = true;
    var _utils = require_utils();
    exports["default"] = function(instance) {
      instance.registerDecorator("inline", function(fn, props, container, options) {
        var ret = fn;
        if (!props.partials) {
          props.partials = {};
          ret = function(context, options2) {
            var original = container.partials;
            container.partials = _utils.extend({}, original, props.partials);
            var ret2 = fn(context, options2);
            container.partials = original;
            return ret2;
          };
        }
        props.partials[options.args[0]] = options.fn;
        return ret;
      });
    };
    module2.exports = exports["default"];
  }
});

// node_modules/handlebars/dist/cjs/handlebars/decorators.js
var require_decorators = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars/decorators.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.registerDefaultDecorators = registerDefaultDecorators;
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var _decoratorsInline = require_inline();
    var _decoratorsInline2 = _interopRequireDefault(_decoratorsInline);
    function registerDefaultDecorators(instance) {
      _decoratorsInline2["default"](instance);
    }
  }
});

// node_modules/handlebars/dist/cjs/handlebars/logger.js
var require_logger = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars/logger.js"(exports, module2) {
    "use strict";
    exports.__esModule = true;
    var _utils = require_utils();
    var logger = {
      methodMap: ["debug", "info", "warn", "error"],
      level: "info",
      lookupLevel: function lookupLevel(level) {
        if (typeof level === "string") {
          var levelMap = _utils.indexOf(logger.methodMap, level.toLowerCase());
          if (levelMap >= 0) {
            level = levelMap;
          } else {
            level = parseInt(level, 10);
          }
        }
        return level;
      },
      log: function log(level) {
        level = logger.lookupLevel(level);
        if (typeof console !== "undefined" && logger.lookupLevel(logger.level) <= level) {
          var method = logger.methodMap[level];
          if (!console[method]) {
            method = "log";
          }
          for (var _len = arguments.length, message = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            message[_key - 1] = arguments[_key];
          }
          console[method].apply(console, message);
        }
      }
    };
    exports["default"] = logger;
    module2.exports = exports["default"];
  }
});

// node_modules/handlebars/dist/cjs/handlebars/internal/create-new-lookup-object.js
var require_create_new_lookup_object = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars/internal/create-new-lookup-object.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.createNewLookupObject = createNewLookupObject;
    var _utils = require_utils();
    function createNewLookupObject() {
      for (var _len = arguments.length, sources = Array(_len), _key = 0; _key < _len; _key++) {
        sources[_key] = arguments[_key];
      }
      return _utils.extend.apply(void 0, [Object.create(null)].concat(sources));
    }
  }
});

// node_modules/handlebars/dist/cjs/handlebars/internal/proto-access.js
var require_proto_access = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars/internal/proto-access.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.createProtoAccessControl = createProtoAccessControl;
    exports.resultIsAllowed = resultIsAllowed;
    exports.resetLoggedProperties = resetLoggedProperties;
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      } else {
        var newObj = {};
        if (obj != null) {
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key))
              newObj[key] = obj[key];
          }
        }
        newObj["default"] = obj;
        return newObj;
      }
    }
    var _createNewLookupObject = require_create_new_lookup_object();
    var _logger = require_logger();
    var logger = _interopRequireWildcard(_logger);
    var loggedProperties = Object.create(null);
    function createProtoAccessControl(runtimeOptions) {
      var defaultMethodWhiteList = Object.create(null);
      defaultMethodWhiteList["constructor"] = false;
      defaultMethodWhiteList["__defineGetter__"] = false;
      defaultMethodWhiteList["__defineSetter__"] = false;
      defaultMethodWhiteList["__lookupGetter__"] = false;
      var defaultPropertyWhiteList = Object.create(null);
      defaultPropertyWhiteList["__proto__"] = false;
      return {
        properties: {
          whitelist: _createNewLookupObject.createNewLookupObject(defaultPropertyWhiteList, runtimeOptions.allowedProtoProperties),
          defaultValue: runtimeOptions.allowProtoPropertiesByDefault
        },
        methods: {
          whitelist: _createNewLookupObject.createNewLookupObject(defaultMethodWhiteList, runtimeOptions.allowedProtoMethods),
          defaultValue: runtimeOptions.allowProtoMethodsByDefault
        }
      };
    }
    function resultIsAllowed(result, protoAccessControl, propertyName) {
      if (typeof result === "function") {
        return checkWhiteList(protoAccessControl.methods, propertyName);
      } else {
        return checkWhiteList(protoAccessControl.properties, propertyName);
      }
    }
    function checkWhiteList(protoAccessControlForType, propertyName) {
      if (protoAccessControlForType.whitelist[propertyName] !== void 0) {
        return protoAccessControlForType.whitelist[propertyName] === true;
      }
      if (protoAccessControlForType.defaultValue !== void 0) {
        return protoAccessControlForType.defaultValue;
      }
      logUnexpecedPropertyAccessOnce(propertyName);
      return false;
    }
    function logUnexpecedPropertyAccessOnce(propertyName) {
      if (loggedProperties[propertyName] !== true) {
        loggedProperties[propertyName] = true;
        logger.log("error", 'Handlebars: Access has been denied to resolve the property "' + propertyName + '" because it is not an "own property" of its parent.\nYou can add a runtime option to disable the check or this warning:\nSee https://handlebarsjs.com/api-reference/runtime-options.html#options-to-control-prototype-access for details');
      }
    }
    function resetLoggedProperties() {
      Object.keys(loggedProperties).forEach(function(propertyName) {
        delete loggedProperties[propertyName];
      });
    }
  }
});

// node_modules/handlebars/dist/cjs/handlebars/base.js
var require_base = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars/base.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.HandlebarsEnvironment = HandlebarsEnvironment;
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var _utils = require_utils();
    var _exception = require_exception();
    var _exception2 = _interopRequireDefault(_exception);
    var _helpers = require_helpers();
    var _decorators = require_decorators();
    var _logger = require_logger();
    var _logger2 = _interopRequireDefault(_logger);
    var _internalProtoAccess = require_proto_access();
    var VERSION = "4.7.7";
    exports.VERSION = VERSION;
    var COMPILER_REVISION = 8;
    exports.COMPILER_REVISION = COMPILER_REVISION;
    var LAST_COMPATIBLE_COMPILER_REVISION = 7;
    exports.LAST_COMPATIBLE_COMPILER_REVISION = LAST_COMPATIBLE_COMPILER_REVISION;
    var REVISION_CHANGES = {
      1: "<= 1.0.rc.2",
      2: "== 1.0.0-rc.3",
      3: "== 1.0.0-rc.4",
      4: "== 1.x.x",
      5: "== 2.0.0-alpha.x",
      6: ">= 2.0.0-beta.1",
      7: ">= 4.0.0 <4.3.0",
      8: ">= 4.3.0"
    };
    exports.REVISION_CHANGES = REVISION_CHANGES;
    var objectType = "[object Object]";
    function HandlebarsEnvironment(helpers, partials, decorators) {
      this.helpers = helpers || {};
      this.partials = partials || {};
      this.decorators = decorators || {};
      _helpers.registerDefaultHelpers(this);
      _decorators.registerDefaultDecorators(this);
    }
    HandlebarsEnvironment.prototype = {
      constructor: HandlebarsEnvironment,
      logger: _logger2["default"],
      log: _logger2["default"].log,
      registerHelper: function registerHelper(name, fn) {
        if (_utils.toString.call(name) === objectType) {
          if (fn) {
            throw new _exception2["default"]("Arg not supported with multiple helpers");
          }
          _utils.extend(this.helpers, name);
        } else {
          this.helpers[name] = fn;
        }
      },
      unregisterHelper: function unregisterHelper(name) {
        delete this.helpers[name];
      },
      registerPartial: function registerPartial(name, partial) {
        if (_utils.toString.call(name) === objectType) {
          _utils.extend(this.partials, name);
        } else {
          if (typeof partial === "undefined") {
            throw new _exception2["default"]('Attempting to register a partial called "' + name + '" as undefined');
          }
          this.partials[name] = partial;
        }
      },
      unregisterPartial: function unregisterPartial(name) {
        delete this.partials[name];
      },
      registerDecorator: function registerDecorator(name, fn) {
        if (_utils.toString.call(name) === objectType) {
          if (fn) {
            throw new _exception2["default"]("Arg not supported with multiple decorators");
          }
          _utils.extend(this.decorators, name);
        } else {
          this.decorators[name] = fn;
        }
      },
      unregisterDecorator: function unregisterDecorator(name) {
        delete this.decorators[name];
      },
      resetLoggedPropertyAccesses: function resetLoggedPropertyAccesses() {
        _internalProtoAccess.resetLoggedProperties();
      }
    };
    var log = _logger2["default"].log;
    exports.log = log;
    exports.createFrame = _utils.createFrame;
    exports.logger = _logger2["default"];
  }
});

// node_modules/handlebars/dist/cjs/handlebars/safe-string.js
var require_safe_string = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars/safe-string.js"(exports, module2) {
    "use strict";
    exports.__esModule = true;
    function SafeString(string) {
      this.string = string;
    }
    SafeString.prototype.toString = SafeString.prototype.toHTML = function() {
      return "" + this.string;
    };
    exports["default"] = SafeString;
    module2.exports = exports["default"];
  }
});

// node_modules/handlebars/dist/cjs/handlebars/internal/wrapHelper.js
var require_wrapHelper = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars/internal/wrapHelper.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.wrapHelper = wrapHelper;
    function wrapHelper(helper, transformOptionsFn) {
      if (typeof helper !== "function") {
        return helper;
      }
      var wrapper = function wrapper2() {
        var options = arguments[arguments.length - 1];
        arguments[arguments.length - 1] = transformOptionsFn(options);
        return helper.apply(this, arguments);
      };
      return wrapper;
    }
  }
});

// node_modules/handlebars/dist/cjs/handlebars/runtime.js
var require_runtime = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars/runtime.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.checkRevision = checkRevision;
    exports.template = template;
    exports.wrapProgram = wrapProgram;
    exports.resolvePartial = resolvePartial;
    exports.invokePartial = invokePartial;
    exports.noop = noop;
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      } else {
        var newObj = {};
        if (obj != null) {
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key))
              newObj[key] = obj[key];
          }
        }
        newObj["default"] = obj;
        return newObj;
      }
    }
    var _utils = require_utils();
    var Utils = _interopRequireWildcard(_utils);
    var _exception = require_exception();
    var _exception2 = _interopRequireDefault(_exception);
    var _base = require_base();
    var _helpers = require_helpers();
    var _internalWrapHelper = require_wrapHelper();
    var _internalProtoAccess = require_proto_access();
    function checkRevision(compilerInfo) {
      var compilerRevision = compilerInfo && compilerInfo[0] || 1, currentRevision = _base.COMPILER_REVISION;
      if (compilerRevision >= _base.LAST_COMPATIBLE_COMPILER_REVISION && compilerRevision <= _base.COMPILER_REVISION) {
        return;
      }
      if (compilerRevision < _base.LAST_COMPATIBLE_COMPILER_REVISION) {
        var runtimeVersions = _base.REVISION_CHANGES[currentRevision], compilerVersions = _base.REVISION_CHANGES[compilerRevision];
        throw new _exception2["default"]("Template was precompiled with an older version of Handlebars than the current runtime. Please update your precompiler to a newer version (" + runtimeVersions + ") or downgrade your runtime to an older version (" + compilerVersions + ").");
      } else {
        throw new _exception2["default"]("Template was precompiled with a newer version of Handlebars than the current runtime. Please update your runtime to a newer version (" + compilerInfo[1] + ").");
      }
    }
    function template(templateSpec, env) {
      if (!env) {
        throw new _exception2["default"]("No environment passed to template");
      }
      if (!templateSpec || !templateSpec.main) {
        throw new _exception2["default"]("Unknown template object: " + typeof templateSpec);
      }
      templateSpec.main.decorator = templateSpec.main_d;
      env.VM.checkRevision(templateSpec.compiler);
      var templateWasPrecompiledWithCompilerV7 = templateSpec.compiler && templateSpec.compiler[0] === 7;
      function invokePartialWrapper(partial, context, options) {
        if (options.hash) {
          context = Utils.extend({}, context, options.hash);
          if (options.ids) {
            options.ids[0] = true;
          }
        }
        partial = env.VM.resolvePartial.call(this, partial, context, options);
        var extendedOptions = Utils.extend({}, options, {
          hooks: this.hooks,
          protoAccessControl: this.protoAccessControl
        });
        var result = env.VM.invokePartial.call(this, partial, context, extendedOptions);
        if (result == null && env.compile) {
          options.partials[options.name] = env.compile(partial, templateSpec.compilerOptions, env);
          result = options.partials[options.name](context, extendedOptions);
        }
        if (result != null) {
          if (options.indent) {
            var lines = result.split("\n");
            for (var i = 0, l = lines.length; i < l; i++) {
              if (!lines[i] && i + 1 === l) {
                break;
              }
              lines[i] = options.indent + lines[i];
            }
            result = lines.join("\n");
          }
          return result;
        } else {
          throw new _exception2["default"]("The partial " + options.name + " could not be compiled when running in runtime-only mode");
        }
      }
      var container = {
        strict: function strict(obj, name, loc) {
          if (!obj || !(name in obj)) {
            throw new _exception2["default"]('"' + name + '" not defined in ' + obj, {
              loc
            });
          }
          return container.lookupProperty(obj, name);
        },
        lookupProperty: function lookupProperty(parent, propertyName) {
          var result = parent[propertyName];
          if (result == null) {
            return result;
          }
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return result;
          }
          if (_internalProtoAccess.resultIsAllowed(result, container.protoAccessControl, propertyName)) {
            return result;
          }
          return void 0;
        },
        lookup: function lookup(depths, name) {
          var len = depths.length;
          for (var i = 0; i < len; i++) {
            var result = depths[i] && container.lookupProperty(depths[i], name);
            if (result != null) {
              return depths[i][name];
            }
          }
        },
        lambda: function lambda(current, context) {
          return typeof current === "function" ? current.call(context) : current;
        },
        escapeExpression: Utils.escapeExpression,
        invokePartial: invokePartialWrapper,
        fn: function fn(i) {
          var ret2 = templateSpec[i];
          ret2.decorator = templateSpec[i + "_d"];
          return ret2;
        },
        programs: [],
        program: function program(i, data, declaredBlockParams, blockParams, depths) {
          var programWrapper = this.programs[i], fn = this.fn(i);
          if (data || depths || blockParams || declaredBlockParams) {
            programWrapper = wrapProgram(this, i, fn, data, declaredBlockParams, blockParams, depths);
          } else if (!programWrapper) {
            programWrapper = this.programs[i] = wrapProgram(this, i, fn);
          }
          return programWrapper;
        },
        data: function data(value2, depth) {
          while (value2 && depth--) {
            value2 = value2._parent;
          }
          return value2;
        },
        mergeIfNeeded: function mergeIfNeeded(param, common) {
          var obj = param || common;
          if (param && common && param !== common) {
            obj = Utils.extend({}, common, param);
          }
          return obj;
        },
        nullContext: Object.seal({}),
        noop: env.VM.noop,
        compilerInfo: templateSpec.compiler
      };
      function ret(context) {
        var options = arguments.length <= 1 || arguments[1] === void 0 ? {} : arguments[1];
        var data = options.data;
        ret._setup(options);
        if (!options.partial && templateSpec.useData) {
          data = initData(context, data);
        }
        var depths = void 0, blockParams = templateSpec.useBlockParams ? [] : void 0;
        if (templateSpec.useDepths) {
          if (options.depths) {
            depths = context != options.depths[0] ? [context].concat(options.depths) : options.depths;
          } else {
            depths = [context];
          }
        }
        function main(context2) {
          return "" + templateSpec.main(container, context2, container.helpers, container.partials, data, blockParams, depths);
        }
        main = executeDecorators(templateSpec.main, main, container, options.depths || [], data, blockParams);
        return main(context, options);
      }
      ret.isTop = true;
      ret._setup = function(options) {
        if (!options.partial) {
          var mergedHelpers = Utils.extend({}, env.helpers, options.helpers);
          wrapHelpersToPassLookupProperty(mergedHelpers, container);
          container.helpers = mergedHelpers;
          if (templateSpec.usePartial) {
            container.partials = container.mergeIfNeeded(options.partials, env.partials);
          }
          if (templateSpec.usePartial || templateSpec.useDecorators) {
            container.decorators = Utils.extend({}, env.decorators, options.decorators);
          }
          container.hooks = {};
          container.protoAccessControl = _internalProtoAccess.createProtoAccessControl(options);
          var keepHelperInHelpers = options.allowCallsToHelperMissing || templateWasPrecompiledWithCompilerV7;
          _helpers.moveHelperToHooks(container, "helperMissing", keepHelperInHelpers);
          _helpers.moveHelperToHooks(container, "blockHelperMissing", keepHelperInHelpers);
        } else {
          container.protoAccessControl = options.protoAccessControl;
          container.helpers = options.helpers;
          container.partials = options.partials;
          container.decorators = options.decorators;
          container.hooks = options.hooks;
        }
      };
      ret._child = function(i, data, blockParams, depths) {
        if (templateSpec.useBlockParams && !blockParams) {
          throw new _exception2["default"]("must pass block params");
        }
        if (templateSpec.useDepths && !depths) {
          throw new _exception2["default"]("must pass parent depths");
        }
        return wrapProgram(container, i, templateSpec[i], data, 0, blockParams, depths);
      };
      return ret;
    }
    function wrapProgram(container, i, fn, data, declaredBlockParams, blockParams, depths) {
      function prog(context) {
        var options = arguments.length <= 1 || arguments[1] === void 0 ? {} : arguments[1];
        var currentDepths = depths;
        if (depths && context != depths[0] && !(context === container.nullContext && depths[0] === null)) {
          currentDepths = [context].concat(depths);
        }
        return fn(container, context, container.helpers, container.partials, options.data || data, blockParams && [options.blockParams].concat(blockParams), currentDepths);
      }
      prog = executeDecorators(fn, prog, container, depths, data, blockParams);
      prog.program = i;
      prog.depth = depths ? depths.length : 0;
      prog.blockParams = declaredBlockParams || 0;
      return prog;
    }
    function resolvePartial(partial, context, options) {
      if (!partial) {
        if (options.name === "@partial-block") {
          partial = options.data["partial-block"];
        } else {
          partial = options.partials[options.name];
        }
      } else if (!partial.call && !options.name) {
        options.name = partial;
        partial = options.partials[partial];
      }
      return partial;
    }
    function invokePartial(partial, context, options) {
      var currentPartialBlock = options.data && options.data["partial-block"];
      options.partial = true;
      if (options.ids) {
        options.data.contextPath = options.ids[0] || options.data.contextPath;
      }
      var partialBlock = void 0;
      if (options.fn && options.fn !== noop) {
        (function() {
          options.data = _base.createFrame(options.data);
          var fn = options.fn;
          partialBlock = options.data["partial-block"] = function partialBlockWrapper(context2) {
            var options2 = arguments.length <= 1 || arguments[1] === void 0 ? {} : arguments[1];
            options2.data = _base.createFrame(options2.data);
            options2.data["partial-block"] = currentPartialBlock;
            return fn(context2, options2);
          };
          if (fn.partials) {
            options.partials = Utils.extend({}, options.partials, fn.partials);
          }
        })();
      }
      if (partial === void 0 && partialBlock) {
        partial = partialBlock;
      }
      if (partial === void 0) {
        throw new _exception2["default"]("The partial " + options.name + " could not be found");
      } else if (partial instanceof Function) {
        return partial(context, options);
      }
    }
    function noop() {
      return "";
    }
    function initData(context, data) {
      if (!data || !("root" in data)) {
        data = data ? _base.createFrame(data) : {};
        data.root = context;
      }
      return data;
    }
    function executeDecorators(fn, prog, container, depths, data, blockParams) {
      if (fn.decorator) {
        var props = {};
        prog = fn.decorator(prog, props, container, depths && depths[0], data, blockParams, depths);
        Utils.extend(prog, props);
      }
      return prog;
    }
    function wrapHelpersToPassLookupProperty(mergedHelpers, container) {
      Object.keys(mergedHelpers).forEach(function(helperName) {
        var helper = mergedHelpers[helperName];
        mergedHelpers[helperName] = passLookupPropertyOption(helper, container);
      });
    }
    function passLookupPropertyOption(helper, container) {
      var lookupProperty = container.lookupProperty;
      return _internalWrapHelper.wrapHelper(helper, function(options) {
        return Utils.extend({ lookupProperty }, options);
      });
    }
  }
});

// node_modules/handlebars/dist/cjs/handlebars/no-conflict.js
var require_no_conflict = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars/no-conflict.js"(exports, module2) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = function(Handlebars) {
      var root = typeof global !== "undefined" ? global : window, $Handlebars = root.Handlebars;
      Handlebars.noConflict = function() {
        if (root.Handlebars === Handlebars) {
          root.Handlebars = $Handlebars;
        }
        return Handlebars;
      };
    };
    module2.exports = exports["default"];
  }
});

// node_modules/handlebars/dist/cjs/handlebars.runtime.js
var require_handlebars_runtime = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars.runtime.js"(exports, module2) {
    "use strict";
    exports.__esModule = true;
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      } else {
        var newObj = {};
        if (obj != null) {
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key))
              newObj[key] = obj[key];
          }
        }
        newObj["default"] = obj;
        return newObj;
      }
    }
    var _handlebarsBase = require_base();
    var base = _interopRequireWildcard(_handlebarsBase);
    var _handlebarsSafeString = require_safe_string();
    var _handlebarsSafeString2 = _interopRequireDefault(_handlebarsSafeString);
    var _handlebarsException = require_exception();
    var _handlebarsException2 = _interopRequireDefault(_handlebarsException);
    var _handlebarsUtils = require_utils();
    var Utils = _interopRequireWildcard(_handlebarsUtils);
    var _handlebarsRuntime = require_runtime();
    var runtime = _interopRequireWildcard(_handlebarsRuntime);
    var _handlebarsNoConflict = require_no_conflict();
    var _handlebarsNoConflict2 = _interopRequireDefault(_handlebarsNoConflict);
    function create() {
      var hb = new base.HandlebarsEnvironment();
      Utils.extend(hb, base);
      hb.SafeString = _handlebarsSafeString2["default"];
      hb.Exception = _handlebarsException2["default"];
      hb.Utils = Utils;
      hb.escapeExpression = Utils.escapeExpression;
      hb.VM = runtime;
      hb.template = function(spec) {
        return runtime.template(spec, hb);
      };
      return hb;
    }
    var inst = create();
    inst.create = create;
    _handlebarsNoConflict2["default"](inst);
    inst["default"] = inst;
    exports["default"] = inst;
    module2.exports = exports["default"];
  }
});

// node_modules/handlebars/dist/cjs/handlebars/compiler/ast.js
var require_ast = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars/compiler/ast.js"(exports, module2) {
    "use strict";
    exports.__esModule = true;
    var AST = {
      helpers: {
        helperExpression: function helperExpression(node) {
          return node.type === "SubExpression" || (node.type === "MustacheStatement" || node.type === "BlockStatement") && !!(node.params && node.params.length || node.hash);
        },
        scopedId: function scopedId(path) {
          return /^\.|this\b/.test(path.original);
        },
        simpleId: function simpleId(path) {
          return path.parts.length === 1 && !AST.helpers.scopedId(path) && !path.depth;
        }
      }
    };
    exports["default"] = AST;
    module2.exports = exports["default"];
  }
});

// node_modules/handlebars/dist/cjs/handlebars/compiler/parser.js
var require_parser = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars/compiler/parser.js"(exports, module2) {
    "use strict";
    exports.__esModule = true;
    var handlebars2 = function() {
      var parser = {
        trace: function trace() {
        },
        yy: {},
        symbols_: { "error": 2, "root": 3, "program": 4, "EOF": 5, "program_repetition0": 6, "statement": 7, "mustache": 8, "block": 9, "rawBlock": 10, "partial": 11, "partialBlock": 12, "content": 13, "COMMENT": 14, "CONTENT": 15, "openRawBlock": 16, "rawBlock_repetition0": 17, "END_RAW_BLOCK": 18, "OPEN_RAW_BLOCK": 19, "helperName": 20, "openRawBlock_repetition0": 21, "openRawBlock_option0": 22, "CLOSE_RAW_BLOCK": 23, "openBlock": 24, "block_option0": 25, "closeBlock": 26, "openInverse": 27, "block_option1": 28, "OPEN_BLOCK": 29, "openBlock_repetition0": 30, "openBlock_option0": 31, "openBlock_option1": 32, "CLOSE": 33, "OPEN_INVERSE": 34, "openInverse_repetition0": 35, "openInverse_option0": 36, "openInverse_option1": 37, "openInverseChain": 38, "OPEN_INVERSE_CHAIN": 39, "openInverseChain_repetition0": 40, "openInverseChain_option0": 41, "openInverseChain_option1": 42, "inverseAndProgram": 43, "INVERSE": 44, "inverseChain": 45, "inverseChain_option0": 46, "OPEN_ENDBLOCK": 47, "OPEN": 48, "mustache_repetition0": 49, "mustache_option0": 50, "OPEN_UNESCAPED": 51, "mustache_repetition1": 52, "mustache_option1": 53, "CLOSE_UNESCAPED": 54, "OPEN_PARTIAL": 55, "partialName": 56, "partial_repetition0": 57, "partial_option0": 58, "openPartialBlock": 59, "OPEN_PARTIAL_BLOCK": 60, "openPartialBlock_repetition0": 61, "openPartialBlock_option0": 62, "param": 63, "sexpr": 64, "OPEN_SEXPR": 65, "sexpr_repetition0": 66, "sexpr_option0": 67, "CLOSE_SEXPR": 68, "hash": 69, "hash_repetition_plus0": 70, "hashSegment": 71, "ID": 72, "EQUALS": 73, "blockParams": 74, "OPEN_BLOCK_PARAMS": 75, "blockParams_repetition_plus0": 76, "CLOSE_BLOCK_PARAMS": 77, "path": 78, "dataName": 79, "STRING": 80, "NUMBER": 81, "BOOLEAN": 82, "UNDEFINED": 83, "NULL": 84, "DATA": 85, "pathSegments": 86, "SEP": 87, "$accept": 0, "$end": 1 },
        terminals_: { 2: "error", 5: "EOF", 14: "COMMENT", 15: "CONTENT", 18: "END_RAW_BLOCK", 19: "OPEN_RAW_BLOCK", 23: "CLOSE_RAW_BLOCK", 29: "OPEN_BLOCK", 33: "CLOSE", 34: "OPEN_INVERSE", 39: "OPEN_INVERSE_CHAIN", 44: "INVERSE", 47: "OPEN_ENDBLOCK", 48: "OPEN", 51: "OPEN_UNESCAPED", 54: "CLOSE_UNESCAPED", 55: "OPEN_PARTIAL", 60: "OPEN_PARTIAL_BLOCK", 65: "OPEN_SEXPR", 68: "CLOSE_SEXPR", 72: "ID", 73: "EQUALS", 75: "OPEN_BLOCK_PARAMS", 77: "CLOSE_BLOCK_PARAMS", 80: "STRING", 81: "NUMBER", 82: "BOOLEAN", 83: "UNDEFINED", 84: "NULL", 85: "DATA", 87: "SEP" },
        productions_: [0, [3, 2], [4, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [13, 1], [10, 3], [16, 5], [9, 4], [9, 4], [24, 6], [27, 6], [38, 6], [43, 2], [45, 3], [45, 1], [26, 3], [8, 5], [8, 5], [11, 5], [12, 3], [59, 5], [63, 1], [63, 1], [64, 5], [69, 1], [71, 3], [74, 3], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [56, 1], [56, 1], [79, 2], [78, 1], [86, 3], [86, 1], [6, 0], [6, 2], [17, 0], [17, 2], [21, 0], [21, 2], [22, 0], [22, 1], [25, 0], [25, 1], [28, 0], [28, 1], [30, 0], [30, 2], [31, 0], [31, 1], [32, 0], [32, 1], [35, 0], [35, 2], [36, 0], [36, 1], [37, 0], [37, 1], [40, 0], [40, 2], [41, 0], [41, 1], [42, 0], [42, 1], [46, 0], [46, 1], [49, 0], [49, 2], [50, 0], [50, 1], [52, 0], [52, 2], [53, 0], [53, 1], [57, 0], [57, 2], [58, 0], [58, 1], [61, 0], [61, 2], [62, 0], [62, 1], [66, 0], [66, 2], [67, 0], [67, 1], [70, 1], [70, 2], [76, 1], [76, 2]],
        performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$) {
          var $0 = $$.length - 1;
          switch (yystate) {
            case 1:
              return $$[$0 - 1];
              break;
            case 2:
              this.$ = yy.prepareProgram($$[$0]);
              break;
            case 3:
              this.$ = $$[$0];
              break;
            case 4:
              this.$ = $$[$0];
              break;
            case 5:
              this.$ = $$[$0];
              break;
            case 6:
              this.$ = $$[$0];
              break;
            case 7:
              this.$ = $$[$0];
              break;
            case 8:
              this.$ = $$[$0];
              break;
            case 9:
              this.$ = {
                type: "CommentStatement",
                value: yy.stripComment($$[$0]),
                strip: yy.stripFlags($$[$0], $$[$0]),
                loc: yy.locInfo(this._$)
              };
              break;
            case 10:
              this.$ = {
                type: "ContentStatement",
                original: $$[$0],
                value: $$[$0],
                loc: yy.locInfo(this._$)
              };
              break;
            case 11:
              this.$ = yy.prepareRawBlock($$[$0 - 2], $$[$0 - 1], $$[$0], this._$);
              break;
            case 12:
              this.$ = { path: $$[$0 - 3], params: $$[$0 - 2], hash: $$[$0 - 1] };
              break;
            case 13:
              this.$ = yy.prepareBlock($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0], false, this._$);
              break;
            case 14:
              this.$ = yy.prepareBlock($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0], true, this._$);
              break;
            case 15:
              this.$ = { open: $$[$0 - 5], path: $$[$0 - 4], params: $$[$0 - 3], hash: $$[$0 - 2], blockParams: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 5], $$[$0]) };
              break;
            case 16:
              this.$ = { path: $$[$0 - 4], params: $$[$0 - 3], hash: $$[$0 - 2], blockParams: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 5], $$[$0]) };
              break;
            case 17:
              this.$ = { path: $$[$0 - 4], params: $$[$0 - 3], hash: $$[$0 - 2], blockParams: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 5], $$[$0]) };
              break;
            case 18:
              this.$ = { strip: yy.stripFlags($$[$0 - 1], $$[$0 - 1]), program: $$[$0] };
              break;
            case 19:
              var inverse = yy.prepareBlock($$[$0 - 2], $$[$0 - 1], $$[$0], $$[$0], false, this._$), program = yy.prepareProgram([inverse], $$[$0 - 1].loc);
              program.chained = true;
              this.$ = { strip: $$[$0 - 2].strip, program, chain: true };
              break;
            case 20:
              this.$ = $$[$0];
              break;
            case 21:
              this.$ = { path: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 2], $$[$0]) };
              break;
            case 22:
              this.$ = yy.prepareMustache($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0 - 4], yy.stripFlags($$[$0 - 4], $$[$0]), this._$);
              break;
            case 23:
              this.$ = yy.prepareMustache($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0 - 4], yy.stripFlags($$[$0 - 4], $$[$0]), this._$);
              break;
            case 24:
              this.$ = {
                type: "PartialStatement",
                name: $$[$0 - 3],
                params: $$[$0 - 2],
                hash: $$[$0 - 1],
                indent: "",
                strip: yy.stripFlags($$[$0 - 4], $$[$0]),
                loc: yy.locInfo(this._$)
              };
              break;
            case 25:
              this.$ = yy.preparePartialBlock($$[$0 - 2], $$[$0 - 1], $$[$0], this._$);
              break;
            case 26:
              this.$ = { path: $$[$0 - 3], params: $$[$0 - 2], hash: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 4], $$[$0]) };
              break;
            case 27:
              this.$ = $$[$0];
              break;
            case 28:
              this.$ = $$[$0];
              break;
            case 29:
              this.$ = {
                type: "SubExpression",
                path: $$[$0 - 3],
                params: $$[$0 - 2],
                hash: $$[$0 - 1],
                loc: yy.locInfo(this._$)
              };
              break;
            case 30:
              this.$ = { type: "Hash", pairs: $$[$0], loc: yy.locInfo(this._$) };
              break;
            case 31:
              this.$ = { type: "HashPair", key: yy.id($$[$0 - 2]), value: $$[$0], loc: yy.locInfo(this._$) };
              break;
            case 32:
              this.$ = yy.id($$[$0 - 1]);
              break;
            case 33:
              this.$ = $$[$0];
              break;
            case 34:
              this.$ = $$[$0];
              break;
            case 35:
              this.$ = { type: "StringLiteral", value: $$[$0], original: $$[$0], loc: yy.locInfo(this._$) };
              break;
            case 36:
              this.$ = { type: "NumberLiteral", value: Number($$[$0]), original: Number($$[$0]), loc: yy.locInfo(this._$) };
              break;
            case 37:
              this.$ = { type: "BooleanLiteral", value: $$[$0] === "true", original: $$[$0] === "true", loc: yy.locInfo(this._$) };
              break;
            case 38:
              this.$ = { type: "UndefinedLiteral", original: void 0, value: void 0, loc: yy.locInfo(this._$) };
              break;
            case 39:
              this.$ = { type: "NullLiteral", original: null, value: null, loc: yy.locInfo(this._$) };
              break;
            case 40:
              this.$ = $$[$0];
              break;
            case 41:
              this.$ = $$[$0];
              break;
            case 42:
              this.$ = yy.preparePath(true, $$[$0], this._$);
              break;
            case 43:
              this.$ = yy.preparePath(false, $$[$0], this._$);
              break;
            case 44:
              $$[$0 - 2].push({ part: yy.id($$[$0]), original: $$[$0], separator: $$[$0 - 1] });
              this.$ = $$[$0 - 2];
              break;
            case 45:
              this.$ = [{ part: yy.id($$[$0]), original: $$[$0] }];
              break;
            case 46:
              this.$ = [];
              break;
            case 47:
              $$[$0 - 1].push($$[$0]);
              break;
            case 48:
              this.$ = [];
              break;
            case 49:
              $$[$0 - 1].push($$[$0]);
              break;
            case 50:
              this.$ = [];
              break;
            case 51:
              $$[$0 - 1].push($$[$0]);
              break;
            case 58:
              this.$ = [];
              break;
            case 59:
              $$[$0 - 1].push($$[$0]);
              break;
            case 64:
              this.$ = [];
              break;
            case 65:
              $$[$0 - 1].push($$[$0]);
              break;
            case 70:
              this.$ = [];
              break;
            case 71:
              $$[$0 - 1].push($$[$0]);
              break;
            case 78:
              this.$ = [];
              break;
            case 79:
              $$[$0 - 1].push($$[$0]);
              break;
            case 82:
              this.$ = [];
              break;
            case 83:
              $$[$0 - 1].push($$[$0]);
              break;
            case 86:
              this.$ = [];
              break;
            case 87:
              $$[$0 - 1].push($$[$0]);
              break;
            case 90:
              this.$ = [];
              break;
            case 91:
              $$[$0 - 1].push($$[$0]);
              break;
            case 94:
              this.$ = [];
              break;
            case 95:
              $$[$0 - 1].push($$[$0]);
              break;
            case 98:
              this.$ = [$$[$0]];
              break;
            case 99:
              $$[$0 - 1].push($$[$0]);
              break;
            case 100:
              this.$ = [$$[$0]];
              break;
            case 101:
              $$[$0 - 1].push($$[$0]);
              break;
          }
        },
        table: [{ 3: 1, 4: 2, 5: [2, 46], 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 1: [3] }, { 5: [1, 4] }, { 5: [2, 2], 7: 5, 8: 6, 9: 7, 10: 8, 11: 9, 12: 10, 13: 11, 14: [1, 12], 15: [1, 20], 16: 17, 19: [1, 23], 24: 15, 27: 16, 29: [1, 21], 34: [1, 22], 39: [2, 2], 44: [2, 2], 47: [2, 2], 48: [1, 13], 51: [1, 14], 55: [1, 18], 59: 19, 60: [1, 24] }, { 1: [2, 1] }, { 5: [2, 47], 14: [2, 47], 15: [2, 47], 19: [2, 47], 29: [2, 47], 34: [2, 47], 39: [2, 47], 44: [2, 47], 47: [2, 47], 48: [2, 47], 51: [2, 47], 55: [2, 47], 60: [2, 47] }, { 5: [2, 3], 14: [2, 3], 15: [2, 3], 19: [2, 3], 29: [2, 3], 34: [2, 3], 39: [2, 3], 44: [2, 3], 47: [2, 3], 48: [2, 3], 51: [2, 3], 55: [2, 3], 60: [2, 3] }, { 5: [2, 4], 14: [2, 4], 15: [2, 4], 19: [2, 4], 29: [2, 4], 34: [2, 4], 39: [2, 4], 44: [2, 4], 47: [2, 4], 48: [2, 4], 51: [2, 4], 55: [2, 4], 60: [2, 4] }, { 5: [2, 5], 14: [2, 5], 15: [2, 5], 19: [2, 5], 29: [2, 5], 34: [2, 5], 39: [2, 5], 44: [2, 5], 47: [2, 5], 48: [2, 5], 51: [2, 5], 55: [2, 5], 60: [2, 5] }, { 5: [2, 6], 14: [2, 6], 15: [2, 6], 19: [2, 6], 29: [2, 6], 34: [2, 6], 39: [2, 6], 44: [2, 6], 47: [2, 6], 48: [2, 6], 51: [2, 6], 55: [2, 6], 60: [2, 6] }, { 5: [2, 7], 14: [2, 7], 15: [2, 7], 19: [2, 7], 29: [2, 7], 34: [2, 7], 39: [2, 7], 44: [2, 7], 47: [2, 7], 48: [2, 7], 51: [2, 7], 55: [2, 7], 60: [2, 7] }, { 5: [2, 8], 14: [2, 8], 15: [2, 8], 19: [2, 8], 29: [2, 8], 34: [2, 8], 39: [2, 8], 44: [2, 8], 47: [2, 8], 48: [2, 8], 51: [2, 8], 55: [2, 8], 60: [2, 8] }, { 5: [2, 9], 14: [2, 9], 15: [2, 9], 19: [2, 9], 29: [2, 9], 34: [2, 9], 39: [2, 9], 44: [2, 9], 47: [2, 9], 48: [2, 9], 51: [2, 9], 55: [2, 9], 60: [2, 9] }, { 20: 25, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 36, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 4: 37, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 39: [2, 46], 44: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 4: 38, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 44: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 15: [2, 48], 17: 39, 18: [2, 48] }, { 20: 41, 56: 40, 64: 42, 65: [1, 43], 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 4: 44, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 5: [2, 10], 14: [2, 10], 15: [2, 10], 18: [2, 10], 19: [2, 10], 29: [2, 10], 34: [2, 10], 39: [2, 10], 44: [2, 10], 47: [2, 10], 48: [2, 10], 51: [2, 10], 55: [2, 10], 60: [2, 10] }, { 20: 45, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 46, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 47, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 41, 56: 48, 64: 42, 65: [1, 43], 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 33: [2, 78], 49: 49, 65: [2, 78], 72: [2, 78], 80: [2, 78], 81: [2, 78], 82: [2, 78], 83: [2, 78], 84: [2, 78], 85: [2, 78] }, { 23: [2, 33], 33: [2, 33], 54: [2, 33], 65: [2, 33], 68: [2, 33], 72: [2, 33], 75: [2, 33], 80: [2, 33], 81: [2, 33], 82: [2, 33], 83: [2, 33], 84: [2, 33], 85: [2, 33] }, { 23: [2, 34], 33: [2, 34], 54: [2, 34], 65: [2, 34], 68: [2, 34], 72: [2, 34], 75: [2, 34], 80: [2, 34], 81: [2, 34], 82: [2, 34], 83: [2, 34], 84: [2, 34], 85: [2, 34] }, { 23: [2, 35], 33: [2, 35], 54: [2, 35], 65: [2, 35], 68: [2, 35], 72: [2, 35], 75: [2, 35], 80: [2, 35], 81: [2, 35], 82: [2, 35], 83: [2, 35], 84: [2, 35], 85: [2, 35] }, { 23: [2, 36], 33: [2, 36], 54: [2, 36], 65: [2, 36], 68: [2, 36], 72: [2, 36], 75: [2, 36], 80: [2, 36], 81: [2, 36], 82: [2, 36], 83: [2, 36], 84: [2, 36], 85: [2, 36] }, { 23: [2, 37], 33: [2, 37], 54: [2, 37], 65: [2, 37], 68: [2, 37], 72: [2, 37], 75: [2, 37], 80: [2, 37], 81: [2, 37], 82: [2, 37], 83: [2, 37], 84: [2, 37], 85: [2, 37] }, { 23: [2, 38], 33: [2, 38], 54: [2, 38], 65: [2, 38], 68: [2, 38], 72: [2, 38], 75: [2, 38], 80: [2, 38], 81: [2, 38], 82: [2, 38], 83: [2, 38], 84: [2, 38], 85: [2, 38] }, { 23: [2, 39], 33: [2, 39], 54: [2, 39], 65: [2, 39], 68: [2, 39], 72: [2, 39], 75: [2, 39], 80: [2, 39], 81: [2, 39], 82: [2, 39], 83: [2, 39], 84: [2, 39], 85: [2, 39] }, { 23: [2, 43], 33: [2, 43], 54: [2, 43], 65: [2, 43], 68: [2, 43], 72: [2, 43], 75: [2, 43], 80: [2, 43], 81: [2, 43], 82: [2, 43], 83: [2, 43], 84: [2, 43], 85: [2, 43], 87: [1, 50] }, { 72: [1, 35], 86: 51 }, { 23: [2, 45], 33: [2, 45], 54: [2, 45], 65: [2, 45], 68: [2, 45], 72: [2, 45], 75: [2, 45], 80: [2, 45], 81: [2, 45], 82: [2, 45], 83: [2, 45], 84: [2, 45], 85: [2, 45], 87: [2, 45] }, { 52: 52, 54: [2, 82], 65: [2, 82], 72: [2, 82], 80: [2, 82], 81: [2, 82], 82: [2, 82], 83: [2, 82], 84: [2, 82], 85: [2, 82] }, { 25: 53, 38: 55, 39: [1, 57], 43: 56, 44: [1, 58], 45: 54, 47: [2, 54] }, { 28: 59, 43: 60, 44: [1, 58], 47: [2, 56] }, { 13: 62, 15: [1, 20], 18: [1, 61] }, { 33: [2, 86], 57: 63, 65: [2, 86], 72: [2, 86], 80: [2, 86], 81: [2, 86], 82: [2, 86], 83: [2, 86], 84: [2, 86], 85: [2, 86] }, { 33: [2, 40], 65: [2, 40], 72: [2, 40], 80: [2, 40], 81: [2, 40], 82: [2, 40], 83: [2, 40], 84: [2, 40], 85: [2, 40] }, { 33: [2, 41], 65: [2, 41], 72: [2, 41], 80: [2, 41], 81: [2, 41], 82: [2, 41], 83: [2, 41], 84: [2, 41], 85: [2, 41] }, { 20: 64, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 26: 65, 47: [1, 66] }, { 30: 67, 33: [2, 58], 65: [2, 58], 72: [2, 58], 75: [2, 58], 80: [2, 58], 81: [2, 58], 82: [2, 58], 83: [2, 58], 84: [2, 58], 85: [2, 58] }, { 33: [2, 64], 35: 68, 65: [2, 64], 72: [2, 64], 75: [2, 64], 80: [2, 64], 81: [2, 64], 82: [2, 64], 83: [2, 64], 84: [2, 64], 85: [2, 64] }, { 21: 69, 23: [2, 50], 65: [2, 50], 72: [2, 50], 80: [2, 50], 81: [2, 50], 82: [2, 50], 83: [2, 50], 84: [2, 50], 85: [2, 50] }, { 33: [2, 90], 61: 70, 65: [2, 90], 72: [2, 90], 80: [2, 90], 81: [2, 90], 82: [2, 90], 83: [2, 90], 84: [2, 90], 85: [2, 90] }, { 20: 74, 33: [2, 80], 50: 71, 63: 72, 64: 75, 65: [1, 43], 69: 73, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 72: [1, 79] }, { 23: [2, 42], 33: [2, 42], 54: [2, 42], 65: [2, 42], 68: [2, 42], 72: [2, 42], 75: [2, 42], 80: [2, 42], 81: [2, 42], 82: [2, 42], 83: [2, 42], 84: [2, 42], 85: [2, 42], 87: [1, 50] }, { 20: 74, 53: 80, 54: [2, 84], 63: 81, 64: 75, 65: [1, 43], 69: 82, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 26: 83, 47: [1, 66] }, { 47: [2, 55] }, { 4: 84, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 39: [2, 46], 44: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 47: [2, 20] }, { 20: 85, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 4: 86, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 26: 87, 47: [1, 66] }, { 47: [2, 57] }, { 5: [2, 11], 14: [2, 11], 15: [2, 11], 19: [2, 11], 29: [2, 11], 34: [2, 11], 39: [2, 11], 44: [2, 11], 47: [2, 11], 48: [2, 11], 51: [2, 11], 55: [2, 11], 60: [2, 11] }, { 15: [2, 49], 18: [2, 49] }, { 20: 74, 33: [2, 88], 58: 88, 63: 89, 64: 75, 65: [1, 43], 69: 90, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 65: [2, 94], 66: 91, 68: [2, 94], 72: [2, 94], 80: [2, 94], 81: [2, 94], 82: [2, 94], 83: [2, 94], 84: [2, 94], 85: [2, 94] }, { 5: [2, 25], 14: [2, 25], 15: [2, 25], 19: [2, 25], 29: [2, 25], 34: [2, 25], 39: [2, 25], 44: [2, 25], 47: [2, 25], 48: [2, 25], 51: [2, 25], 55: [2, 25], 60: [2, 25] }, { 20: 92, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 74, 31: 93, 33: [2, 60], 63: 94, 64: 75, 65: [1, 43], 69: 95, 70: 76, 71: 77, 72: [1, 78], 75: [2, 60], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 74, 33: [2, 66], 36: 96, 63: 97, 64: 75, 65: [1, 43], 69: 98, 70: 76, 71: 77, 72: [1, 78], 75: [2, 66], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 74, 22: 99, 23: [2, 52], 63: 100, 64: 75, 65: [1, 43], 69: 101, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 74, 33: [2, 92], 62: 102, 63: 103, 64: 75, 65: [1, 43], 69: 104, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 33: [1, 105] }, { 33: [2, 79], 65: [2, 79], 72: [2, 79], 80: [2, 79], 81: [2, 79], 82: [2, 79], 83: [2, 79], 84: [2, 79], 85: [2, 79] }, { 33: [2, 81] }, { 23: [2, 27], 33: [2, 27], 54: [2, 27], 65: [2, 27], 68: [2, 27], 72: [2, 27], 75: [2, 27], 80: [2, 27], 81: [2, 27], 82: [2, 27], 83: [2, 27], 84: [2, 27], 85: [2, 27] }, { 23: [2, 28], 33: [2, 28], 54: [2, 28], 65: [2, 28], 68: [2, 28], 72: [2, 28], 75: [2, 28], 80: [2, 28], 81: [2, 28], 82: [2, 28], 83: [2, 28], 84: [2, 28], 85: [2, 28] }, { 23: [2, 30], 33: [2, 30], 54: [2, 30], 68: [2, 30], 71: 106, 72: [1, 107], 75: [2, 30] }, { 23: [2, 98], 33: [2, 98], 54: [2, 98], 68: [2, 98], 72: [2, 98], 75: [2, 98] }, { 23: [2, 45], 33: [2, 45], 54: [2, 45], 65: [2, 45], 68: [2, 45], 72: [2, 45], 73: [1, 108], 75: [2, 45], 80: [2, 45], 81: [2, 45], 82: [2, 45], 83: [2, 45], 84: [2, 45], 85: [2, 45], 87: [2, 45] }, { 23: [2, 44], 33: [2, 44], 54: [2, 44], 65: [2, 44], 68: [2, 44], 72: [2, 44], 75: [2, 44], 80: [2, 44], 81: [2, 44], 82: [2, 44], 83: [2, 44], 84: [2, 44], 85: [2, 44], 87: [2, 44] }, { 54: [1, 109] }, { 54: [2, 83], 65: [2, 83], 72: [2, 83], 80: [2, 83], 81: [2, 83], 82: [2, 83], 83: [2, 83], 84: [2, 83], 85: [2, 83] }, { 54: [2, 85] }, { 5: [2, 13], 14: [2, 13], 15: [2, 13], 19: [2, 13], 29: [2, 13], 34: [2, 13], 39: [2, 13], 44: [2, 13], 47: [2, 13], 48: [2, 13], 51: [2, 13], 55: [2, 13], 60: [2, 13] }, { 38: 55, 39: [1, 57], 43: 56, 44: [1, 58], 45: 111, 46: 110, 47: [2, 76] }, { 33: [2, 70], 40: 112, 65: [2, 70], 72: [2, 70], 75: [2, 70], 80: [2, 70], 81: [2, 70], 82: [2, 70], 83: [2, 70], 84: [2, 70], 85: [2, 70] }, { 47: [2, 18] }, { 5: [2, 14], 14: [2, 14], 15: [2, 14], 19: [2, 14], 29: [2, 14], 34: [2, 14], 39: [2, 14], 44: [2, 14], 47: [2, 14], 48: [2, 14], 51: [2, 14], 55: [2, 14], 60: [2, 14] }, { 33: [1, 113] }, { 33: [2, 87], 65: [2, 87], 72: [2, 87], 80: [2, 87], 81: [2, 87], 82: [2, 87], 83: [2, 87], 84: [2, 87], 85: [2, 87] }, { 33: [2, 89] }, { 20: 74, 63: 115, 64: 75, 65: [1, 43], 67: 114, 68: [2, 96], 69: 116, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 33: [1, 117] }, { 32: 118, 33: [2, 62], 74: 119, 75: [1, 120] }, { 33: [2, 59], 65: [2, 59], 72: [2, 59], 75: [2, 59], 80: [2, 59], 81: [2, 59], 82: [2, 59], 83: [2, 59], 84: [2, 59], 85: [2, 59] }, { 33: [2, 61], 75: [2, 61] }, { 33: [2, 68], 37: 121, 74: 122, 75: [1, 120] }, { 33: [2, 65], 65: [2, 65], 72: [2, 65], 75: [2, 65], 80: [2, 65], 81: [2, 65], 82: [2, 65], 83: [2, 65], 84: [2, 65], 85: [2, 65] }, { 33: [2, 67], 75: [2, 67] }, { 23: [1, 123] }, { 23: [2, 51], 65: [2, 51], 72: [2, 51], 80: [2, 51], 81: [2, 51], 82: [2, 51], 83: [2, 51], 84: [2, 51], 85: [2, 51] }, { 23: [2, 53] }, { 33: [1, 124] }, { 33: [2, 91], 65: [2, 91], 72: [2, 91], 80: [2, 91], 81: [2, 91], 82: [2, 91], 83: [2, 91], 84: [2, 91], 85: [2, 91] }, { 33: [2, 93] }, { 5: [2, 22], 14: [2, 22], 15: [2, 22], 19: [2, 22], 29: [2, 22], 34: [2, 22], 39: [2, 22], 44: [2, 22], 47: [2, 22], 48: [2, 22], 51: [2, 22], 55: [2, 22], 60: [2, 22] }, { 23: [2, 99], 33: [2, 99], 54: [2, 99], 68: [2, 99], 72: [2, 99], 75: [2, 99] }, { 73: [1, 108] }, { 20: 74, 63: 125, 64: 75, 65: [1, 43], 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 5: [2, 23], 14: [2, 23], 15: [2, 23], 19: [2, 23], 29: [2, 23], 34: [2, 23], 39: [2, 23], 44: [2, 23], 47: [2, 23], 48: [2, 23], 51: [2, 23], 55: [2, 23], 60: [2, 23] }, { 47: [2, 19] }, { 47: [2, 77] }, { 20: 74, 33: [2, 72], 41: 126, 63: 127, 64: 75, 65: [1, 43], 69: 128, 70: 76, 71: 77, 72: [1, 78], 75: [2, 72], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 5: [2, 24], 14: [2, 24], 15: [2, 24], 19: [2, 24], 29: [2, 24], 34: [2, 24], 39: [2, 24], 44: [2, 24], 47: [2, 24], 48: [2, 24], 51: [2, 24], 55: [2, 24], 60: [2, 24] }, { 68: [1, 129] }, { 65: [2, 95], 68: [2, 95], 72: [2, 95], 80: [2, 95], 81: [2, 95], 82: [2, 95], 83: [2, 95], 84: [2, 95], 85: [2, 95] }, { 68: [2, 97] }, { 5: [2, 21], 14: [2, 21], 15: [2, 21], 19: [2, 21], 29: [2, 21], 34: [2, 21], 39: [2, 21], 44: [2, 21], 47: [2, 21], 48: [2, 21], 51: [2, 21], 55: [2, 21], 60: [2, 21] }, { 33: [1, 130] }, { 33: [2, 63] }, { 72: [1, 132], 76: 131 }, { 33: [1, 133] }, { 33: [2, 69] }, { 15: [2, 12], 18: [2, 12] }, { 14: [2, 26], 15: [2, 26], 19: [2, 26], 29: [2, 26], 34: [2, 26], 47: [2, 26], 48: [2, 26], 51: [2, 26], 55: [2, 26], 60: [2, 26] }, { 23: [2, 31], 33: [2, 31], 54: [2, 31], 68: [2, 31], 72: [2, 31], 75: [2, 31] }, { 33: [2, 74], 42: 134, 74: 135, 75: [1, 120] }, { 33: [2, 71], 65: [2, 71], 72: [2, 71], 75: [2, 71], 80: [2, 71], 81: [2, 71], 82: [2, 71], 83: [2, 71], 84: [2, 71], 85: [2, 71] }, { 33: [2, 73], 75: [2, 73] }, { 23: [2, 29], 33: [2, 29], 54: [2, 29], 65: [2, 29], 68: [2, 29], 72: [2, 29], 75: [2, 29], 80: [2, 29], 81: [2, 29], 82: [2, 29], 83: [2, 29], 84: [2, 29], 85: [2, 29] }, { 14: [2, 15], 15: [2, 15], 19: [2, 15], 29: [2, 15], 34: [2, 15], 39: [2, 15], 44: [2, 15], 47: [2, 15], 48: [2, 15], 51: [2, 15], 55: [2, 15], 60: [2, 15] }, { 72: [1, 137], 77: [1, 136] }, { 72: [2, 100], 77: [2, 100] }, { 14: [2, 16], 15: [2, 16], 19: [2, 16], 29: [2, 16], 34: [2, 16], 44: [2, 16], 47: [2, 16], 48: [2, 16], 51: [2, 16], 55: [2, 16], 60: [2, 16] }, { 33: [1, 138] }, { 33: [2, 75] }, { 33: [2, 32] }, { 72: [2, 101], 77: [2, 101] }, { 14: [2, 17], 15: [2, 17], 19: [2, 17], 29: [2, 17], 34: [2, 17], 39: [2, 17], 44: [2, 17], 47: [2, 17], 48: [2, 17], 51: [2, 17], 55: [2, 17], 60: [2, 17] }],
        defaultActions: { 4: [2, 1], 54: [2, 55], 56: [2, 20], 60: [2, 57], 73: [2, 81], 82: [2, 85], 86: [2, 18], 90: [2, 89], 101: [2, 53], 104: [2, 93], 110: [2, 19], 111: [2, 77], 116: [2, 97], 119: [2, 63], 122: [2, 69], 135: [2, 75], 136: [2, 32] },
        parseError: function parseError(str, hash) {
          throw new Error(str);
        },
        parse: function parse(input) {
          var self2 = this, stack = [0], vstack = [null], lstack = [], table = this.table, yytext = "", yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;
          this.lexer.setInput(input);
          this.lexer.yy = this.yy;
          this.yy.lexer = this.lexer;
          this.yy.parser = this;
          if (typeof this.lexer.yylloc == "undefined")
            this.lexer.yylloc = {};
          var yyloc = this.lexer.yylloc;
          lstack.push(yyloc);
          var ranges = this.lexer.options && this.lexer.options.ranges;
          if (typeof this.yy.parseError === "function")
            this.parseError = this.yy.parseError;
          function popStack(n) {
            stack.length = stack.length - 2 * n;
            vstack.length = vstack.length - n;
            lstack.length = lstack.length - n;
          }
          function lex() {
            var token;
            token = self2.lexer.lex() || 1;
            if (typeof token !== "number") {
              token = self2.symbols_[token] || token;
            }
            return token;
          }
          var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;
          while (true) {
            state = stack[stack.length - 1];
            if (this.defaultActions[state]) {
              action = this.defaultActions[state];
            } else {
              if (symbol === null || typeof symbol == "undefined") {
                symbol = lex();
              }
              action = table[state] && table[state][symbol];
            }
            if (typeof action === "undefined" || !action.length || !action[0]) {
              var errStr = "";
              if (!recovering) {
                expected = [];
                for (p in table[state])
                  if (this.terminals_[p] && p > 2) {
                    expected.push("'" + this.terminals_[p] + "'");
                  }
                if (this.lexer.showPosition) {
                  errStr = "Parse error on line " + (yylineno + 1) + ":\n" + this.lexer.showPosition() + "\nExpecting " + expected.join(", ") + ", got '" + (this.terminals_[symbol] || symbol) + "'";
                } else {
                  errStr = "Parse error on line " + (yylineno + 1) + ": Unexpected " + (symbol == 1 ? "end of input" : "'" + (this.terminals_[symbol] || symbol) + "'");
                }
                this.parseError(errStr, { text: this.lexer.match, token: this.terminals_[symbol] || symbol, line: this.lexer.yylineno, loc: yyloc, expected });
              }
            }
            if (action[0] instanceof Array && action.length > 1) {
              throw new Error("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol);
            }
            switch (action[0]) {
              case 1:
                stack.push(symbol);
                vstack.push(this.lexer.yytext);
                lstack.push(this.lexer.yylloc);
                stack.push(action[1]);
                symbol = null;
                if (!preErrorSymbol) {
                  yyleng = this.lexer.yyleng;
                  yytext = this.lexer.yytext;
                  yylineno = this.lexer.yylineno;
                  yyloc = this.lexer.yylloc;
                  if (recovering > 0)
                    recovering--;
                } else {
                  symbol = preErrorSymbol;
                  preErrorSymbol = null;
                }
                break;
              case 2:
                len = this.productions_[action[1]][1];
                yyval.$ = vstack[vstack.length - len];
                yyval._$ = { first_line: lstack[lstack.length - (len || 1)].first_line, last_line: lstack[lstack.length - 1].last_line, first_column: lstack[lstack.length - (len || 1)].first_column, last_column: lstack[lstack.length - 1].last_column };
                if (ranges) {
                  yyval._$.range = [lstack[lstack.length - (len || 1)].range[0], lstack[lstack.length - 1].range[1]];
                }
                r = this.performAction.call(yyval, yytext, yyleng, yylineno, this.yy, action[1], vstack, lstack);
                if (typeof r !== "undefined") {
                  return r;
                }
                if (len) {
                  stack = stack.slice(0, -1 * len * 2);
                  vstack = vstack.slice(0, -1 * len);
                  lstack = lstack.slice(0, -1 * len);
                }
                stack.push(this.productions_[action[1]][0]);
                vstack.push(yyval.$);
                lstack.push(yyval._$);
                newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
                stack.push(newState);
                break;
              case 3:
                return true;
            }
          }
          return true;
        }
      };
      var lexer = function() {
        var lexer2 = {
          EOF: 1,
          parseError: function parseError(str, hash) {
            if (this.yy.parser) {
              this.yy.parser.parseError(str, hash);
            } else {
              throw new Error(str);
            }
          },
          setInput: function setInput(input) {
            this._input = input;
            this._more = this._less = this.done = false;
            this.yylineno = this.yyleng = 0;
            this.yytext = this.matched = this.match = "";
            this.conditionStack = ["INITIAL"];
            this.yylloc = { first_line: 1, first_column: 0, last_line: 1, last_column: 0 };
            if (this.options.ranges)
              this.yylloc.range = [0, 0];
            this.offset = 0;
            return this;
          },
          input: function input() {
            var ch = this._input[0];
            this.yytext += ch;
            this.yyleng++;
            this.offset++;
            this.match += ch;
            this.matched += ch;
            var lines = ch.match(/(?:\r\n?|\n).*/g);
            if (lines) {
              this.yylineno++;
              this.yylloc.last_line++;
            } else {
              this.yylloc.last_column++;
            }
            if (this.options.ranges)
              this.yylloc.range[1]++;
            this._input = this._input.slice(1);
            return ch;
          },
          unput: function unput(ch) {
            var len = ch.length;
            var lines = ch.split(/(?:\r\n?|\n)/g);
            this._input = ch + this._input;
            this.yytext = this.yytext.substr(0, this.yytext.length - len - 1);
            this.offset -= len;
            var oldLines = this.match.split(/(?:\r\n?|\n)/g);
            this.match = this.match.substr(0, this.match.length - 1);
            this.matched = this.matched.substr(0, this.matched.length - 1);
            if (lines.length - 1)
              this.yylineno -= lines.length - 1;
            var r = this.yylloc.range;
            this.yylloc = {
              first_line: this.yylloc.first_line,
              last_line: this.yylineno + 1,
              first_column: this.yylloc.first_column,
              last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
            };
            if (this.options.ranges) {
              this.yylloc.range = [r[0], r[0] + this.yyleng - len];
            }
            return this;
          },
          more: function more() {
            this._more = true;
            return this;
          },
          less: function less(n) {
            this.unput(this.match.slice(n));
          },
          pastInput: function pastInput() {
            var past = this.matched.substr(0, this.matched.length - this.match.length);
            return (past.length > 20 ? "..." : "") + past.substr(-20).replace(/\n/g, "");
          },
          upcomingInput: function upcomingInput() {
            var next = this.match;
            if (next.length < 20) {
              next += this._input.substr(0, 20 - next.length);
            }
            return (next.substr(0, 20) + (next.length > 20 ? "..." : "")).replace(/\n/g, "");
          },
          showPosition: function showPosition() {
            var pre = this.pastInput();
            var c = new Array(pre.length + 1).join("-");
            return pre + this.upcomingInput() + "\n" + c + "^";
          },
          next: function next() {
            if (this.done) {
              return this.EOF;
            }
            if (!this._input)
              this.done = true;
            var token, match, tempMatch, index, col, lines;
            if (!this._more) {
              this.yytext = "";
              this.match = "";
            }
            var rules = this._currentRules();
            for (var i = 0; i < rules.length; i++) {
              tempMatch = this._input.match(this.rules[rules[i]]);
              if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
                match = tempMatch;
                index = i;
                if (!this.options.flex)
                  break;
              }
            }
            if (match) {
              lines = match[0].match(/(?:\r\n?|\n).*/g);
              if (lines)
                this.yylineno += lines.length;
              this.yylloc = {
                first_line: this.yylloc.last_line,
                last_line: this.yylineno + 1,
                first_column: this.yylloc.last_column,
                last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length
              };
              this.yytext += match[0];
              this.match += match[0];
              this.matches = match;
              this.yyleng = this.yytext.length;
              if (this.options.ranges) {
                this.yylloc.range = [this.offset, this.offset += this.yyleng];
              }
              this._more = false;
              this._input = this._input.slice(match[0].length);
              this.matched += match[0];
              token = this.performAction.call(this, this.yy, this, rules[index], this.conditionStack[this.conditionStack.length - 1]);
              if (this.done && this._input)
                this.done = false;
              if (token)
                return token;
              else
                return;
            }
            if (this._input === "") {
              return this.EOF;
            } else {
              return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". Unrecognized text.\n" + this.showPosition(), { text: "", token: null, line: this.yylineno });
            }
          },
          lex: function lex() {
            var r = this.next();
            if (typeof r !== "undefined") {
              return r;
            } else {
              return this.lex();
            }
          },
          begin: function begin(condition) {
            this.conditionStack.push(condition);
          },
          popState: function popState() {
            return this.conditionStack.pop();
          },
          _currentRules: function _currentRules() {
            return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
          },
          topState: function topState() {
            return this.conditionStack[this.conditionStack.length - 2];
          },
          pushState: function begin(condition) {
            this.begin(condition);
          }
        };
        lexer2.options = {};
        lexer2.performAction = function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {
          function strip(start, end) {
            return yy_.yytext = yy_.yytext.substring(start, yy_.yyleng - end + start);
          }
          var YYSTATE = YY_START;
          switch ($avoiding_name_collisions) {
            case 0:
              if (yy_.yytext.slice(-2) === "\\\\") {
                strip(0, 1);
                this.begin("mu");
              } else if (yy_.yytext.slice(-1) === "\\") {
                strip(0, 1);
                this.begin("emu");
              } else {
                this.begin("mu");
              }
              if (yy_.yytext)
                return 15;
              break;
            case 1:
              return 15;
              break;
            case 2:
              this.popState();
              return 15;
              break;
            case 3:
              this.begin("raw");
              return 15;
              break;
            case 4:
              this.popState();
              if (this.conditionStack[this.conditionStack.length - 1] === "raw") {
                return 15;
              } else {
                strip(5, 9);
                return "END_RAW_BLOCK";
              }
              break;
            case 5:
              return 15;
              break;
            case 6:
              this.popState();
              return 14;
              break;
            case 7:
              return 65;
              break;
            case 8:
              return 68;
              break;
            case 9:
              return 19;
              break;
            case 10:
              this.popState();
              this.begin("raw");
              return 23;
              break;
            case 11:
              return 55;
              break;
            case 12:
              return 60;
              break;
            case 13:
              return 29;
              break;
            case 14:
              return 47;
              break;
            case 15:
              this.popState();
              return 44;
              break;
            case 16:
              this.popState();
              return 44;
              break;
            case 17:
              return 34;
              break;
            case 18:
              return 39;
              break;
            case 19:
              return 51;
              break;
            case 20:
              return 48;
              break;
            case 21:
              this.unput(yy_.yytext);
              this.popState();
              this.begin("com");
              break;
            case 22:
              this.popState();
              return 14;
              break;
            case 23:
              return 48;
              break;
            case 24:
              return 73;
              break;
            case 25:
              return 72;
              break;
            case 26:
              return 72;
              break;
            case 27:
              return 87;
              break;
            case 28:
              break;
            case 29:
              this.popState();
              return 54;
              break;
            case 30:
              this.popState();
              return 33;
              break;
            case 31:
              yy_.yytext = strip(1, 2).replace(/\\"/g, '"');
              return 80;
              break;
            case 32:
              yy_.yytext = strip(1, 2).replace(/\\'/g, "'");
              return 80;
              break;
            case 33:
              return 85;
              break;
            case 34:
              return 82;
              break;
            case 35:
              return 82;
              break;
            case 36:
              return 83;
              break;
            case 37:
              return 84;
              break;
            case 38:
              return 81;
              break;
            case 39:
              return 75;
              break;
            case 40:
              return 77;
              break;
            case 41:
              return 72;
              break;
            case 42:
              yy_.yytext = yy_.yytext.replace(/\\([\\\]])/g, "$1");
              return 72;
              break;
            case 43:
              return "INVALID";
              break;
            case 44:
              return 5;
              break;
          }
        };
        lexer2.rules = [/^(?:[^\x00]*?(?=(\{\{)))/, /^(?:[^\x00]+)/, /^(?:[^\x00]{2,}?(?=(\{\{|\\\{\{|\\\\\{\{|$)))/, /^(?:\{\{\{\{(?=[^\/]))/, /^(?:\{\{\{\{\/[^\s!"#%-,\.\/;->@\[-\^`\{-~]+(?=[=}\s\/.])\}\}\}\})/, /^(?:[^\x00]+?(?=(\{\{\{\{)))/, /^(?:[\s\S]*?--(~)?\}\})/, /^(?:\()/, /^(?:\))/, /^(?:\{\{\{\{)/, /^(?:\}\}\}\})/, /^(?:\{\{(~)?>)/, /^(?:\{\{(~)?#>)/, /^(?:\{\{(~)?#\*?)/, /^(?:\{\{(~)?\/)/, /^(?:\{\{(~)?\^\s*(~)?\}\})/, /^(?:\{\{(~)?\s*else\s*(~)?\}\})/, /^(?:\{\{(~)?\^)/, /^(?:\{\{(~)?\s*else\b)/, /^(?:\{\{(~)?\{)/, /^(?:\{\{(~)?&)/, /^(?:\{\{(~)?!--)/, /^(?:\{\{(~)?![\s\S]*?\}\})/, /^(?:\{\{(~)?\*?)/, /^(?:=)/, /^(?:\.\.)/, /^(?:\.(?=([=~}\s\/.)|])))/, /^(?:[\/.])/, /^(?:\s+)/, /^(?:\}(~)?\}\})/, /^(?:(~)?\}\})/, /^(?:"(\\["]|[^"])*")/, /^(?:'(\\[']|[^'])*')/, /^(?:@)/, /^(?:true(?=([~}\s)])))/, /^(?:false(?=([~}\s)])))/, /^(?:undefined(?=([~}\s)])))/, /^(?:null(?=([~}\s)])))/, /^(?:-?[0-9]+(?:\.[0-9]+)?(?=([~}\s)])))/, /^(?:as\s+\|)/, /^(?:\|)/, /^(?:([^\s!"#%-,\.\/;->@\[-\^`\{-~]+(?=([=~}\s\/.)|]))))/, /^(?:\[(\\\]|[^\]])*\])/, /^(?:.)/, /^(?:$)/];
        lexer2.conditions = { "mu": { "rules": [7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44], "inclusive": false }, "emu": { "rules": [2], "inclusive": false }, "com": { "rules": [6], "inclusive": false }, "raw": { "rules": [3, 4, 5], "inclusive": false }, "INITIAL": { "rules": [0, 1, 44], "inclusive": true } };
        return lexer2;
      }();
      parser.lexer = lexer;
      function Parser() {
        this.yy = {};
      }
      Parser.prototype = parser;
      parser.Parser = Parser;
      return new Parser();
    }();
    exports["default"] = handlebars2;
    module2.exports = exports["default"];
  }
});

// node_modules/handlebars/dist/cjs/handlebars/compiler/visitor.js
var require_visitor = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars/compiler/visitor.js"(exports, module2) {
    "use strict";
    exports.__esModule = true;
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var _exception = require_exception();
    var _exception2 = _interopRequireDefault(_exception);
    function Visitor() {
      this.parents = [];
    }
    Visitor.prototype = {
      constructor: Visitor,
      mutating: false,
      acceptKey: function acceptKey(node, name) {
        var value2 = this.accept(node[name]);
        if (this.mutating) {
          if (value2 && !Visitor.prototype[value2.type]) {
            throw new _exception2["default"]('Unexpected node type "' + value2.type + '" found when accepting ' + name + " on " + node.type);
          }
          node[name] = value2;
        }
      },
      acceptRequired: function acceptRequired(node, name) {
        this.acceptKey(node, name);
        if (!node[name]) {
          throw new _exception2["default"](node.type + " requires " + name);
        }
      },
      acceptArray: function acceptArray(array) {
        for (var i = 0, l = array.length; i < l; i++) {
          this.acceptKey(array, i);
          if (!array[i]) {
            array.splice(i, 1);
            i--;
            l--;
          }
        }
      },
      accept: function accept(object) {
        if (!object) {
          return;
        }
        if (!this[object.type]) {
          throw new _exception2["default"]("Unknown type: " + object.type, object);
        }
        if (this.current) {
          this.parents.unshift(this.current);
        }
        this.current = object;
        var ret = this[object.type](object);
        this.current = this.parents.shift();
        if (!this.mutating || ret) {
          return ret;
        } else if (ret !== false) {
          return object;
        }
      },
      Program: function Program(program) {
        this.acceptArray(program.body);
      },
      MustacheStatement: visitSubExpression,
      Decorator: visitSubExpression,
      BlockStatement: visitBlock,
      DecoratorBlock: visitBlock,
      PartialStatement: visitPartial,
      PartialBlockStatement: function PartialBlockStatement(partial) {
        visitPartial.call(this, partial);
        this.acceptKey(partial, "program");
      },
      ContentStatement: function ContentStatement() {
      },
      CommentStatement: function CommentStatement() {
      },
      SubExpression: visitSubExpression,
      PathExpression: function PathExpression() {
      },
      StringLiteral: function StringLiteral() {
      },
      NumberLiteral: function NumberLiteral() {
      },
      BooleanLiteral: function BooleanLiteral() {
      },
      UndefinedLiteral: function UndefinedLiteral() {
      },
      NullLiteral: function NullLiteral() {
      },
      Hash: function Hash(hash) {
        this.acceptArray(hash.pairs);
      },
      HashPair: function HashPair(pair) {
        this.acceptRequired(pair, "value");
      }
    };
    function visitSubExpression(mustache) {
      this.acceptRequired(mustache, "path");
      this.acceptArray(mustache.params);
      this.acceptKey(mustache, "hash");
    }
    function visitBlock(block) {
      visitSubExpression.call(this, block);
      this.acceptKey(block, "program");
      this.acceptKey(block, "inverse");
    }
    function visitPartial(partial) {
      this.acceptRequired(partial, "name");
      this.acceptArray(partial.params);
      this.acceptKey(partial, "hash");
    }
    exports["default"] = Visitor;
    module2.exports = exports["default"];
  }
});

// node_modules/handlebars/dist/cjs/handlebars/compiler/whitespace-control.js
var require_whitespace_control = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars/compiler/whitespace-control.js"(exports, module2) {
    "use strict";
    exports.__esModule = true;
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var _visitor = require_visitor();
    var _visitor2 = _interopRequireDefault(_visitor);
    function WhitespaceControl() {
      var options = arguments.length <= 0 || arguments[0] === void 0 ? {} : arguments[0];
      this.options = options;
    }
    WhitespaceControl.prototype = new _visitor2["default"]();
    WhitespaceControl.prototype.Program = function(program) {
      var doStandalone = !this.options.ignoreStandalone;
      var isRoot = !this.isRootSeen;
      this.isRootSeen = true;
      var body = program.body;
      for (var i = 0, l = body.length; i < l; i++) {
        var current = body[i], strip = this.accept(current);
        if (!strip) {
          continue;
        }
        var _isPrevWhitespace = isPrevWhitespace(body, i, isRoot), _isNextWhitespace = isNextWhitespace(body, i, isRoot), openStandalone = strip.openStandalone && _isPrevWhitespace, closeStandalone = strip.closeStandalone && _isNextWhitespace, inlineStandalone = strip.inlineStandalone && _isPrevWhitespace && _isNextWhitespace;
        if (strip.close) {
          omitRight(body, i, true);
        }
        if (strip.open) {
          omitLeft(body, i, true);
        }
        if (doStandalone && inlineStandalone) {
          omitRight(body, i);
          if (omitLeft(body, i)) {
            if (current.type === "PartialStatement") {
              current.indent = /([ \t]+$)/.exec(body[i - 1].original)[1];
            }
          }
        }
        if (doStandalone && openStandalone) {
          omitRight((current.program || current.inverse).body);
          omitLeft(body, i);
        }
        if (doStandalone && closeStandalone) {
          omitRight(body, i);
          omitLeft((current.inverse || current.program).body);
        }
      }
      return program;
    };
    WhitespaceControl.prototype.BlockStatement = WhitespaceControl.prototype.DecoratorBlock = WhitespaceControl.prototype.PartialBlockStatement = function(block) {
      this.accept(block.program);
      this.accept(block.inverse);
      var program = block.program || block.inverse, inverse = block.program && block.inverse, firstInverse = inverse, lastInverse = inverse;
      if (inverse && inverse.chained) {
        firstInverse = inverse.body[0].program;
        while (lastInverse.chained) {
          lastInverse = lastInverse.body[lastInverse.body.length - 1].program;
        }
      }
      var strip = {
        open: block.openStrip.open,
        close: block.closeStrip.close,
        openStandalone: isNextWhitespace(program.body),
        closeStandalone: isPrevWhitespace((firstInverse || program).body)
      };
      if (block.openStrip.close) {
        omitRight(program.body, null, true);
      }
      if (inverse) {
        var inverseStrip = block.inverseStrip;
        if (inverseStrip.open) {
          omitLeft(program.body, null, true);
        }
        if (inverseStrip.close) {
          omitRight(firstInverse.body, null, true);
        }
        if (block.closeStrip.open) {
          omitLeft(lastInverse.body, null, true);
        }
        if (!this.options.ignoreStandalone && isPrevWhitespace(program.body) && isNextWhitespace(firstInverse.body)) {
          omitLeft(program.body);
          omitRight(firstInverse.body);
        }
      } else if (block.closeStrip.open) {
        omitLeft(program.body, null, true);
      }
      return strip;
    };
    WhitespaceControl.prototype.Decorator = WhitespaceControl.prototype.MustacheStatement = function(mustache) {
      return mustache.strip;
    };
    WhitespaceControl.prototype.PartialStatement = WhitespaceControl.prototype.CommentStatement = function(node) {
      var strip = node.strip || {};
      return {
        inlineStandalone: true,
        open: strip.open,
        close: strip.close
      };
    };
    function isPrevWhitespace(body, i, isRoot) {
      if (i === void 0) {
        i = body.length;
      }
      var prev = body[i - 1], sibling = body[i - 2];
      if (!prev) {
        return isRoot;
      }
      if (prev.type === "ContentStatement") {
        return (sibling || !isRoot ? /\r?\n\s*?$/ : /(^|\r?\n)\s*?$/).test(prev.original);
      }
    }
    function isNextWhitespace(body, i, isRoot) {
      if (i === void 0) {
        i = -1;
      }
      var next = body[i + 1], sibling = body[i + 2];
      if (!next) {
        return isRoot;
      }
      if (next.type === "ContentStatement") {
        return (sibling || !isRoot ? /^\s*?\r?\n/ : /^\s*?(\r?\n|$)/).test(next.original);
      }
    }
    function omitRight(body, i, multiple) {
      var current = body[i == null ? 0 : i + 1];
      if (!current || current.type !== "ContentStatement" || !multiple && current.rightStripped) {
        return;
      }
      var original = current.value;
      current.value = current.value.replace(multiple ? /^\s+/ : /^[ \t]*\r?\n?/, "");
      current.rightStripped = current.value !== original;
    }
    function omitLeft(body, i, multiple) {
      var current = body[i == null ? body.length - 1 : i - 1];
      if (!current || current.type !== "ContentStatement" || !multiple && current.leftStripped) {
        return;
      }
      var original = current.value;
      current.value = current.value.replace(multiple ? /\s+$/ : /[ \t]+$/, "");
      current.leftStripped = current.value !== original;
      return current.leftStripped;
    }
    exports["default"] = WhitespaceControl;
    module2.exports = exports["default"];
  }
});

// node_modules/handlebars/dist/cjs/handlebars/compiler/helpers.js
var require_helpers2 = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars/compiler/helpers.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.SourceLocation = SourceLocation;
    exports.id = id;
    exports.stripFlags = stripFlags;
    exports.stripComment = stripComment;
    exports.preparePath = preparePath;
    exports.prepareMustache = prepareMustache;
    exports.prepareRawBlock = prepareRawBlock;
    exports.prepareBlock = prepareBlock;
    exports.prepareProgram = prepareProgram;
    exports.preparePartialBlock = preparePartialBlock;
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var _exception = require_exception();
    var _exception2 = _interopRequireDefault(_exception);
    function validateClose(open, close) {
      close = close.path ? close.path.original : close;
      if (open.path.original !== close) {
        var errorNode = { loc: open.path.loc };
        throw new _exception2["default"](open.path.original + " doesn't match " + close, errorNode);
      }
    }
    function SourceLocation(source, locInfo) {
      this.source = source;
      this.start = {
        line: locInfo.first_line,
        column: locInfo.first_column
      };
      this.end = {
        line: locInfo.last_line,
        column: locInfo.last_column
      };
    }
    function id(token) {
      if (/^\[.*\]$/.test(token)) {
        return token.substring(1, token.length - 1);
      } else {
        return token;
      }
    }
    function stripFlags(open, close) {
      return {
        open: open.charAt(2) === "~",
        close: close.charAt(close.length - 3) === "~"
      };
    }
    function stripComment(comment) {
      return comment.replace(/^\{\{~?!-?-?/, "").replace(/-?-?~?\}\}$/, "");
    }
    function preparePath(data, parts, loc) {
      loc = this.locInfo(loc);
      var original = data ? "@" : "", dig = [], depth = 0;
      for (var i = 0, l = parts.length; i < l; i++) {
        var part = parts[i].part, isLiteral = parts[i].original !== part;
        original += (parts[i].separator || "") + part;
        if (!isLiteral && (part === ".." || part === "." || part === "this")) {
          if (dig.length > 0) {
            throw new _exception2["default"]("Invalid path: " + original, { loc });
          } else if (part === "..") {
            depth++;
          }
        } else {
          dig.push(part);
        }
      }
      return {
        type: "PathExpression",
        data,
        depth,
        parts: dig,
        original,
        loc
      };
    }
    function prepareMustache(path, params, hash, open, strip, locInfo) {
      var escapeFlag = open.charAt(3) || open.charAt(2), escaped = escapeFlag !== "{" && escapeFlag !== "&";
      var decorator = /\*/.test(open);
      return {
        type: decorator ? "Decorator" : "MustacheStatement",
        path,
        params,
        hash,
        escaped,
        strip,
        loc: this.locInfo(locInfo)
      };
    }
    function prepareRawBlock(openRawBlock, contents, close, locInfo) {
      validateClose(openRawBlock, close);
      locInfo = this.locInfo(locInfo);
      var program = {
        type: "Program",
        body: contents,
        strip: {},
        loc: locInfo
      };
      return {
        type: "BlockStatement",
        path: openRawBlock.path,
        params: openRawBlock.params,
        hash: openRawBlock.hash,
        program,
        openStrip: {},
        inverseStrip: {},
        closeStrip: {},
        loc: locInfo
      };
    }
    function prepareBlock(openBlock, program, inverseAndProgram, close, inverted, locInfo) {
      if (close && close.path) {
        validateClose(openBlock, close);
      }
      var decorator = /\*/.test(openBlock.open);
      program.blockParams = openBlock.blockParams;
      var inverse = void 0, inverseStrip = void 0;
      if (inverseAndProgram) {
        if (decorator) {
          throw new _exception2["default"]("Unexpected inverse block on decorator", inverseAndProgram);
        }
        if (inverseAndProgram.chain) {
          inverseAndProgram.program.body[0].closeStrip = close.strip;
        }
        inverseStrip = inverseAndProgram.strip;
        inverse = inverseAndProgram.program;
      }
      if (inverted) {
        inverted = inverse;
        inverse = program;
        program = inverted;
      }
      return {
        type: decorator ? "DecoratorBlock" : "BlockStatement",
        path: openBlock.path,
        params: openBlock.params,
        hash: openBlock.hash,
        program,
        inverse,
        openStrip: openBlock.strip,
        inverseStrip,
        closeStrip: close && close.strip,
        loc: this.locInfo(locInfo)
      };
    }
    function prepareProgram(statements, loc) {
      if (!loc && statements.length) {
        var firstLoc = statements[0].loc, lastLoc = statements[statements.length - 1].loc;
        if (firstLoc && lastLoc) {
          loc = {
            source: firstLoc.source,
            start: {
              line: firstLoc.start.line,
              column: firstLoc.start.column
            },
            end: {
              line: lastLoc.end.line,
              column: lastLoc.end.column
            }
          };
        }
      }
      return {
        type: "Program",
        body: statements,
        strip: {},
        loc
      };
    }
    function preparePartialBlock(open, program, close, locInfo) {
      validateClose(open, close);
      return {
        type: "PartialBlockStatement",
        name: open.path,
        params: open.params,
        hash: open.hash,
        program,
        openStrip: open.strip,
        closeStrip: close && close.strip,
        loc: this.locInfo(locInfo)
      };
    }
  }
});

// node_modules/handlebars/dist/cjs/handlebars/compiler/base.js
var require_base2 = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars/compiler/base.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.parseWithoutProcessing = parseWithoutProcessing;
    exports.parse = parse;
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      } else {
        var newObj = {};
        if (obj != null) {
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key))
              newObj[key] = obj[key];
          }
        }
        newObj["default"] = obj;
        return newObj;
      }
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var _parser = require_parser();
    var _parser2 = _interopRequireDefault(_parser);
    var _whitespaceControl = require_whitespace_control();
    var _whitespaceControl2 = _interopRequireDefault(_whitespaceControl);
    var _helpers = require_helpers2();
    var Helpers = _interopRequireWildcard(_helpers);
    var _utils = require_utils();
    exports.parser = _parser2["default"];
    var yy = {};
    _utils.extend(yy, Helpers);
    function parseWithoutProcessing(input, options) {
      if (input.type === "Program") {
        return input;
      }
      _parser2["default"].yy = yy;
      yy.locInfo = function(locInfo) {
        return new yy.SourceLocation(options && options.srcName, locInfo);
      };
      var ast = _parser2["default"].parse(input);
      return ast;
    }
    function parse(input, options) {
      var ast = parseWithoutProcessing(input, options);
      var strip = new _whitespaceControl2["default"](options);
      return strip.accept(ast);
    }
  }
});

// node_modules/handlebars/dist/cjs/handlebars/compiler/compiler.js
var require_compiler = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars/compiler/compiler.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.Compiler = Compiler;
    exports.precompile = precompile;
    exports.compile = compile;
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var _exception = require_exception();
    var _exception2 = _interopRequireDefault(_exception);
    var _utils = require_utils();
    var _ast = require_ast();
    var _ast2 = _interopRequireDefault(_ast);
    var slice = [].slice;
    function Compiler() {
    }
    Compiler.prototype = {
      compiler: Compiler,
      equals: function equals(other) {
        var len = this.opcodes.length;
        if (other.opcodes.length !== len) {
          return false;
        }
        for (var i = 0; i < len; i++) {
          var opcode = this.opcodes[i], otherOpcode = other.opcodes[i];
          if (opcode.opcode !== otherOpcode.opcode || !argEquals(opcode.args, otherOpcode.args)) {
            return false;
          }
        }
        len = this.children.length;
        for (var i = 0; i < len; i++) {
          if (!this.children[i].equals(other.children[i])) {
            return false;
          }
        }
        return true;
      },
      guid: 0,
      compile: function compile2(program, options) {
        this.sourceNode = [];
        this.opcodes = [];
        this.children = [];
        this.options = options;
        this.stringParams = options.stringParams;
        this.trackIds = options.trackIds;
        options.blockParams = options.blockParams || [];
        options.knownHelpers = _utils.extend(Object.create(null), {
          helperMissing: true,
          blockHelperMissing: true,
          each: true,
          "if": true,
          unless: true,
          "with": true,
          log: true,
          lookup: true
        }, options.knownHelpers);
        return this.accept(program);
      },
      compileProgram: function compileProgram(program) {
        var childCompiler = new this.compiler(), result = childCompiler.compile(program, this.options), guid = this.guid++;
        this.usePartial = this.usePartial || result.usePartial;
        this.children[guid] = result;
        this.useDepths = this.useDepths || result.useDepths;
        return guid;
      },
      accept: function accept(node) {
        if (!this[node.type]) {
          throw new _exception2["default"]("Unknown type: " + node.type, node);
        }
        this.sourceNode.unshift(node);
        var ret = this[node.type](node);
        this.sourceNode.shift();
        return ret;
      },
      Program: function Program(program) {
        this.options.blockParams.unshift(program.blockParams);
        var body = program.body, bodyLength = body.length;
        for (var i = 0; i < bodyLength; i++) {
          this.accept(body[i]);
        }
        this.options.blockParams.shift();
        this.isSimple = bodyLength === 1;
        this.blockParams = program.blockParams ? program.blockParams.length : 0;
        return this;
      },
      BlockStatement: function BlockStatement(block) {
        transformLiteralToPath(block);
        var program = block.program, inverse = block.inverse;
        program = program && this.compileProgram(program);
        inverse = inverse && this.compileProgram(inverse);
        var type = this.classifySexpr(block);
        if (type === "helper") {
          this.helperSexpr(block, program, inverse);
        } else if (type === "simple") {
          this.simpleSexpr(block);
          this.opcode("pushProgram", program);
          this.opcode("pushProgram", inverse);
          this.opcode("emptyHash");
          this.opcode("blockValue", block.path.original);
        } else {
          this.ambiguousSexpr(block, program, inverse);
          this.opcode("pushProgram", program);
          this.opcode("pushProgram", inverse);
          this.opcode("emptyHash");
          this.opcode("ambiguousBlockValue");
        }
        this.opcode("append");
      },
      DecoratorBlock: function DecoratorBlock(decorator) {
        var program = decorator.program && this.compileProgram(decorator.program);
        var params = this.setupFullMustacheParams(decorator, program, void 0), path = decorator.path;
        this.useDecorators = true;
        this.opcode("registerDecorator", params.length, path.original);
      },
      PartialStatement: function PartialStatement(partial) {
        this.usePartial = true;
        var program = partial.program;
        if (program) {
          program = this.compileProgram(partial.program);
        }
        var params = partial.params;
        if (params.length > 1) {
          throw new _exception2["default"]("Unsupported number of partial arguments: " + params.length, partial);
        } else if (!params.length) {
          if (this.options.explicitPartialContext) {
            this.opcode("pushLiteral", "undefined");
          } else {
            params.push({ type: "PathExpression", parts: [], depth: 0 });
          }
        }
        var partialName = partial.name.original, isDynamic = partial.name.type === "SubExpression";
        if (isDynamic) {
          this.accept(partial.name);
        }
        this.setupFullMustacheParams(partial, program, void 0, true);
        var indent = partial.indent || "";
        if (this.options.preventIndent && indent) {
          this.opcode("appendContent", indent);
          indent = "";
        }
        this.opcode("invokePartial", isDynamic, partialName, indent);
        this.opcode("append");
      },
      PartialBlockStatement: function PartialBlockStatement(partialBlock) {
        this.PartialStatement(partialBlock);
      },
      MustacheStatement: function MustacheStatement(mustache) {
        this.SubExpression(mustache);
        if (mustache.escaped && !this.options.noEscape) {
          this.opcode("appendEscaped");
        } else {
          this.opcode("append");
        }
      },
      Decorator: function Decorator(decorator) {
        this.DecoratorBlock(decorator);
      },
      ContentStatement: function ContentStatement(content) {
        if (content.value) {
          this.opcode("appendContent", content.value);
        }
      },
      CommentStatement: function CommentStatement() {
      },
      SubExpression: function SubExpression(sexpr) {
        transformLiteralToPath(sexpr);
        var type = this.classifySexpr(sexpr);
        if (type === "simple") {
          this.simpleSexpr(sexpr);
        } else if (type === "helper") {
          this.helperSexpr(sexpr);
        } else {
          this.ambiguousSexpr(sexpr);
        }
      },
      ambiguousSexpr: function ambiguousSexpr(sexpr, program, inverse) {
        var path = sexpr.path, name = path.parts[0], isBlock = program != null || inverse != null;
        this.opcode("getContext", path.depth);
        this.opcode("pushProgram", program);
        this.opcode("pushProgram", inverse);
        path.strict = true;
        this.accept(path);
        this.opcode("invokeAmbiguous", name, isBlock);
      },
      simpleSexpr: function simpleSexpr(sexpr) {
        var path = sexpr.path;
        path.strict = true;
        this.accept(path);
        this.opcode("resolvePossibleLambda");
      },
      helperSexpr: function helperSexpr(sexpr, program, inverse) {
        var params = this.setupFullMustacheParams(sexpr, program, inverse), path = sexpr.path, name = path.parts[0];
        if (this.options.knownHelpers[name]) {
          this.opcode("invokeKnownHelper", params.length, name);
        } else if (this.options.knownHelpersOnly) {
          throw new _exception2["default"]("You specified knownHelpersOnly, but used the unknown helper " + name, sexpr);
        } else {
          path.strict = true;
          path.falsy = true;
          this.accept(path);
          this.opcode("invokeHelper", params.length, path.original, _ast2["default"].helpers.simpleId(path));
        }
      },
      PathExpression: function PathExpression(path) {
        this.addDepth(path.depth);
        this.opcode("getContext", path.depth);
        var name = path.parts[0], scoped = _ast2["default"].helpers.scopedId(path), blockParamId = !path.depth && !scoped && this.blockParamIndex(name);
        if (blockParamId) {
          this.opcode("lookupBlockParam", blockParamId, path.parts);
        } else if (!name) {
          this.opcode("pushContext");
        } else if (path.data) {
          this.options.data = true;
          this.opcode("lookupData", path.depth, path.parts, path.strict);
        } else {
          this.opcode("lookupOnContext", path.parts, path.falsy, path.strict, scoped);
        }
      },
      StringLiteral: function StringLiteral(string) {
        this.opcode("pushString", string.value);
      },
      NumberLiteral: function NumberLiteral(number) {
        this.opcode("pushLiteral", number.value);
      },
      BooleanLiteral: function BooleanLiteral(bool) {
        this.opcode("pushLiteral", bool.value);
      },
      UndefinedLiteral: function UndefinedLiteral() {
        this.opcode("pushLiteral", "undefined");
      },
      NullLiteral: function NullLiteral() {
        this.opcode("pushLiteral", "null");
      },
      Hash: function Hash(hash) {
        var pairs = hash.pairs, i = 0, l = pairs.length;
        this.opcode("pushHash");
        for (; i < l; i++) {
          this.pushParam(pairs[i].value);
        }
        while (i--) {
          this.opcode("assignToHash", pairs[i].key);
        }
        this.opcode("popHash");
      },
      opcode: function opcode(name) {
        this.opcodes.push({
          opcode: name,
          args: slice.call(arguments, 1),
          loc: this.sourceNode[0].loc
        });
      },
      addDepth: function addDepth(depth) {
        if (!depth) {
          return;
        }
        this.useDepths = true;
      },
      classifySexpr: function classifySexpr(sexpr) {
        var isSimple = _ast2["default"].helpers.simpleId(sexpr.path);
        var isBlockParam = isSimple && !!this.blockParamIndex(sexpr.path.parts[0]);
        var isHelper = !isBlockParam && _ast2["default"].helpers.helperExpression(sexpr);
        var isEligible = !isBlockParam && (isHelper || isSimple);
        if (isEligible && !isHelper) {
          var _name = sexpr.path.parts[0], options = this.options;
          if (options.knownHelpers[_name]) {
            isHelper = true;
          } else if (options.knownHelpersOnly) {
            isEligible = false;
          }
        }
        if (isHelper) {
          return "helper";
        } else if (isEligible) {
          return "ambiguous";
        } else {
          return "simple";
        }
      },
      pushParams: function pushParams(params) {
        for (var i = 0, l = params.length; i < l; i++) {
          this.pushParam(params[i]);
        }
      },
      pushParam: function pushParam(val) {
        var value2 = val.value != null ? val.value : val.original || "";
        if (this.stringParams) {
          if (value2.replace) {
            value2 = value2.replace(/^(\.?\.\/)*/g, "").replace(/\//g, ".");
          }
          if (val.depth) {
            this.addDepth(val.depth);
          }
          this.opcode("getContext", val.depth || 0);
          this.opcode("pushStringParam", value2, val.type);
          if (val.type === "SubExpression") {
            this.accept(val);
          }
        } else {
          if (this.trackIds) {
            var blockParamIndex = void 0;
            if (val.parts && !_ast2["default"].helpers.scopedId(val) && !val.depth) {
              blockParamIndex = this.blockParamIndex(val.parts[0]);
            }
            if (blockParamIndex) {
              var blockParamChild = val.parts.slice(1).join(".");
              this.opcode("pushId", "BlockParam", blockParamIndex, blockParamChild);
            } else {
              value2 = val.original || value2;
              if (value2.replace) {
                value2 = value2.replace(/^this(?:\.|$)/, "").replace(/^\.\//, "").replace(/^\.$/, "");
              }
              this.opcode("pushId", val.type, value2);
            }
          }
          this.accept(val);
        }
      },
      setupFullMustacheParams: function setupFullMustacheParams(sexpr, program, inverse, omitEmpty) {
        var params = sexpr.params;
        this.pushParams(params);
        this.opcode("pushProgram", program);
        this.opcode("pushProgram", inverse);
        if (sexpr.hash) {
          this.accept(sexpr.hash);
        } else {
          this.opcode("emptyHash", omitEmpty);
        }
        return params;
      },
      blockParamIndex: function blockParamIndex(name) {
        for (var depth = 0, len = this.options.blockParams.length; depth < len; depth++) {
          var blockParams = this.options.blockParams[depth], param = blockParams && _utils.indexOf(blockParams, name);
          if (blockParams && param >= 0) {
            return [depth, param];
          }
        }
      }
    };
    function precompile(input, options, env) {
      if (input == null || typeof input !== "string" && input.type !== "Program") {
        throw new _exception2["default"]("You must pass a string or Handlebars AST to Handlebars.precompile. You passed " + input);
      }
      options = options || {};
      if (!("data" in options)) {
        options.data = true;
      }
      if (options.compat) {
        options.useDepths = true;
      }
      var ast = env.parse(input, options), environment = new env.Compiler().compile(ast, options);
      return new env.JavaScriptCompiler().compile(environment, options);
    }
    function compile(input, options, env) {
      if (options === void 0)
        options = {};
      if (input == null || typeof input !== "string" && input.type !== "Program") {
        throw new _exception2["default"]("You must pass a string or Handlebars AST to Handlebars.compile. You passed " + input);
      }
      options = _utils.extend({}, options);
      if (!("data" in options)) {
        options.data = true;
      }
      if (options.compat) {
        options.useDepths = true;
      }
      var compiled = void 0;
      function compileInput() {
        var ast = env.parse(input, options), environment = new env.Compiler().compile(ast, options), templateSpec = new env.JavaScriptCompiler().compile(environment, options, void 0, true);
        return env.template(templateSpec);
      }
      function ret(context, execOptions) {
        if (!compiled) {
          compiled = compileInput();
        }
        return compiled.call(this, context, execOptions);
      }
      ret._setup = function(setupOptions) {
        if (!compiled) {
          compiled = compileInput();
        }
        return compiled._setup(setupOptions);
      };
      ret._child = function(i, data, blockParams, depths) {
        if (!compiled) {
          compiled = compileInput();
        }
        return compiled._child(i, data, blockParams, depths);
      };
      return ret;
    }
    function argEquals(a, b) {
      if (a === b) {
        return true;
      }
      if (_utils.isArray(a) && _utils.isArray(b) && a.length === b.length) {
        for (var i = 0; i < a.length; i++) {
          if (!argEquals(a[i], b[i])) {
            return false;
          }
        }
        return true;
      }
    }
    function transformLiteralToPath(sexpr) {
      if (!sexpr.path.parts) {
        var literal = sexpr.path;
        sexpr.path = {
          type: "PathExpression",
          data: false,
          depth: 0,
          parts: [literal.original + ""],
          original: literal.original + "",
          loc: literal.loc
        };
      }
    }
  }
});

// node_modules/source-map/lib/base64.js
var require_base64 = __commonJS({
  "node_modules/source-map/lib/base64.js"(exports) {
    var intToCharMap = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
    exports.encode = function(number) {
      if (0 <= number && number < intToCharMap.length) {
        return intToCharMap[number];
      }
      throw new TypeError("Must be between 0 and 63: " + number);
    };
    exports.decode = function(charCode) {
      var bigA = 65;
      var bigZ = 90;
      var littleA = 97;
      var littleZ = 122;
      var zero = 48;
      var nine = 57;
      var plus = 43;
      var slash = 47;
      var littleOffset = 26;
      var numberOffset = 52;
      if (bigA <= charCode && charCode <= bigZ) {
        return charCode - bigA;
      }
      if (littleA <= charCode && charCode <= littleZ) {
        return charCode - littleA + littleOffset;
      }
      if (zero <= charCode && charCode <= nine) {
        return charCode - zero + numberOffset;
      }
      if (charCode == plus) {
        return 62;
      }
      if (charCode == slash) {
        return 63;
      }
      return -1;
    };
  }
});

// node_modules/source-map/lib/base64-vlq.js
var require_base64_vlq = __commonJS({
  "node_modules/source-map/lib/base64-vlq.js"(exports) {
    var base64 = require_base64();
    var VLQ_BASE_SHIFT = 5;
    var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
    var VLQ_BASE_MASK = VLQ_BASE - 1;
    var VLQ_CONTINUATION_BIT = VLQ_BASE;
    function toVLQSigned(aValue) {
      return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
    }
    function fromVLQSigned(aValue) {
      var isNegative = (aValue & 1) === 1;
      var shifted = aValue >> 1;
      return isNegative ? -shifted : shifted;
    }
    exports.encode = function base64VLQ_encode(aValue) {
      var encoded = "";
      var digit;
      var vlq = toVLQSigned(aValue);
      do {
        digit = vlq & VLQ_BASE_MASK;
        vlq >>>= VLQ_BASE_SHIFT;
        if (vlq > 0) {
          digit |= VLQ_CONTINUATION_BIT;
        }
        encoded += base64.encode(digit);
      } while (vlq > 0);
      return encoded;
    };
    exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
      var strLen = aStr.length;
      var result = 0;
      var shift = 0;
      var continuation, digit;
      do {
        if (aIndex >= strLen) {
          throw new Error("Expected more digits in base 64 VLQ value.");
        }
        digit = base64.decode(aStr.charCodeAt(aIndex++));
        if (digit === -1) {
          throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
        }
        continuation = !!(digit & VLQ_CONTINUATION_BIT);
        digit &= VLQ_BASE_MASK;
        result = result + (digit << shift);
        shift += VLQ_BASE_SHIFT;
      } while (continuation);
      aOutParam.value = fromVLQSigned(result);
      aOutParam.rest = aIndex;
    };
  }
});

// node_modules/source-map/lib/util.js
var require_util = __commonJS({
  "node_modules/source-map/lib/util.js"(exports) {
    function getArg(aArgs, aName, aDefaultValue) {
      if (aName in aArgs) {
        return aArgs[aName];
      } else if (arguments.length === 3) {
        return aDefaultValue;
      } else {
        throw new Error('"' + aName + '" is a required argument.');
      }
    }
    exports.getArg = getArg;
    var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
    var dataUrlRegexp = /^data:.+\,.+$/;
    function urlParse(aUrl) {
      var match = aUrl.match(urlRegexp);
      if (!match) {
        return null;
      }
      return {
        scheme: match[1],
        auth: match[2],
        host: match[3],
        port: match[4],
        path: match[5]
      };
    }
    exports.urlParse = urlParse;
    function urlGenerate(aParsedUrl) {
      var url = "";
      if (aParsedUrl.scheme) {
        url += aParsedUrl.scheme + ":";
      }
      url += "//";
      if (aParsedUrl.auth) {
        url += aParsedUrl.auth + "@";
      }
      if (aParsedUrl.host) {
        url += aParsedUrl.host;
      }
      if (aParsedUrl.port) {
        url += ":" + aParsedUrl.port;
      }
      if (aParsedUrl.path) {
        url += aParsedUrl.path;
      }
      return url;
    }
    exports.urlGenerate = urlGenerate;
    function normalize(aPath) {
      var path = aPath;
      var url = urlParse(aPath);
      if (url) {
        if (!url.path) {
          return aPath;
        }
        path = url.path;
      }
      var isAbsolute = exports.isAbsolute(path);
      var parts = path.split(/\/+/);
      for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
        part = parts[i];
        if (part === ".") {
          parts.splice(i, 1);
        } else if (part === "..") {
          up++;
        } else if (up > 0) {
          if (part === "") {
            parts.splice(i + 1, up);
            up = 0;
          } else {
            parts.splice(i, 2);
            up--;
          }
        }
      }
      path = parts.join("/");
      if (path === "") {
        path = isAbsolute ? "/" : ".";
      }
      if (url) {
        url.path = path;
        return urlGenerate(url);
      }
      return path;
    }
    exports.normalize = normalize;
    function join(aRoot, aPath) {
      if (aRoot === "") {
        aRoot = ".";
      }
      if (aPath === "") {
        aPath = ".";
      }
      var aPathUrl = urlParse(aPath);
      var aRootUrl = urlParse(aRoot);
      if (aRootUrl) {
        aRoot = aRootUrl.path || "/";
      }
      if (aPathUrl && !aPathUrl.scheme) {
        if (aRootUrl) {
          aPathUrl.scheme = aRootUrl.scheme;
        }
        return urlGenerate(aPathUrl);
      }
      if (aPathUrl || aPath.match(dataUrlRegexp)) {
        return aPath;
      }
      if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
        aRootUrl.host = aPath;
        return urlGenerate(aRootUrl);
      }
      var joined = aPath.charAt(0) === "/" ? aPath : normalize(aRoot.replace(/\/+$/, "") + "/" + aPath);
      if (aRootUrl) {
        aRootUrl.path = joined;
        return urlGenerate(aRootUrl);
      }
      return joined;
    }
    exports.join = join;
    exports.isAbsolute = function(aPath) {
      return aPath.charAt(0) === "/" || urlRegexp.test(aPath);
    };
    function relative(aRoot, aPath) {
      if (aRoot === "") {
        aRoot = ".";
      }
      aRoot = aRoot.replace(/\/$/, "");
      var level = 0;
      while (aPath.indexOf(aRoot + "/") !== 0) {
        var index = aRoot.lastIndexOf("/");
        if (index < 0) {
          return aPath;
        }
        aRoot = aRoot.slice(0, index);
        if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
          return aPath;
        }
        ++level;
      }
      return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
    }
    exports.relative = relative;
    var supportsNullProto = function() {
      var obj = Object.create(null);
      return !("__proto__" in obj);
    }();
    function identity(s) {
      return s;
    }
    function toSetString(aStr) {
      if (isProtoString(aStr)) {
        return "$" + aStr;
      }
      return aStr;
    }
    exports.toSetString = supportsNullProto ? identity : toSetString;
    function fromSetString(aStr) {
      if (isProtoString(aStr)) {
        return aStr.slice(1);
      }
      return aStr;
    }
    exports.fromSetString = supportsNullProto ? identity : fromSetString;
    function isProtoString(s) {
      if (!s) {
        return false;
      }
      var length = s.length;
      if (length < 9) {
        return false;
      }
      if (s.charCodeAt(length - 1) !== 95 || s.charCodeAt(length - 2) !== 95 || s.charCodeAt(length - 3) !== 111 || s.charCodeAt(length - 4) !== 116 || s.charCodeAt(length - 5) !== 111 || s.charCodeAt(length - 6) !== 114 || s.charCodeAt(length - 7) !== 112 || s.charCodeAt(length - 8) !== 95 || s.charCodeAt(length - 9) !== 95) {
        return false;
      }
      for (var i = length - 10; i >= 0; i--) {
        if (s.charCodeAt(i) !== 36) {
          return false;
        }
      }
      return true;
    }
    function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
      var cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0 || onlyCompareOriginal) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports.compareByOriginalPositions = compareByOriginalPositions;
    function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
      var cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0 || onlyCompareGenerated) {
        return cmp;
      }
      cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
    function strcmp(aStr1, aStr2) {
      if (aStr1 === aStr2) {
        return 0;
      }
      if (aStr1 === null) {
        return 1;
      }
      if (aStr2 === null) {
        return -1;
      }
      if (aStr1 > aStr2) {
        return 1;
      }
      return -1;
    }
    function compareByGeneratedPositionsInflated(mappingA, mappingB) {
      var cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
    function parseSourceMapInput(str) {
      return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ""));
    }
    exports.parseSourceMapInput = parseSourceMapInput;
    function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
      sourceURL = sourceURL || "";
      if (sourceRoot) {
        if (sourceRoot[sourceRoot.length - 1] !== "/" && sourceURL[0] !== "/") {
          sourceRoot += "/";
        }
        sourceURL = sourceRoot + sourceURL;
      }
      if (sourceMapURL) {
        var parsed = urlParse(sourceMapURL);
        if (!parsed) {
          throw new Error("sourceMapURL could not be parsed");
        }
        if (parsed.path) {
          var index = parsed.path.lastIndexOf("/");
          if (index >= 0) {
            parsed.path = parsed.path.substring(0, index + 1);
          }
        }
        sourceURL = join(urlGenerate(parsed), sourceURL);
      }
      return normalize(sourceURL);
    }
    exports.computeSourceURL = computeSourceURL;
  }
});

// node_modules/source-map/lib/array-set.js
var require_array_set = __commonJS({
  "node_modules/source-map/lib/array-set.js"(exports) {
    var util = require_util();
    var has = Object.prototype.hasOwnProperty;
    var hasNativeMap = typeof Map !== "undefined";
    function ArraySet() {
      this._array = [];
      this._set = hasNativeMap ? new Map() : Object.create(null);
    }
    ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
      var set = new ArraySet();
      for (var i = 0, len = aArray.length; i < len; i++) {
        set.add(aArray[i], aAllowDuplicates);
      }
      return set;
    };
    ArraySet.prototype.size = function ArraySet_size() {
      return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
    };
    ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
      var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
      var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
      var idx = this._array.length;
      if (!isDuplicate || aAllowDuplicates) {
        this._array.push(aStr);
      }
      if (!isDuplicate) {
        if (hasNativeMap) {
          this._set.set(aStr, idx);
        } else {
          this._set[sStr] = idx;
        }
      }
    };
    ArraySet.prototype.has = function ArraySet_has(aStr) {
      if (hasNativeMap) {
        return this._set.has(aStr);
      } else {
        var sStr = util.toSetString(aStr);
        return has.call(this._set, sStr);
      }
    };
    ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
      if (hasNativeMap) {
        var idx = this._set.get(aStr);
        if (idx >= 0) {
          return idx;
        }
      } else {
        var sStr = util.toSetString(aStr);
        if (has.call(this._set, sStr)) {
          return this._set[sStr];
        }
      }
      throw new Error('"' + aStr + '" is not in the set.');
    };
    ArraySet.prototype.at = function ArraySet_at(aIdx) {
      if (aIdx >= 0 && aIdx < this._array.length) {
        return this._array[aIdx];
      }
      throw new Error("No element indexed by " + aIdx);
    };
    ArraySet.prototype.toArray = function ArraySet_toArray() {
      return this._array.slice();
    };
    exports.ArraySet = ArraySet;
  }
});

// node_modules/source-map/lib/mapping-list.js
var require_mapping_list = __commonJS({
  "node_modules/source-map/lib/mapping-list.js"(exports) {
    var util = require_util();
    function generatedPositionAfter(mappingA, mappingB) {
      var lineA = mappingA.generatedLine;
      var lineB = mappingB.generatedLine;
      var columnA = mappingA.generatedColumn;
      var columnB = mappingB.generatedColumn;
      return lineB > lineA || lineB == lineA && columnB >= columnA || util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
    }
    function MappingList() {
      this._array = [];
      this._sorted = true;
      this._last = { generatedLine: -1, generatedColumn: 0 };
    }
    MappingList.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {
      this._array.forEach(aCallback, aThisArg);
    };
    MappingList.prototype.add = function MappingList_add(aMapping) {
      if (generatedPositionAfter(this._last, aMapping)) {
        this._last = aMapping;
        this._array.push(aMapping);
      } else {
        this._sorted = false;
        this._array.push(aMapping);
      }
    };
    MappingList.prototype.toArray = function MappingList_toArray() {
      if (!this._sorted) {
        this._array.sort(util.compareByGeneratedPositionsInflated);
        this._sorted = true;
      }
      return this._array;
    };
    exports.MappingList = MappingList;
  }
});

// node_modules/source-map/lib/source-map-generator.js
var require_source_map_generator = __commonJS({
  "node_modules/source-map/lib/source-map-generator.js"(exports) {
    var base64VLQ = require_base64_vlq();
    var util = require_util();
    var ArraySet = require_array_set().ArraySet;
    var MappingList = require_mapping_list().MappingList;
    function SourceMapGenerator(aArgs) {
      if (!aArgs) {
        aArgs = {};
      }
      this._file = util.getArg(aArgs, "file", null);
      this._sourceRoot = util.getArg(aArgs, "sourceRoot", null);
      this._skipValidation = util.getArg(aArgs, "skipValidation", false);
      this._sources = new ArraySet();
      this._names = new ArraySet();
      this._mappings = new MappingList();
      this._sourcesContents = null;
    }
    SourceMapGenerator.prototype._version = 3;
    SourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
      var sourceRoot = aSourceMapConsumer.sourceRoot;
      var generator = new SourceMapGenerator({
        file: aSourceMapConsumer.file,
        sourceRoot
      });
      aSourceMapConsumer.eachMapping(function(mapping) {
        var newMapping = {
          generated: {
            line: mapping.generatedLine,
            column: mapping.generatedColumn
          }
        };
        if (mapping.source != null) {
          newMapping.source = mapping.source;
          if (sourceRoot != null) {
            newMapping.source = util.relative(sourceRoot, newMapping.source);
          }
          newMapping.original = {
            line: mapping.originalLine,
            column: mapping.originalColumn
          };
          if (mapping.name != null) {
            newMapping.name = mapping.name;
          }
        }
        generator.addMapping(newMapping);
      });
      aSourceMapConsumer.sources.forEach(function(sourceFile) {
        var sourceRelative = sourceFile;
        if (sourceRoot !== null) {
          sourceRelative = util.relative(sourceRoot, sourceFile);
        }
        if (!generator._sources.has(sourceRelative)) {
          generator._sources.add(sourceRelative);
        }
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
          generator.setSourceContent(sourceFile, content);
        }
      });
      return generator;
    };
    SourceMapGenerator.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {
      var generated = util.getArg(aArgs, "generated");
      var original = util.getArg(aArgs, "original", null);
      var source = util.getArg(aArgs, "source", null);
      var name = util.getArg(aArgs, "name", null);
      if (!this._skipValidation) {
        this._validateMapping(generated, original, source, name);
      }
      if (source != null) {
        source = String(source);
        if (!this._sources.has(source)) {
          this._sources.add(source);
        }
      }
      if (name != null) {
        name = String(name);
        if (!this._names.has(name)) {
          this._names.add(name);
        }
      }
      this._mappings.add({
        generatedLine: generated.line,
        generatedColumn: generated.column,
        originalLine: original != null && original.line,
        originalColumn: original != null && original.column,
        source,
        name
      });
    };
    SourceMapGenerator.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
      var source = aSourceFile;
      if (this._sourceRoot != null) {
        source = util.relative(this._sourceRoot, source);
      }
      if (aSourceContent != null) {
        if (!this._sourcesContents) {
          this._sourcesContents = Object.create(null);
        }
        this._sourcesContents[util.toSetString(source)] = aSourceContent;
      } else if (this._sourcesContents) {
        delete this._sourcesContents[util.toSetString(source)];
        if (Object.keys(this._sourcesContents).length === 0) {
          this._sourcesContents = null;
        }
      }
    };
    SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
      var sourceFile = aSourceFile;
      if (aSourceFile == null) {
        if (aSourceMapConsumer.file == null) {
          throw new Error(`SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's "file" property. Both were omitted.`);
        }
        sourceFile = aSourceMapConsumer.file;
      }
      var sourceRoot = this._sourceRoot;
      if (sourceRoot != null) {
        sourceFile = util.relative(sourceRoot, sourceFile);
      }
      var newSources = new ArraySet();
      var newNames = new ArraySet();
      this._mappings.unsortedForEach(function(mapping) {
        if (mapping.source === sourceFile && mapping.originalLine != null) {
          var original = aSourceMapConsumer.originalPositionFor({
            line: mapping.originalLine,
            column: mapping.originalColumn
          });
          if (original.source != null) {
            mapping.source = original.source;
            if (aSourceMapPath != null) {
              mapping.source = util.join(aSourceMapPath, mapping.source);
            }
            if (sourceRoot != null) {
              mapping.source = util.relative(sourceRoot, mapping.source);
            }
            mapping.originalLine = original.line;
            mapping.originalColumn = original.column;
            if (original.name != null) {
              mapping.name = original.name;
            }
          }
        }
        var source = mapping.source;
        if (source != null && !newSources.has(source)) {
          newSources.add(source);
        }
        var name = mapping.name;
        if (name != null && !newNames.has(name)) {
          newNames.add(name);
        }
      }, this);
      this._sources = newSources;
      this._names = newNames;
      aSourceMapConsumer.sources.forEach(function(sourceFile2) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile2);
        if (content != null) {
          if (aSourceMapPath != null) {
            sourceFile2 = util.join(aSourceMapPath, sourceFile2);
          }
          if (sourceRoot != null) {
            sourceFile2 = util.relative(sourceRoot, sourceFile2);
          }
          this.setSourceContent(sourceFile2, content);
        }
      }, this);
    };
    SourceMapGenerator.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {
      if (aOriginal && typeof aOriginal.line !== "number" && typeof aOriginal.column !== "number") {
        throw new Error("original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values.");
      }
      if (aGenerated && "line" in aGenerated && "column" in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {
        return;
      } else if (aGenerated && "line" in aGenerated && "column" in aGenerated && aOriginal && "line" in aOriginal && "column" in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {
        return;
      } else {
        throw new Error("Invalid mapping: " + JSON.stringify({
          generated: aGenerated,
          source: aSource,
          original: aOriginal,
          name: aName
        }));
      }
    };
    SourceMapGenerator.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
      var previousGeneratedColumn = 0;
      var previousGeneratedLine = 1;
      var previousOriginalColumn = 0;
      var previousOriginalLine = 0;
      var previousName = 0;
      var previousSource = 0;
      var result = "";
      var next;
      var mapping;
      var nameIdx;
      var sourceIdx;
      var mappings = this._mappings.toArray();
      for (var i = 0, len = mappings.length; i < len; i++) {
        mapping = mappings[i];
        next = "";
        if (mapping.generatedLine !== previousGeneratedLine) {
          previousGeneratedColumn = 0;
          while (mapping.generatedLine !== previousGeneratedLine) {
            next += ";";
            previousGeneratedLine++;
          }
        } else {
          if (i > 0) {
            if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
              continue;
            }
            next += ",";
          }
        }
        next += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);
        previousGeneratedColumn = mapping.generatedColumn;
        if (mapping.source != null) {
          sourceIdx = this._sources.indexOf(mapping.source);
          next += base64VLQ.encode(sourceIdx - previousSource);
          previousSource = sourceIdx;
          next += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine);
          previousOriginalLine = mapping.originalLine - 1;
          next += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);
          previousOriginalColumn = mapping.originalColumn;
          if (mapping.name != null) {
            nameIdx = this._names.indexOf(mapping.name);
            next += base64VLQ.encode(nameIdx - previousName);
            previousName = nameIdx;
          }
        }
        result += next;
      }
      return result;
    };
    SourceMapGenerator.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
      return aSources.map(function(source) {
        if (!this._sourcesContents) {
          return null;
        }
        if (aSourceRoot != null) {
          source = util.relative(aSourceRoot, source);
        }
        var key = util.toSetString(source);
        return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
      }, this);
    };
    SourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {
      var map = {
        version: this._version,
        sources: this._sources.toArray(),
        names: this._names.toArray(),
        mappings: this._serializeMappings()
      };
      if (this._file != null) {
        map.file = this._file;
      }
      if (this._sourceRoot != null) {
        map.sourceRoot = this._sourceRoot;
      }
      if (this._sourcesContents) {
        map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
      }
      return map;
    };
    SourceMapGenerator.prototype.toString = function SourceMapGenerator_toString() {
      return JSON.stringify(this.toJSON());
    };
    exports.SourceMapGenerator = SourceMapGenerator;
  }
});

// node_modules/source-map/lib/binary-search.js
var require_binary_search = __commonJS({
  "node_modules/source-map/lib/binary-search.js"(exports) {
    exports.GREATEST_LOWER_BOUND = 1;
    exports.LEAST_UPPER_BOUND = 2;
    function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
      var mid = Math.floor((aHigh - aLow) / 2) + aLow;
      var cmp = aCompare(aNeedle, aHaystack[mid], true);
      if (cmp === 0) {
        return mid;
      } else if (cmp > 0) {
        if (aHigh - mid > 1) {
          return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
        }
        if (aBias == exports.LEAST_UPPER_BOUND) {
          return aHigh < aHaystack.length ? aHigh : -1;
        } else {
          return mid;
        }
      } else {
        if (mid - aLow > 1) {
          return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
        }
        if (aBias == exports.LEAST_UPPER_BOUND) {
          return mid;
        } else {
          return aLow < 0 ? -1 : aLow;
        }
      }
    }
    exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
      if (aHaystack.length === 0) {
        return -1;
      }
      var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare, aBias || exports.GREATEST_LOWER_BOUND);
      if (index < 0) {
        return -1;
      }
      while (index - 1 >= 0) {
        if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
          break;
        }
        --index;
      }
      return index;
    };
  }
});

// node_modules/source-map/lib/quick-sort.js
var require_quick_sort = __commonJS({
  "node_modules/source-map/lib/quick-sort.js"(exports) {
    function swap(ary, x, y) {
      var temp = ary[x];
      ary[x] = ary[y];
      ary[y] = temp;
    }
    function randomIntInRange(low, high) {
      return Math.round(low + Math.random() * (high - low));
    }
    function doQuickSort(ary, comparator, p, r) {
      if (p < r) {
        var pivotIndex = randomIntInRange(p, r);
        var i = p - 1;
        swap(ary, pivotIndex, r);
        var pivot = ary[r];
        for (var j = p; j < r; j++) {
          if (comparator(ary[j], pivot) <= 0) {
            i += 1;
            swap(ary, i, j);
          }
        }
        swap(ary, i + 1, j);
        var q = i + 1;
        doQuickSort(ary, comparator, p, q - 1);
        doQuickSort(ary, comparator, q + 1, r);
      }
    }
    exports.quickSort = function(ary, comparator) {
      doQuickSort(ary, comparator, 0, ary.length - 1);
    };
  }
});

// node_modules/source-map/lib/source-map-consumer.js
var require_source_map_consumer = __commonJS({
  "node_modules/source-map/lib/source-map-consumer.js"(exports) {
    var util = require_util();
    var binarySearch = require_binary_search();
    var ArraySet = require_array_set().ArraySet;
    var base64VLQ = require_base64_vlq();
    var quickSort = require_quick_sort().quickSort;
    function SourceMapConsumer(aSourceMap, aSourceMapURL) {
      var sourceMap = aSourceMap;
      if (typeof aSourceMap === "string") {
        sourceMap = util.parseSourceMapInput(aSourceMap);
      }
      return sourceMap.sections != null ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL) : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
    }
    SourceMapConsumer.fromSourceMap = function(aSourceMap, aSourceMapURL) {
      return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
    };
    SourceMapConsumer.prototype._version = 3;
    SourceMapConsumer.prototype.__generatedMappings = null;
    Object.defineProperty(SourceMapConsumer.prototype, "_generatedMappings", {
      configurable: true,
      enumerable: true,
      get: function() {
        if (!this.__generatedMappings) {
          this._parseMappings(this._mappings, this.sourceRoot);
        }
        return this.__generatedMappings;
      }
    });
    SourceMapConsumer.prototype.__originalMappings = null;
    Object.defineProperty(SourceMapConsumer.prototype, "_originalMappings", {
      configurable: true,
      enumerable: true,
      get: function() {
        if (!this.__originalMappings) {
          this._parseMappings(this._mappings, this.sourceRoot);
        }
        return this.__originalMappings;
      }
    });
    SourceMapConsumer.prototype._charIsMappingSeparator = function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
      var c = aStr.charAt(index);
      return c === ";" || c === ",";
    };
    SourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      throw new Error("Subclasses must implement _parseMappings");
    };
    SourceMapConsumer.GENERATED_ORDER = 1;
    SourceMapConsumer.ORIGINAL_ORDER = 2;
    SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
    SourceMapConsumer.LEAST_UPPER_BOUND = 2;
    SourceMapConsumer.prototype.eachMapping = function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
      var context = aContext || null;
      var order = aOrder || SourceMapConsumer.GENERATED_ORDER;
      var mappings;
      switch (order) {
        case SourceMapConsumer.GENERATED_ORDER:
          mappings = this._generatedMappings;
          break;
        case SourceMapConsumer.ORIGINAL_ORDER:
          mappings = this._originalMappings;
          break;
        default:
          throw new Error("Unknown order of iteration.");
      }
      var sourceRoot = this.sourceRoot;
      mappings.map(function(mapping) {
        var source = mapping.source === null ? null : this._sources.at(mapping.source);
        source = util.computeSourceURL(sourceRoot, source, this._sourceMapURL);
        return {
          source,
          generatedLine: mapping.generatedLine,
          generatedColumn: mapping.generatedColumn,
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name: mapping.name === null ? null : this._names.at(mapping.name)
        };
      }, this).forEach(aCallback, context);
    };
    SourceMapConsumer.prototype.allGeneratedPositionsFor = function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
      var line = util.getArg(aArgs, "line");
      var needle = {
        source: util.getArg(aArgs, "source"),
        originalLine: line,
        originalColumn: util.getArg(aArgs, "column", 0)
      };
      needle.source = this._findSourceIndex(needle.source);
      if (needle.source < 0) {
        return [];
      }
      var mappings = [];
      var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util.compareByOriginalPositions, binarySearch.LEAST_UPPER_BOUND);
      if (index >= 0) {
        var mapping = this._originalMappings[index];
        if (aArgs.column === void 0) {
          var originalLine = mapping.originalLine;
          while (mapping && mapping.originalLine === originalLine) {
            mappings.push({
              line: util.getArg(mapping, "generatedLine", null),
              column: util.getArg(mapping, "generatedColumn", null),
              lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
            });
            mapping = this._originalMappings[++index];
          }
        } else {
          var originalColumn = mapping.originalColumn;
          while (mapping && mapping.originalLine === line && mapping.originalColumn == originalColumn) {
            mappings.push({
              line: util.getArg(mapping, "generatedLine", null),
              column: util.getArg(mapping, "generatedColumn", null),
              lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
            });
            mapping = this._originalMappings[++index];
          }
        }
      }
      return mappings;
    };
    exports.SourceMapConsumer = SourceMapConsumer;
    function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
      var sourceMap = aSourceMap;
      if (typeof aSourceMap === "string") {
        sourceMap = util.parseSourceMapInput(aSourceMap);
      }
      var version = util.getArg(sourceMap, "version");
      var sources = util.getArg(sourceMap, "sources");
      var names = util.getArg(sourceMap, "names", []);
      var sourceRoot = util.getArg(sourceMap, "sourceRoot", null);
      var sourcesContent = util.getArg(sourceMap, "sourcesContent", null);
      var mappings = util.getArg(sourceMap, "mappings");
      var file = util.getArg(sourceMap, "file", null);
      if (version != this._version) {
        throw new Error("Unsupported version: " + version);
      }
      if (sourceRoot) {
        sourceRoot = util.normalize(sourceRoot);
      }
      sources = sources.map(String).map(util.normalize).map(function(source) {
        return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source) ? util.relative(sourceRoot, source) : source;
      });
      this._names = ArraySet.fromArray(names.map(String), true);
      this._sources = ArraySet.fromArray(sources, true);
      this._absoluteSources = this._sources.toArray().map(function(s) {
        return util.computeSourceURL(sourceRoot, s, aSourceMapURL);
      });
      this.sourceRoot = sourceRoot;
      this.sourcesContent = sourcesContent;
      this._mappings = mappings;
      this._sourceMapURL = aSourceMapURL;
      this.file = file;
    }
    BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
    BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;
    BasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {
      var relativeSource = aSource;
      if (this.sourceRoot != null) {
        relativeSource = util.relative(this.sourceRoot, relativeSource);
      }
      if (this._sources.has(relativeSource)) {
        return this._sources.indexOf(relativeSource);
      }
      var i;
      for (i = 0; i < this._absoluteSources.length; ++i) {
        if (this._absoluteSources[i] == aSource) {
          return i;
        }
      }
      return -1;
    };
    BasicSourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {
      var smc = Object.create(BasicSourceMapConsumer.prototype);
      var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
      var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
      smc.sourceRoot = aSourceMap._sourceRoot;
      smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(), smc.sourceRoot);
      smc.file = aSourceMap._file;
      smc._sourceMapURL = aSourceMapURL;
      smc._absoluteSources = smc._sources.toArray().map(function(s) {
        return util.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);
      });
      var generatedMappings = aSourceMap._mappings.toArray().slice();
      var destGeneratedMappings = smc.__generatedMappings = [];
      var destOriginalMappings = smc.__originalMappings = [];
      for (var i = 0, length = generatedMappings.length; i < length; i++) {
        var srcMapping = generatedMappings[i];
        var destMapping = new Mapping();
        destMapping.generatedLine = srcMapping.generatedLine;
        destMapping.generatedColumn = srcMapping.generatedColumn;
        if (srcMapping.source) {
          destMapping.source = sources.indexOf(srcMapping.source);
          destMapping.originalLine = srcMapping.originalLine;
          destMapping.originalColumn = srcMapping.originalColumn;
          if (srcMapping.name) {
            destMapping.name = names.indexOf(srcMapping.name);
          }
          destOriginalMappings.push(destMapping);
        }
        destGeneratedMappings.push(destMapping);
      }
      quickSort(smc.__originalMappings, util.compareByOriginalPositions);
      return smc;
    };
    BasicSourceMapConsumer.prototype._version = 3;
    Object.defineProperty(BasicSourceMapConsumer.prototype, "sources", {
      get: function() {
        return this._absoluteSources.slice();
      }
    });
    function Mapping() {
      this.generatedLine = 0;
      this.generatedColumn = 0;
      this.source = null;
      this.originalLine = null;
      this.originalColumn = null;
      this.name = null;
    }
    BasicSourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      var generatedLine = 1;
      var previousGeneratedColumn = 0;
      var previousOriginalLine = 0;
      var previousOriginalColumn = 0;
      var previousSource = 0;
      var previousName = 0;
      var length = aStr.length;
      var index = 0;
      var cachedSegments = {};
      var temp = {};
      var originalMappings = [];
      var generatedMappings = [];
      var mapping, str, segment, end, value2;
      while (index < length) {
        if (aStr.charAt(index) === ";") {
          generatedLine++;
          index++;
          previousGeneratedColumn = 0;
        } else if (aStr.charAt(index) === ",") {
          index++;
        } else {
          mapping = new Mapping();
          mapping.generatedLine = generatedLine;
          for (end = index; end < length; end++) {
            if (this._charIsMappingSeparator(aStr, end)) {
              break;
            }
          }
          str = aStr.slice(index, end);
          segment = cachedSegments[str];
          if (segment) {
            index += str.length;
          } else {
            segment = [];
            while (index < end) {
              base64VLQ.decode(aStr, index, temp);
              value2 = temp.value;
              index = temp.rest;
              segment.push(value2);
            }
            if (segment.length === 2) {
              throw new Error("Found a source, but no line and column");
            }
            if (segment.length === 3) {
              throw new Error("Found a source and line, but no column");
            }
            cachedSegments[str] = segment;
          }
          mapping.generatedColumn = previousGeneratedColumn + segment[0];
          previousGeneratedColumn = mapping.generatedColumn;
          if (segment.length > 1) {
            mapping.source = previousSource + segment[1];
            previousSource += segment[1];
            mapping.originalLine = previousOriginalLine + segment[2];
            previousOriginalLine = mapping.originalLine;
            mapping.originalLine += 1;
            mapping.originalColumn = previousOriginalColumn + segment[3];
            previousOriginalColumn = mapping.originalColumn;
            if (segment.length > 4) {
              mapping.name = previousName + segment[4];
              previousName += segment[4];
            }
          }
          generatedMappings.push(mapping);
          if (typeof mapping.originalLine === "number") {
            originalMappings.push(mapping);
          }
        }
      }
      quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);
      this.__generatedMappings = generatedMappings;
      quickSort(originalMappings, util.compareByOriginalPositions);
      this.__originalMappings = originalMappings;
    };
    BasicSourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {
      if (aNeedle[aLineName] <= 0) {
        throw new TypeError("Line must be greater than or equal to 1, got " + aNeedle[aLineName]);
      }
      if (aNeedle[aColumnName] < 0) {
        throw new TypeError("Column must be greater than or equal to 0, got " + aNeedle[aColumnName]);
      }
      return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
    };
    BasicSourceMapConsumer.prototype.computeColumnSpans = function SourceMapConsumer_computeColumnSpans() {
      for (var index = 0; index < this._generatedMappings.length; ++index) {
        var mapping = this._generatedMappings[index];
        if (index + 1 < this._generatedMappings.length) {
          var nextMapping = this._generatedMappings[index + 1];
          if (mapping.generatedLine === nextMapping.generatedLine) {
            mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
            continue;
          }
        }
        mapping.lastGeneratedColumn = Infinity;
      }
    };
    BasicSourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(aArgs) {
      var needle = {
        generatedLine: util.getArg(aArgs, "line"),
        generatedColumn: util.getArg(aArgs, "column")
      };
      var index = this._findMapping(needle, this._generatedMappings, "generatedLine", "generatedColumn", util.compareByGeneratedPositionsDeflated, util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND));
      if (index >= 0) {
        var mapping = this._generatedMappings[index];
        if (mapping.generatedLine === needle.generatedLine) {
          var source = util.getArg(mapping, "source", null);
          if (source !== null) {
            source = this._sources.at(source);
            source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);
          }
          var name = util.getArg(mapping, "name", null);
          if (name !== null) {
            name = this._names.at(name);
          }
          return {
            source,
            line: util.getArg(mapping, "originalLine", null),
            column: util.getArg(mapping, "originalColumn", null),
            name
          };
        }
      }
      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    };
    BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function BasicSourceMapConsumer_hasContentsOfAllSources() {
      if (!this.sourcesContent) {
        return false;
      }
      return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function(sc) {
        return sc == null;
      });
    };
    BasicSourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
      if (!this.sourcesContent) {
        return null;
      }
      var index = this._findSourceIndex(aSource);
      if (index >= 0) {
        return this.sourcesContent[index];
      }
      var relativeSource = aSource;
      if (this.sourceRoot != null) {
        relativeSource = util.relative(this.sourceRoot, relativeSource);
      }
      var url;
      if (this.sourceRoot != null && (url = util.urlParse(this.sourceRoot))) {
        var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
        if (url.scheme == "file" && this._sources.has(fileUriAbsPath)) {
          return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
        }
        if ((!url.path || url.path == "/") && this._sources.has("/" + relativeSource)) {
          return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
        }
      }
      if (nullOnMissing) {
        return null;
      } else {
        throw new Error('"' + relativeSource + '" is not in the SourceMap.');
      }
    };
    BasicSourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(aArgs) {
      var source = util.getArg(aArgs, "source");
      source = this._findSourceIndex(source);
      if (source < 0) {
        return {
          line: null,
          column: null,
          lastColumn: null
        };
      }
      var needle = {
        source,
        originalLine: util.getArg(aArgs, "line"),
        originalColumn: util.getArg(aArgs, "column")
      };
      var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util.compareByOriginalPositions, util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND));
      if (index >= 0) {
        var mapping = this._originalMappings[index];
        if (mapping.source === needle.source) {
          return {
            line: util.getArg(mapping, "generatedLine", null),
            column: util.getArg(mapping, "generatedColumn", null),
            lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
          };
        }
      }
      return {
        line: null,
        column: null,
        lastColumn: null
      };
    };
    exports.BasicSourceMapConsumer = BasicSourceMapConsumer;
    function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
      var sourceMap = aSourceMap;
      if (typeof aSourceMap === "string") {
        sourceMap = util.parseSourceMapInput(aSourceMap);
      }
      var version = util.getArg(sourceMap, "version");
      var sections = util.getArg(sourceMap, "sections");
      if (version != this._version) {
        throw new Error("Unsupported version: " + version);
      }
      this._sources = new ArraySet();
      this._names = new ArraySet();
      var lastOffset = {
        line: -1,
        column: 0
      };
      this._sections = sections.map(function(s) {
        if (s.url) {
          throw new Error("Support for url field in sections not implemented.");
        }
        var offset = util.getArg(s, "offset");
        var offsetLine = util.getArg(offset, "line");
        var offsetColumn = util.getArg(offset, "column");
        if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) {
          throw new Error("Section offsets must be ordered and non-overlapping.");
        }
        lastOffset = offset;
        return {
          generatedOffset: {
            generatedLine: offsetLine + 1,
            generatedColumn: offsetColumn + 1
          },
          consumer: new SourceMapConsumer(util.getArg(s, "map"), aSourceMapURL)
        };
      });
    }
    IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
    IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;
    IndexedSourceMapConsumer.prototype._version = 3;
    Object.defineProperty(IndexedSourceMapConsumer.prototype, "sources", {
      get: function() {
        var sources = [];
        for (var i = 0; i < this._sections.length; i++) {
          for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
            sources.push(this._sections[i].consumer.sources[j]);
          }
        }
        return sources;
      }
    });
    IndexedSourceMapConsumer.prototype.originalPositionFor = function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
      var needle = {
        generatedLine: util.getArg(aArgs, "line"),
        generatedColumn: util.getArg(aArgs, "column")
      };
      var sectionIndex = binarySearch.search(needle, this._sections, function(needle2, section2) {
        var cmp = needle2.generatedLine - section2.generatedOffset.generatedLine;
        if (cmp) {
          return cmp;
        }
        return needle2.generatedColumn - section2.generatedOffset.generatedColumn;
      });
      var section = this._sections[sectionIndex];
      if (!section) {
        return {
          source: null,
          line: null,
          column: null,
          name: null
        };
      }
      return section.consumer.originalPositionFor({
        line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),
        column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
        bias: aArgs.bias
      });
    };
    IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function IndexedSourceMapConsumer_hasContentsOfAllSources() {
      return this._sections.every(function(s) {
        return s.consumer.hasContentsOfAllSources();
      });
    };
    IndexedSourceMapConsumer.prototype.sourceContentFor = function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
      for (var i = 0; i < this._sections.length; i++) {
        var section = this._sections[i];
        var content = section.consumer.sourceContentFor(aSource, true);
        if (content) {
          return content;
        }
      }
      if (nullOnMissing) {
        return null;
      } else {
        throw new Error('"' + aSource + '" is not in the SourceMap.');
      }
    };
    IndexedSourceMapConsumer.prototype.generatedPositionFor = function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
      for (var i = 0; i < this._sections.length; i++) {
        var section = this._sections[i];
        if (section.consumer._findSourceIndex(util.getArg(aArgs, "source")) === -1) {
          continue;
        }
        var generatedPosition = section.consumer.generatedPositionFor(aArgs);
        if (generatedPosition) {
          var ret = {
            line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),
            column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)
          };
          return ret;
        }
      }
      return {
        line: null,
        column: null
      };
    };
    IndexedSourceMapConsumer.prototype._parseMappings = function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      this.__generatedMappings = [];
      this.__originalMappings = [];
      for (var i = 0; i < this._sections.length; i++) {
        var section = this._sections[i];
        var sectionMappings = section.consumer._generatedMappings;
        for (var j = 0; j < sectionMappings.length; j++) {
          var mapping = sectionMappings[j];
          var source = section.consumer._sources.at(mapping.source);
          source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);
          this._sources.add(source);
          source = this._sources.indexOf(source);
          var name = null;
          if (mapping.name) {
            name = section.consumer._names.at(mapping.name);
            this._names.add(name);
            name = this._names.indexOf(name);
          }
          var adjustedMapping = {
            source,
            generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1),
            generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
            originalLine: mapping.originalLine,
            originalColumn: mapping.originalColumn,
            name
          };
          this.__generatedMappings.push(adjustedMapping);
          if (typeof adjustedMapping.originalLine === "number") {
            this.__originalMappings.push(adjustedMapping);
          }
        }
      }
      quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
      quickSort(this.__originalMappings, util.compareByOriginalPositions);
    };
    exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
  }
});

// node_modules/source-map/lib/source-node.js
var require_source_node = __commonJS({
  "node_modules/source-map/lib/source-node.js"(exports) {
    var SourceMapGenerator = require_source_map_generator().SourceMapGenerator;
    var util = require_util();
    var REGEX_NEWLINE = /(\r?\n)/;
    var NEWLINE_CODE = 10;
    var isSourceNode = "$$$isSourceNode$$$";
    function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
      this.children = [];
      this.sourceContents = {};
      this.line = aLine == null ? null : aLine;
      this.column = aColumn == null ? null : aColumn;
      this.source = aSource == null ? null : aSource;
      this.name = aName == null ? null : aName;
      this[isSourceNode] = true;
      if (aChunks != null)
        this.add(aChunks);
    }
    SourceNode.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
      var node = new SourceNode();
      var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
      var remainingLinesIndex = 0;
      var shiftNextLine = function() {
        var lineContents = getNextLine();
        var newLine = getNextLine() || "";
        return lineContents + newLine;
        function getNextLine() {
          return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : void 0;
        }
      };
      var lastGeneratedLine = 1, lastGeneratedColumn = 0;
      var lastMapping = null;
      aSourceMapConsumer.eachMapping(function(mapping) {
        if (lastMapping !== null) {
          if (lastGeneratedLine < mapping.generatedLine) {
            addMappingWithCode(lastMapping, shiftNextLine());
            lastGeneratedLine++;
            lastGeneratedColumn = 0;
          } else {
            var nextLine = remainingLines[remainingLinesIndex] || "";
            var code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);
            remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);
            lastGeneratedColumn = mapping.generatedColumn;
            addMappingWithCode(lastMapping, code);
            lastMapping = mapping;
            return;
          }
        }
        while (lastGeneratedLine < mapping.generatedLine) {
          node.add(shiftNextLine());
          lastGeneratedLine++;
        }
        if (lastGeneratedColumn < mapping.generatedColumn) {
          var nextLine = remainingLines[remainingLinesIndex] || "";
          node.add(nextLine.substr(0, mapping.generatedColumn));
          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
          lastGeneratedColumn = mapping.generatedColumn;
        }
        lastMapping = mapping;
      }, this);
      if (remainingLinesIndex < remainingLines.length) {
        if (lastMapping) {
          addMappingWithCode(lastMapping, shiftNextLine());
        }
        node.add(remainingLines.splice(remainingLinesIndex).join(""));
      }
      aSourceMapConsumer.sources.forEach(function(sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
          if (aRelativePath != null) {
            sourceFile = util.join(aRelativePath, sourceFile);
          }
          node.setSourceContent(sourceFile, content);
        }
      });
      return node;
      function addMappingWithCode(mapping, code) {
        if (mapping === null || mapping.source === void 0) {
          node.add(code);
        } else {
          var source = aRelativePath ? util.join(aRelativePath, mapping.source) : mapping.source;
          node.add(new SourceNode(mapping.originalLine, mapping.originalColumn, source, code, mapping.name));
        }
      }
    };
    SourceNode.prototype.add = function SourceNode_add(aChunk) {
      if (Array.isArray(aChunk)) {
        aChunk.forEach(function(chunk) {
          this.add(chunk);
        }, this);
      } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
        if (aChunk) {
          this.children.push(aChunk);
        }
      } else {
        throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
      }
      return this;
    };
    SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
      if (Array.isArray(aChunk)) {
        for (var i = aChunk.length - 1; i >= 0; i--) {
          this.prepend(aChunk[i]);
        }
      } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
        this.children.unshift(aChunk);
      } else {
        throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
      }
      return this;
    };
    SourceNode.prototype.walk = function SourceNode_walk(aFn) {
      var chunk;
      for (var i = 0, len = this.children.length; i < len; i++) {
        chunk = this.children[i];
        if (chunk[isSourceNode]) {
          chunk.walk(aFn);
        } else {
          if (chunk !== "") {
            aFn(chunk, {
              source: this.source,
              line: this.line,
              column: this.column,
              name: this.name
            });
          }
        }
      }
    };
    SourceNode.prototype.join = function SourceNode_join(aSep) {
      var newChildren;
      var i;
      var len = this.children.length;
      if (len > 0) {
        newChildren = [];
        for (i = 0; i < len - 1; i++) {
          newChildren.push(this.children[i]);
          newChildren.push(aSep);
        }
        newChildren.push(this.children[i]);
        this.children = newChildren;
      }
      return this;
    };
    SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
      var lastChild = this.children[this.children.length - 1];
      if (lastChild[isSourceNode]) {
        lastChild.replaceRight(aPattern, aReplacement);
      } else if (typeof lastChild === "string") {
        this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
      } else {
        this.children.push("".replace(aPattern, aReplacement));
      }
      return this;
    };
    SourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
      this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
    };
    SourceNode.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {
      for (var i = 0, len = this.children.length; i < len; i++) {
        if (this.children[i][isSourceNode]) {
          this.children[i].walkSourceContents(aFn);
        }
      }
      var sources = Object.keys(this.sourceContents);
      for (var i = 0, len = sources.length; i < len; i++) {
        aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
      }
    };
    SourceNode.prototype.toString = function SourceNode_toString() {
      var str = "";
      this.walk(function(chunk) {
        str += chunk;
      });
      return str;
    };
    SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
      var generated = {
        code: "",
        line: 1,
        column: 0
      };
      var map = new SourceMapGenerator(aArgs);
      var sourceMappingActive = false;
      var lastOriginalSource = null;
      var lastOriginalLine = null;
      var lastOriginalColumn = null;
      var lastOriginalName = null;
      this.walk(function(chunk, original) {
        generated.code += chunk;
        if (original.source !== null && original.line !== null && original.column !== null) {
          if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {
            map.addMapping({
              source: original.source,
              original: {
                line: original.line,
                column: original.column
              },
              generated: {
                line: generated.line,
                column: generated.column
              },
              name: original.name
            });
          }
          lastOriginalSource = original.source;
          lastOriginalLine = original.line;
          lastOriginalColumn = original.column;
          lastOriginalName = original.name;
          sourceMappingActive = true;
        } else if (sourceMappingActive) {
          map.addMapping({
            generated: {
              line: generated.line,
              column: generated.column
            }
          });
          lastOriginalSource = null;
          sourceMappingActive = false;
        }
        for (var idx = 0, length = chunk.length; idx < length; idx++) {
          if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
            generated.line++;
            generated.column = 0;
            if (idx + 1 === length) {
              lastOriginalSource = null;
              sourceMappingActive = false;
            } else if (sourceMappingActive) {
              map.addMapping({
                source: original.source,
                original: {
                  line: original.line,
                  column: original.column
                },
                generated: {
                  line: generated.line,
                  column: generated.column
                },
                name: original.name
              });
            }
          } else {
            generated.column++;
          }
        }
      });
      this.walkSourceContents(function(sourceFile, sourceContent) {
        map.setSourceContent(sourceFile, sourceContent);
      });
      return { code: generated.code, map };
    };
    exports.SourceNode = SourceNode;
  }
});

// node_modules/source-map/source-map.js
var require_source_map = __commonJS({
  "node_modules/source-map/source-map.js"(exports) {
    exports.SourceMapGenerator = require_source_map_generator().SourceMapGenerator;
    exports.SourceMapConsumer = require_source_map_consumer().SourceMapConsumer;
    exports.SourceNode = require_source_node().SourceNode;
  }
});

// node_modules/handlebars/dist/cjs/handlebars/compiler/code-gen.js
var require_code_gen = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars/compiler/code-gen.js"(exports, module2) {
    "use strict";
    exports.__esModule = true;
    var _utils = require_utils();
    var SourceNode = void 0;
    try {
      if (typeof define !== "function" || !define.amd) {
        SourceMap = require_source_map();
        SourceNode = SourceMap.SourceNode;
      }
    } catch (err) {
    }
    var SourceMap;
    if (!SourceNode) {
      SourceNode = function(line, column, srcFile, chunks) {
        this.src = "";
        if (chunks) {
          this.add(chunks);
        }
      };
      SourceNode.prototype = {
        add: function add(chunks) {
          if (_utils.isArray(chunks)) {
            chunks = chunks.join("");
          }
          this.src += chunks;
        },
        prepend: function prepend(chunks) {
          if (_utils.isArray(chunks)) {
            chunks = chunks.join("");
          }
          this.src = chunks + this.src;
        },
        toStringWithSourceMap: function toStringWithSourceMap() {
          return { code: this.toString() };
        },
        toString: function toString() {
          return this.src;
        }
      };
    }
    function castChunk(chunk, codeGen, loc) {
      if (_utils.isArray(chunk)) {
        var ret = [];
        for (var i = 0, len = chunk.length; i < len; i++) {
          ret.push(codeGen.wrap(chunk[i], loc));
        }
        return ret;
      } else if (typeof chunk === "boolean" || typeof chunk === "number") {
        return chunk + "";
      }
      return chunk;
    }
    function CodeGen(srcFile) {
      this.srcFile = srcFile;
      this.source = [];
    }
    CodeGen.prototype = {
      isEmpty: function isEmpty() {
        return !this.source.length;
      },
      prepend: function prepend(source, loc) {
        this.source.unshift(this.wrap(source, loc));
      },
      push: function push(source, loc) {
        this.source.push(this.wrap(source, loc));
      },
      merge: function merge() {
        var source = this.empty();
        this.each(function(line) {
          source.add(["  ", line, "\n"]);
        });
        return source;
      },
      each: function each(iter) {
        for (var i = 0, len = this.source.length; i < len; i++) {
          iter(this.source[i]);
        }
      },
      empty: function empty() {
        var loc = this.currentLocation || { start: {} };
        return new SourceNode(loc.start.line, loc.start.column, this.srcFile);
      },
      wrap: function wrap(chunk) {
        var loc = arguments.length <= 1 || arguments[1] === void 0 ? this.currentLocation || { start: {} } : arguments[1];
        if (chunk instanceof SourceNode) {
          return chunk;
        }
        chunk = castChunk(chunk, this, loc);
        return new SourceNode(loc.start.line, loc.start.column, this.srcFile, chunk);
      },
      functionCall: function functionCall(fn, type, params) {
        params = this.generateList(params);
        return this.wrap([fn, type ? "." + type + "(" : "(", params, ")"]);
      },
      quotedString: function quotedString(str) {
        return '"' + (str + "").replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029") + '"';
      },
      objectLiteral: function objectLiteral(obj) {
        var _this = this;
        var pairs = [];
        Object.keys(obj).forEach(function(key) {
          var value2 = castChunk(obj[key], _this);
          if (value2 !== "undefined") {
            pairs.push([_this.quotedString(key), ":", value2]);
          }
        });
        var ret = this.generateList(pairs);
        ret.prepend("{");
        ret.add("}");
        return ret;
      },
      generateList: function generateList(entries) {
        var ret = this.empty();
        for (var i = 0, len = entries.length; i < len; i++) {
          if (i) {
            ret.add(",");
          }
          ret.add(castChunk(entries[i], this));
        }
        return ret;
      },
      generateArray: function generateArray(entries) {
        var ret = this.generateList(entries);
        ret.prepend("[");
        ret.add("]");
        return ret;
      }
    };
    exports["default"] = CodeGen;
    module2.exports = exports["default"];
  }
});

// node_modules/handlebars/dist/cjs/handlebars/compiler/javascript-compiler.js
var require_javascript_compiler = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars/compiler/javascript-compiler.js"(exports, module2) {
    "use strict";
    exports.__esModule = true;
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var _base = require_base();
    var _exception = require_exception();
    var _exception2 = _interopRequireDefault(_exception);
    var _utils = require_utils();
    var _codeGen = require_code_gen();
    var _codeGen2 = _interopRequireDefault(_codeGen);
    function Literal(value2) {
      this.value = value2;
    }
    function JavaScriptCompiler() {
    }
    JavaScriptCompiler.prototype = {
      nameLookup: function nameLookup(parent, name) {
        return this.internalNameLookup(parent, name);
      },
      depthedLookup: function depthedLookup(name) {
        return [this.aliasable("container.lookup"), "(depths, ", JSON.stringify(name), ")"];
      },
      compilerInfo: function compilerInfo() {
        var revision = _base.COMPILER_REVISION, versions = _base.REVISION_CHANGES[revision];
        return [revision, versions];
      },
      appendToBuffer: function appendToBuffer(source, location, explicit) {
        if (!_utils.isArray(source)) {
          source = [source];
        }
        source = this.source.wrap(source, location);
        if (this.environment.isSimple) {
          return ["return ", source, ";"];
        } else if (explicit) {
          return ["buffer += ", source, ";"];
        } else {
          source.appendToBuffer = true;
          return source;
        }
      },
      initializeBuffer: function initializeBuffer() {
        return this.quotedString("");
      },
      internalNameLookup: function internalNameLookup(parent, name) {
        this.lookupPropertyFunctionIsUsed = true;
        return ["lookupProperty(", parent, ",", JSON.stringify(name), ")"];
      },
      lookupPropertyFunctionIsUsed: false,
      compile: function compile(environment, options, context, asObject) {
        this.environment = environment;
        this.options = options;
        this.stringParams = this.options.stringParams;
        this.trackIds = this.options.trackIds;
        this.precompile = !asObject;
        this.name = this.environment.name;
        this.isChild = !!context;
        this.context = context || {
          decorators: [],
          programs: [],
          environments: []
        };
        this.preamble();
        this.stackSlot = 0;
        this.stackVars = [];
        this.aliases = {};
        this.registers = { list: [] };
        this.hashes = [];
        this.compileStack = [];
        this.inlineStack = [];
        this.blockParams = [];
        this.compileChildren(environment, options);
        this.useDepths = this.useDepths || environment.useDepths || environment.useDecorators || this.options.compat;
        this.useBlockParams = this.useBlockParams || environment.useBlockParams;
        var opcodes = environment.opcodes, opcode = void 0, firstLoc = void 0, i = void 0, l = void 0;
        for (i = 0, l = opcodes.length; i < l; i++) {
          opcode = opcodes[i];
          this.source.currentLocation = opcode.loc;
          firstLoc = firstLoc || opcode.loc;
          this[opcode.opcode].apply(this, opcode.args);
        }
        this.source.currentLocation = firstLoc;
        this.pushSource("");
        if (this.stackSlot || this.inlineStack.length || this.compileStack.length) {
          throw new _exception2["default"]("Compile completed with content left on stack");
        }
        if (!this.decorators.isEmpty()) {
          this.useDecorators = true;
          this.decorators.prepend(["var decorators = container.decorators, ", this.lookupPropertyFunctionVarDeclaration(), ";\n"]);
          this.decorators.push("return fn;");
          if (asObject) {
            this.decorators = Function.apply(this, ["fn", "props", "container", "depth0", "data", "blockParams", "depths", this.decorators.merge()]);
          } else {
            this.decorators.prepend("function(fn, props, container, depth0, data, blockParams, depths) {\n");
            this.decorators.push("}\n");
            this.decorators = this.decorators.merge();
          }
        } else {
          this.decorators = void 0;
        }
        var fn = this.createFunctionContext(asObject);
        if (!this.isChild) {
          var ret = {
            compiler: this.compilerInfo(),
            main: fn
          };
          if (this.decorators) {
            ret.main_d = this.decorators;
            ret.useDecorators = true;
          }
          var _context = this.context;
          var programs = _context.programs;
          var decorators = _context.decorators;
          for (i = 0, l = programs.length; i < l; i++) {
            if (programs[i]) {
              ret[i] = programs[i];
              if (decorators[i]) {
                ret[i + "_d"] = decorators[i];
                ret.useDecorators = true;
              }
            }
          }
          if (this.environment.usePartial) {
            ret.usePartial = true;
          }
          if (this.options.data) {
            ret.useData = true;
          }
          if (this.useDepths) {
            ret.useDepths = true;
          }
          if (this.useBlockParams) {
            ret.useBlockParams = true;
          }
          if (this.options.compat) {
            ret.compat = true;
          }
          if (!asObject) {
            ret.compiler = JSON.stringify(ret.compiler);
            this.source.currentLocation = { start: { line: 1, column: 0 } };
            ret = this.objectLiteral(ret);
            if (options.srcName) {
              ret = ret.toStringWithSourceMap({ file: options.destName });
              ret.map = ret.map && ret.map.toString();
            } else {
              ret = ret.toString();
            }
          } else {
            ret.compilerOptions = this.options;
          }
          return ret;
        } else {
          return fn;
        }
      },
      preamble: function preamble() {
        this.lastContext = 0;
        this.source = new _codeGen2["default"](this.options.srcName);
        this.decorators = new _codeGen2["default"](this.options.srcName);
      },
      createFunctionContext: function createFunctionContext(asObject) {
        var _this = this;
        var varDeclarations = "";
        var locals = this.stackVars.concat(this.registers.list);
        if (locals.length > 0) {
          varDeclarations += ", " + locals.join(", ");
        }
        var aliasCount = 0;
        Object.keys(this.aliases).forEach(function(alias) {
          var node = _this.aliases[alias];
          if (node.children && node.referenceCount > 1) {
            varDeclarations += ", alias" + ++aliasCount + "=" + alias;
            node.children[0] = "alias" + aliasCount;
          }
        });
        if (this.lookupPropertyFunctionIsUsed) {
          varDeclarations += ", " + this.lookupPropertyFunctionVarDeclaration();
        }
        var params = ["container", "depth0", "helpers", "partials", "data"];
        if (this.useBlockParams || this.useDepths) {
          params.push("blockParams");
        }
        if (this.useDepths) {
          params.push("depths");
        }
        var source = this.mergeSource(varDeclarations);
        if (asObject) {
          params.push(source);
          return Function.apply(this, params);
        } else {
          return this.source.wrap(["function(", params.join(","), ") {\n  ", source, "}"]);
        }
      },
      mergeSource: function mergeSource(varDeclarations) {
        var isSimple = this.environment.isSimple, appendOnly = !this.forceBuffer, appendFirst = void 0, sourceSeen = void 0, bufferStart = void 0, bufferEnd = void 0;
        this.source.each(function(line) {
          if (line.appendToBuffer) {
            if (bufferStart) {
              line.prepend("  + ");
            } else {
              bufferStart = line;
            }
            bufferEnd = line;
          } else {
            if (bufferStart) {
              if (!sourceSeen) {
                appendFirst = true;
              } else {
                bufferStart.prepend("buffer += ");
              }
              bufferEnd.add(";");
              bufferStart = bufferEnd = void 0;
            }
            sourceSeen = true;
            if (!isSimple) {
              appendOnly = false;
            }
          }
        });
        if (appendOnly) {
          if (bufferStart) {
            bufferStart.prepend("return ");
            bufferEnd.add(";");
          } else if (!sourceSeen) {
            this.source.push('return "";');
          }
        } else {
          varDeclarations += ", buffer = " + (appendFirst ? "" : this.initializeBuffer());
          if (bufferStart) {
            bufferStart.prepend("return buffer + ");
            bufferEnd.add(";");
          } else {
            this.source.push("return buffer;");
          }
        }
        if (varDeclarations) {
          this.source.prepend("var " + varDeclarations.substring(2) + (appendFirst ? "" : ";\n"));
        }
        return this.source.merge();
      },
      lookupPropertyFunctionVarDeclaration: function lookupPropertyFunctionVarDeclaration() {
        return "\n      lookupProperty = container.lookupProperty || function(parent, propertyName) {\n        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {\n          return parent[propertyName];\n        }\n        return undefined\n    }\n    ".trim();
      },
      blockValue: function blockValue(name) {
        var blockHelperMissing = this.aliasable("container.hooks.blockHelperMissing"), params = [this.contextName(0)];
        this.setupHelperArgs(name, 0, params);
        var blockName = this.popStack();
        params.splice(1, 0, blockName);
        this.push(this.source.functionCall(blockHelperMissing, "call", params));
      },
      ambiguousBlockValue: function ambiguousBlockValue() {
        var blockHelperMissing = this.aliasable("container.hooks.blockHelperMissing"), params = [this.contextName(0)];
        this.setupHelperArgs("", 0, params, true);
        this.flushInline();
        var current = this.topStack();
        params.splice(1, 0, current);
        this.pushSource(["if (!", this.lastHelper, ") { ", current, " = ", this.source.functionCall(blockHelperMissing, "call", params), "}"]);
      },
      appendContent: function appendContent(content) {
        if (this.pendingContent) {
          content = this.pendingContent + content;
        } else {
          this.pendingLocation = this.source.currentLocation;
        }
        this.pendingContent = content;
      },
      append: function append() {
        if (this.isInline()) {
          this.replaceStack(function(current) {
            return [" != null ? ", current, ' : ""'];
          });
          this.pushSource(this.appendToBuffer(this.popStack()));
        } else {
          var local = this.popStack();
          this.pushSource(["if (", local, " != null) { ", this.appendToBuffer(local, void 0, true), " }"]);
          if (this.environment.isSimple) {
            this.pushSource(["else { ", this.appendToBuffer("''", void 0, true), " }"]);
          }
        }
      },
      appendEscaped: function appendEscaped() {
        this.pushSource(this.appendToBuffer([this.aliasable("container.escapeExpression"), "(", this.popStack(), ")"]));
      },
      getContext: function getContext(depth) {
        this.lastContext = depth;
      },
      pushContext: function pushContext() {
        this.pushStackLiteral(this.contextName(this.lastContext));
      },
      lookupOnContext: function lookupOnContext(parts, falsy, strict, scoped) {
        var i = 0;
        if (!scoped && this.options.compat && !this.lastContext) {
          this.push(this.depthedLookup(parts[i++]));
        } else {
          this.pushContext();
        }
        this.resolvePath("context", parts, i, falsy, strict);
      },
      lookupBlockParam: function lookupBlockParam(blockParamId, parts) {
        this.useBlockParams = true;
        this.push(["blockParams[", blockParamId[0], "][", blockParamId[1], "]"]);
        this.resolvePath("context", parts, 1);
      },
      lookupData: function lookupData(depth, parts, strict) {
        if (!depth) {
          this.pushStackLiteral("data");
        } else {
          this.pushStackLiteral("container.data(data, " + depth + ")");
        }
        this.resolvePath("data", parts, 0, true, strict);
      },
      resolvePath: function resolvePath(type, parts, i, falsy, strict) {
        var _this2 = this;
        if (this.options.strict || this.options.assumeObjects) {
          this.push(strictLookup(this.options.strict && strict, this, parts, type));
          return;
        }
        var len = parts.length;
        for (; i < len; i++) {
          this.replaceStack(function(current) {
            var lookup = _this2.nameLookup(current, parts[i], type);
            if (!falsy) {
              return [" != null ? ", lookup, " : ", current];
            } else {
              return [" && ", lookup];
            }
          });
        }
      },
      resolvePossibleLambda: function resolvePossibleLambda() {
        this.push([this.aliasable("container.lambda"), "(", this.popStack(), ", ", this.contextName(0), ")"]);
      },
      pushStringParam: function pushStringParam(string, type) {
        this.pushContext();
        this.pushString(type);
        if (type !== "SubExpression") {
          if (typeof string === "string") {
            this.pushString(string);
          } else {
            this.pushStackLiteral(string);
          }
        }
      },
      emptyHash: function emptyHash(omitEmpty) {
        if (this.trackIds) {
          this.push("{}");
        }
        if (this.stringParams) {
          this.push("{}");
          this.push("{}");
        }
        this.pushStackLiteral(omitEmpty ? "undefined" : "{}");
      },
      pushHash: function pushHash() {
        if (this.hash) {
          this.hashes.push(this.hash);
        }
        this.hash = { values: {}, types: [], contexts: [], ids: [] };
      },
      popHash: function popHash() {
        var hash = this.hash;
        this.hash = this.hashes.pop();
        if (this.trackIds) {
          this.push(this.objectLiteral(hash.ids));
        }
        if (this.stringParams) {
          this.push(this.objectLiteral(hash.contexts));
          this.push(this.objectLiteral(hash.types));
        }
        this.push(this.objectLiteral(hash.values));
      },
      pushString: function pushString(string) {
        this.pushStackLiteral(this.quotedString(string));
      },
      pushLiteral: function pushLiteral(value2) {
        this.pushStackLiteral(value2);
      },
      pushProgram: function pushProgram(guid) {
        if (guid != null) {
          this.pushStackLiteral(this.programExpression(guid));
        } else {
          this.pushStackLiteral(null);
        }
      },
      registerDecorator: function registerDecorator(paramSize, name) {
        var foundDecorator = this.nameLookup("decorators", name, "decorator"), options = this.setupHelperArgs(name, paramSize);
        this.decorators.push(["fn = ", this.decorators.functionCall(foundDecorator, "", ["fn", "props", "container", options]), " || fn;"]);
      },
      invokeHelper: function invokeHelper(paramSize, name, isSimple) {
        var nonHelper = this.popStack(), helper = this.setupHelper(paramSize, name);
        var possibleFunctionCalls = [];
        if (isSimple) {
          possibleFunctionCalls.push(helper.name);
        }
        possibleFunctionCalls.push(nonHelper);
        if (!this.options.strict) {
          possibleFunctionCalls.push(this.aliasable("container.hooks.helperMissing"));
        }
        var functionLookupCode = ["(", this.itemsSeparatedBy(possibleFunctionCalls, "||"), ")"];
        var functionCall = this.source.functionCall(functionLookupCode, "call", helper.callParams);
        this.push(functionCall);
      },
      itemsSeparatedBy: function itemsSeparatedBy(items, separator) {
        var result = [];
        result.push(items[0]);
        for (var i = 1; i < items.length; i++) {
          result.push(separator, items[i]);
        }
        return result;
      },
      invokeKnownHelper: function invokeKnownHelper(paramSize, name) {
        var helper = this.setupHelper(paramSize, name);
        this.push(this.source.functionCall(helper.name, "call", helper.callParams));
      },
      invokeAmbiguous: function invokeAmbiguous(name, helperCall) {
        this.useRegister("helper");
        var nonHelper = this.popStack();
        this.emptyHash();
        var helper = this.setupHelper(0, name, helperCall);
        var helperName = this.lastHelper = this.nameLookup("helpers", name, "helper");
        var lookup = ["(", "(helper = ", helperName, " || ", nonHelper, ")"];
        if (!this.options.strict) {
          lookup[0] = "(helper = ";
          lookup.push(" != null ? helper : ", this.aliasable("container.hooks.helperMissing"));
        }
        this.push(["(", lookup, helper.paramsInit ? ["),(", helper.paramsInit] : [], "),", "(typeof helper === ", this.aliasable('"function"'), " ? ", this.source.functionCall("helper", "call", helper.callParams), " : helper))"]);
      },
      invokePartial: function invokePartial(isDynamic, name, indent) {
        var params = [], options = this.setupParams(name, 1, params);
        if (isDynamic) {
          name = this.popStack();
          delete options.name;
        }
        if (indent) {
          options.indent = JSON.stringify(indent);
        }
        options.helpers = "helpers";
        options.partials = "partials";
        options.decorators = "container.decorators";
        if (!isDynamic) {
          params.unshift(this.nameLookup("partials", name, "partial"));
        } else {
          params.unshift(name);
        }
        if (this.options.compat) {
          options.depths = "depths";
        }
        options = this.objectLiteral(options);
        params.push(options);
        this.push(this.source.functionCall("container.invokePartial", "", params));
      },
      assignToHash: function assignToHash(key) {
        var value2 = this.popStack(), context = void 0, type = void 0, id = void 0;
        if (this.trackIds) {
          id = this.popStack();
        }
        if (this.stringParams) {
          type = this.popStack();
          context = this.popStack();
        }
        var hash = this.hash;
        if (context) {
          hash.contexts[key] = context;
        }
        if (type) {
          hash.types[key] = type;
        }
        if (id) {
          hash.ids[key] = id;
        }
        hash.values[key] = value2;
      },
      pushId: function pushId(type, name, child) {
        if (type === "BlockParam") {
          this.pushStackLiteral("blockParams[" + name[0] + "].path[" + name[1] + "]" + (child ? " + " + JSON.stringify("." + child) : ""));
        } else if (type === "PathExpression") {
          this.pushString(name);
        } else if (type === "SubExpression") {
          this.pushStackLiteral("true");
        } else {
          this.pushStackLiteral("null");
        }
      },
      compiler: JavaScriptCompiler,
      compileChildren: function compileChildren(environment, options) {
        var children = environment.children, child = void 0, compiler = void 0;
        for (var i = 0, l = children.length; i < l; i++) {
          child = children[i];
          compiler = new this.compiler();
          var existing = this.matchExistingProgram(child);
          if (existing == null) {
            this.context.programs.push("");
            var index = this.context.programs.length;
            child.index = index;
            child.name = "program" + index;
            this.context.programs[index] = compiler.compile(child, options, this.context, !this.precompile);
            this.context.decorators[index] = compiler.decorators;
            this.context.environments[index] = child;
            this.useDepths = this.useDepths || compiler.useDepths;
            this.useBlockParams = this.useBlockParams || compiler.useBlockParams;
            child.useDepths = this.useDepths;
            child.useBlockParams = this.useBlockParams;
          } else {
            child.index = existing.index;
            child.name = "program" + existing.index;
            this.useDepths = this.useDepths || existing.useDepths;
            this.useBlockParams = this.useBlockParams || existing.useBlockParams;
          }
        }
      },
      matchExistingProgram: function matchExistingProgram(child) {
        for (var i = 0, len = this.context.environments.length; i < len; i++) {
          var environment = this.context.environments[i];
          if (environment && environment.equals(child)) {
            return environment;
          }
        }
      },
      programExpression: function programExpression(guid) {
        var child = this.environment.children[guid], programParams = [child.index, "data", child.blockParams];
        if (this.useBlockParams || this.useDepths) {
          programParams.push("blockParams");
        }
        if (this.useDepths) {
          programParams.push("depths");
        }
        return "container.program(" + programParams.join(", ") + ")";
      },
      useRegister: function useRegister(name) {
        if (!this.registers[name]) {
          this.registers[name] = true;
          this.registers.list.push(name);
        }
      },
      push: function push(expr) {
        if (!(expr instanceof Literal)) {
          expr = this.source.wrap(expr);
        }
        this.inlineStack.push(expr);
        return expr;
      },
      pushStackLiteral: function pushStackLiteral(item) {
        this.push(new Literal(item));
      },
      pushSource: function pushSource(source) {
        if (this.pendingContent) {
          this.source.push(this.appendToBuffer(this.source.quotedString(this.pendingContent), this.pendingLocation));
          this.pendingContent = void 0;
        }
        if (source) {
          this.source.push(source);
        }
      },
      replaceStack: function replaceStack(callback) {
        var prefix = ["("], stack = void 0, createdStack = void 0, usedLiteral = void 0;
        if (!this.isInline()) {
          throw new _exception2["default"]("replaceStack on non-inline");
        }
        var top = this.popStack(true);
        if (top instanceof Literal) {
          stack = [top.value];
          prefix = ["(", stack];
          usedLiteral = true;
        } else {
          createdStack = true;
          var _name = this.incrStack();
          prefix = ["((", this.push(_name), " = ", top, ")"];
          stack = this.topStack();
        }
        var item = callback.call(this, stack);
        if (!usedLiteral) {
          this.popStack();
        }
        if (createdStack) {
          this.stackSlot--;
        }
        this.push(prefix.concat(item, ")"));
      },
      incrStack: function incrStack() {
        this.stackSlot++;
        if (this.stackSlot > this.stackVars.length) {
          this.stackVars.push("stack" + this.stackSlot);
        }
        return this.topStackName();
      },
      topStackName: function topStackName() {
        return "stack" + this.stackSlot;
      },
      flushInline: function flushInline() {
        var inlineStack = this.inlineStack;
        this.inlineStack = [];
        for (var i = 0, len = inlineStack.length; i < len; i++) {
          var entry = inlineStack[i];
          if (entry instanceof Literal) {
            this.compileStack.push(entry);
          } else {
            var stack = this.incrStack();
            this.pushSource([stack, " = ", entry, ";"]);
            this.compileStack.push(stack);
          }
        }
      },
      isInline: function isInline() {
        return this.inlineStack.length;
      },
      popStack: function popStack(wrapped) {
        var inline = this.isInline(), item = (inline ? this.inlineStack : this.compileStack).pop();
        if (!wrapped && item instanceof Literal) {
          return item.value;
        } else {
          if (!inline) {
            if (!this.stackSlot) {
              throw new _exception2["default"]("Invalid stack pop");
            }
            this.stackSlot--;
          }
          return item;
        }
      },
      topStack: function topStack() {
        var stack = this.isInline() ? this.inlineStack : this.compileStack, item = stack[stack.length - 1];
        if (item instanceof Literal) {
          return item.value;
        } else {
          return item;
        }
      },
      contextName: function contextName(context) {
        if (this.useDepths && context) {
          return "depths[" + context + "]";
        } else {
          return "depth" + context;
        }
      },
      quotedString: function quotedString(str) {
        return this.source.quotedString(str);
      },
      objectLiteral: function objectLiteral(obj) {
        return this.source.objectLiteral(obj);
      },
      aliasable: function aliasable(name) {
        var ret = this.aliases[name];
        if (ret) {
          ret.referenceCount++;
          return ret;
        }
        ret = this.aliases[name] = this.source.wrap(name);
        ret.aliasable = true;
        ret.referenceCount = 1;
        return ret;
      },
      setupHelper: function setupHelper(paramSize, name, blockHelper) {
        var params = [], paramsInit = this.setupHelperArgs(name, paramSize, params, blockHelper);
        var foundHelper = this.nameLookup("helpers", name, "helper"), callContext = this.aliasable(this.contextName(0) + " != null ? " + this.contextName(0) + " : (container.nullContext || {})");
        return {
          params,
          paramsInit,
          name: foundHelper,
          callParams: [callContext].concat(params)
        };
      },
      setupParams: function setupParams(helper, paramSize, params) {
        var options = {}, contexts = [], types = [], ids = [], objectArgs = !params, param = void 0;
        if (objectArgs) {
          params = [];
        }
        options.name = this.quotedString(helper);
        options.hash = this.popStack();
        if (this.trackIds) {
          options.hashIds = this.popStack();
        }
        if (this.stringParams) {
          options.hashTypes = this.popStack();
          options.hashContexts = this.popStack();
        }
        var inverse = this.popStack(), program = this.popStack();
        if (program || inverse) {
          options.fn = program || "container.noop";
          options.inverse = inverse || "container.noop";
        }
        var i = paramSize;
        while (i--) {
          param = this.popStack();
          params[i] = param;
          if (this.trackIds) {
            ids[i] = this.popStack();
          }
          if (this.stringParams) {
            types[i] = this.popStack();
            contexts[i] = this.popStack();
          }
        }
        if (objectArgs) {
          options.args = this.source.generateArray(params);
        }
        if (this.trackIds) {
          options.ids = this.source.generateArray(ids);
        }
        if (this.stringParams) {
          options.types = this.source.generateArray(types);
          options.contexts = this.source.generateArray(contexts);
        }
        if (this.options.data) {
          options.data = "data";
        }
        if (this.useBlockParams) {
          options.blockParams = "blockParams";
        }
        return options;
      },
      setupHelperArgs: function setupHelperArgs(helper, paramSize, params, useRegister) {
        var options = this.setupParams(helper, paramSize, params);
        options.loc = JSON.stringify(this.source.currentLocation);
        options = this.objectLiteral(options);
        if (useRegister) {
          this.useRegister("options");
          params.push("options");
          return ["options=", options];
        } else if (params) {
          params.push(options);
          return "";
        } else {
          return options;
        }
      }
    };
    (function() {
      var reservedWords = "break else new var case finally return void catch for switch while continue function this with default if throw delete in try do instanceof typeof abstract enum int short boolean export interface static byte extends long super char final native synchronized class float package throws const goto private transient debugger implements protected volatile double import public let yield await null true false".split(" ");
      var compilerWords = JavaScriptCompiler.RESERVED_WORDS = {};
      for (var i = 0, l = reservedWords.length; i < l; i++) {
        compilerWords[reservedWords[i]] = true;
      }
    })();
    JavaScriptCompiler.isValidJavaScriptVariableName = function(name) {
      return !JavaScriptCompiler.RESERVED_WORDS[name] && /^[a-zA-Z_$][0-9a-zA-Z_$]*$/.test(name);
    };
    function strictLookup(requireTerminal, compiler, parts, type) {
      var stack = compiler.popStack(), i = 0, len = parts.length;
      if (requireTerminal) {
        len--;
      }
      for (; i < len; i++) {
        stack = compiler.nameLookup(stack, parts[i], type);
      }
      if (requireTerminal) {
        return [compiler.aliasable("container.strict"), "(", stack, ", ", compiler.quotedString(parts[i]), ", ", JSON.stringify(compiler.source.currentLocation), " )"];
      } else {
        return stack;
      }
    }
    exports["default"] = JavaScriptCompiler;
    module2.exports = exports["default"];
  }
});

// node_modules/handlebars/dist/cjs/handlebars.js
var require_handlebars = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars.js"(exports, module2) {
    "use strict";
    exports.__esModule = true;
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var _handlebarsRuntime = require_handlebars_runtime();
    var _handlebarsRuntime2 = _interopRequireDefault(_handlebarsRuntime);
    var _handlebarsCompilerAst = require_ast();
    var _handlebarsCompilerAst2 = _interopRequireDefault(_handlebarsCompilerAst);
    var _handlebarsCompilerBase = require_base2();
    var _handlebarsCompilerCompiler = require_compiler();
    var _handlebarsCompilerJavascriptCompiler = require_javascript_compiler();
    var _handlebarsCompilerJavascriptCompiler2 = _interopRequireDefault(_handlebarsCompilerJavascriptCompiler);
    var _handlebarsCompilerVisitor = require_visitor();
    var _handlebarsCompilerVisitor2 = _interopRequireDefault(_handlebarsCompilerVisitor);
    var _handlebarsNoConflict = require_no_conflict();
    var _handlebarsNoConflict2 = _interopRequireDefault(_handlebarsNoConflict);
    var _create = _handlebarsRuntime2["default"].create;
    function create() {
      var hb = _create();
      hb.compile = function(input, options) {
        return _handlebarsCompilerCompiler.compile(input, options, hb);
      };
      hb.precompile = function(input, options) {
        return _handlebarsCompilerCompiler.precompile(input, options, hb);
      };
      hb.AST = _handlebarsCompilerAst2["default"];
      hb.Compiler = _handlebarsCompilerCompiler.Compiler;
      hb.JavaScriptCompiler = _handlebarsCompilerJavascriptCompiler2["default"];
      hb.Parser = _handlebarsCompilerBase.parser;
      hb.parse = _handlebarsCompilerBase.parse;
      hb.parseWithoutProcessing = _handlebarsCompilerBase.parseWithoutProcessing;
      return hb;
    }
    var inst = create();
    inst.create = create;
    _handlebarsNoConflict2["default"](inst);
    inst.Visitor = _handlebarsCompilerVisitor2["default"];
    inst["default"] = inst;
    exports["default"] = inst;
    module2.exports = exports["default"];
  }
});

// node_modules/handlebars/dist/cjs/handlebars/compiler/printer.js
var require_printer = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars/compiler/printer.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.print = print;
    exports.PrintVisitor = PrintVisitor;
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var _visitor = require_visitor();
    var _visitor2 = _interopRequireDefault(_visitor);
    function print(ast) {
      return new PrintVisitor().accept(ast);
    }
    function PrintVisitor() {
      this.padding = 0;
    }
    PrintVisitor.prototype = new _visitor2["default"]();
    PrintVisitor.prototype.pad = function(string) {
      var out = "";
      for (var i = 0, l = this.padding; i < l; i++) {
        out += "  ";
      }
      out += string + "\n";
      return out;
    };
    PrintVisitor.prototype.Program = function(program) {
      var out = "", body = program.body, i = void 0, l = void 0;
      if (program.blockParams) {
        var blockParams = "BLOCK PARAMS: [";
        for (i = 0, l = program.blockParams.length; i < l; i++) {
          blockParams += " " + program.blockParams[i];
        }
        blockParams += " ]";
        out += this.pad(blockParams);
      }
      for (i = 0, l = body.length; i < l; i++) {
        out += this.accept(body[i]);
      }
      this.padding--;
      return out;
    };
    PrintVisitor.prototype.MustacheStatement = function(mustache) {
      return this.pad("{{ " + this.SubExpression(mustache) + " }}");
    };
    PrintVisitor.prototype.Decorator = function(mustache) {
      return this.pad("{{ DIRECTIVE " + this.SubExpression(mustache) + " }}");
    };
    PrintVisitor.prototype.BlockStatement = PrintVisitor.prototype.DecoratorBlock = function(block) {
      var out = "";
      out += this.pad((block.type === "DecoratorBlock" ? "DIRECTIVE " : "") + "BLOCK:");
      this.padding++;
      out += this.pad(this.SubExpression(block));
      if (block.program) {
        out += this.pad("PROGRAM:");
        this.padding++;
        out += this.accept(block.program);
        this.padding--;
      }
      if (block.inverse) {
        if (block.program) {
          this.padding++;
        }
        out += this.pad("{{^}}");
        this.padding++;
        out += this.accept(block.inverse);
        this.padding--;
        if (block.program) {
          this.padding--;
        }
      }
      this.padding--;
      return out;
    };
    PrintVisitor.prototype.PartialStatement = function(partial) {
      var content = "PARTIAL:" + partial.name.original;
      if (partial.params[0]) {
        content += " " + this.accept(partial.params[0]);
      }
      if (partial.hash) {
        content += " " + this.accept(partial.hash);
      }
      return this.pad("{{> " + content + " }}");
    };
    PrintVisitor.prototype.PartialBlockStatement = function(partial) {
      var content = "PARTIAL BLOCK:" + partial.name.original;
      if (partial.params[0]) {
        content += " " + this.accept(partial.params[0]);
      }
      if (partial.hash) {
        content += " " + this.accept(partial.hash);
      }
      content += " " + this.pad("PROGRAM:");
      this.padding++;
      content += this.accept(partial.program);
      this.padding--;
      return this.pad("{{> " + content + " }}");
    };
    PrintVisitor.prototype.ContentStatement = function(content) {
      return this.pad("CONTENT[ '" + content.value + "' ]");
    };
    PrintVisitor.prototype.CommentStatement = function(comment) {
      return this.pad("{{! '" + comment.value + "' }}");
    };
    PrintVisitor.prototype.SubExpression = function(sexpr) {
      var params = sexpr.params, paramStrings = [], hash = void 0;
      for (var i = 0, l = params.length; i < l; i++) {
        paramStrings.push(this.accept(params[i]));
      }
      params = "[" + paramStrings.join(", ") + "]";
      hash = sexpr.hash ? " " + this.accept(sexpr.hash) : "";
      return this.accept(sexpr.path) + " " + params + hash;
    };
    PrintVisitor.prototype.PathExpression = function(id) {
      var path = id.parts.join("/");
      return (id.data ? "@" : "") + "PATH:" + path;
    };
    PrintVisitor.prototype.StringLiteral = function(string) {
      return '"' + string.value + '"';
    };
    PrintVisitor.prototype.NumberLiteral = function(number) {
      return "NUMBER{" + number.value + "}";
    };
    PrintVisitor.prototype.BooleanLiteral = function(bool) {
      return "BOOLEAN{" + bool.value + "}";
    };
    PrintVisitor.prototype.UndefinedLiteral = function() {
      return "UNDEFINED";
    };
    PrintVisitor.prototype.NullLiteral = function() {
      return "NULL";
    };
    PrintVisitor.prototype.Hash = function(hash) {
      var pairs = hash.pairs, joinedPairs = [];
      for (var i = 0, l = pairs.length; i < l; i++) {
        joinedPairs.push(this.accept(pairs[i]));
      }
      return "HASH{" + joinedPairs.join(", ") + "}";
    };
    PrintVisitor.prototype.HashPair = function(pair) {
      return pair.key + "=" + this.accept(pair.value);
    };
  }
});

// node_modules/handlebars/lib/index.js
var require_lib = __commonJS({
  "node_modules/handlebars/lib/index.js"(exports, module2) {
    var handlebars2 = require_handlebars()["default"];
    var printer = require_printer();
    handlebars2.PrintVisitor = printer.PrintVisitor;
    handlebars2.print = printer.print;
    module2.exports = handlebars2;
    function extension(module3, filename) {
      var fs = require("fs");
      var templateString = fs.readFileSync(filename, "utf8");
      module3.exports = handlebars2.compile(templateString);
    }
    if (typeof require !== "undefined" && require.extensions) {
      require.extensions[".handlebars"] = extension;
      require.extensions[".hbs"] = extension;
    }
  }
});

// node_modules/for-in/index.js
var require_for_in = __commonJS({
  "node_modules/for-in/index.js"(exports, module2) {
    "use strict";
    module2.exports = function forIn(obj, fn, thisArg) {
      for (var key in obj) {
        if (fn.call(thisArg, obj[key], key, obj) === false) {
          break;
        }
      }
    };
  }
});

// node_modules/isobject/index.js
var require_isobject = __commonJS({
  "node_modules/isobject/index.js"(exports, module2) {
    "use strict";
    module2.exports = function isObject(val) {
      return val != null && typeof val === "object" && Array.isArray(val) === false;
    };
  }
});

// node_modules/kind-of/index.js
var require_kind_of = __commonJS({
  "node_modules/kind-of/index.js"(exports, module2) {
    var toString = Object.prototype.toString;
    module2.exports = function kindOf(val) {
      if (val === void 0)
        return "undefined";
      if (val === null)
        return "null";
      var type = typeof val;
      if (type === "boolean")
        return "boolean";
      if (type === "string")
        return "string";
      if (type === "number")
        return "number";
      if (type === "symbol")
        return "symbol";
      if (type === "function") {
        return isGeneratorFn(val) ? "generatorfunction" : "function";
      }
      if (isArray(val))
        return "array";
      if (isBuffer(val))
        return "buffer";
      if (isArguments(val))
        return "arguments";
      if (isDate(val))
        return "date";
      if (isError(val))
        return "error";
      if (isRegexp(val))
        return "regexp";
      switch (ctorName(val)) {
        case "Symbol":
          return "symbol";
        case "Promise":
          return "promise";
        case "WeakMap":
          return "weakmap";
        case "WeakSet":
          return "weakset";
        case "Map":
          return "map";
        case "Set":
          return "set";
        case "Int8Array":
          return "int8array";
        case "Uint8Array":
          return "uint8array";
        case "Uint8ClampedArray":
          return "uint8clampedarray";
        case "Int16Array":
          return "int16array";
        case "Uint16Array":
          return "uint16array";
        case "Int32Array":
          return "int32array";
        case "Uint32Array":
          return "uint32array";
        case "Float32Array":
          return "float32array";
        case "Float64Array":
          return "float64array";
      }
      if (isGeneratorObj(val)) {
        return "generator";
      }
      type = toString.call(val);
      switch (type) {
        case "[object Object]":
          return "object";
        case "[object Map Iterator]":
          return "mapiterator";
        case "[object Set Iterator]":
          return "setiterator";
        case "[object String Iterator]":
          return "stringiterator";
        case "[object Array Iterator]":
          return "arrayiterator";
      }
      return type.slice(8, -1).toLowerCase().replace(/\s/g, "");
    };
    function ctorName(val) {
      return typeof val.constructor === "function" ? val.constructor.name : null;
    }
    function isArray(val) {
      if (Array.isArray)
        return Array.isArray(val);
      return val instanceof Array;
    }
    function isError(val) {
      return val instanceof Error || typeof val.message === "string" && val.constructor && typeof val.constructor.stackTraceLimit === "number";
    }
    function isDate(val) {
      if (val instanceof Date)
        return true;
      return typeof val.toDateString === "function" && typeof val.getDate === "function" && typeof val.setDate === "function";
    }
    function isRegexp(val) {
      if (val instanceof RegExp)
        return true;
      return typeof val.flags === "string" && typeof val.ignoreCase === "boolean" && typeof val.multiline === "boolean" && typeof val.global === "boolean";
    }
    function isGeneratorFn(name, val) {
      return ctorName(name) === "GeneratorFunction";
    }
    function isGeneratorObj(val) {
      return typeof val.throw === "function" && typeof val.return === "function" && typeof val.next === "function";
    }
    function isArguments(val) {
      try {
        if (typeof val.length === "number" && typeof val.callee === "function") {
          return true;
        }
      } catch (err) {
        if (err.message.indexOf("callee") !== -1) {
          return true;
        }
      }
      return false;
    }
    function isBuffer(val) {
      if (val.constructor && typeof val.constructor.isBuffer === "function") {
        return val.constructor.isBuffer(val);
      }
      return false;
    }
  }
});

// node_modules/is-accessor-descriptor/index.js
var require_is_accessor_descriptor = __commonJS({
  "node_modules/is-accessor-descriptor/index.js"(exports, module2) {
    "use strict";
    var typeOf = require_kind_of();
    var accessor = {
      get: "function",
      set: "function",
      configurable: "boolean",
      enumerable: "boolean"
    };
    function isAccessorDescriptor(obj, prop) {
      if (typeof prop === "string") {
        var val = Object.getOwnPropertyDescriptor(obj, prop);
        return typeof val !== "undefined";
      }
      if (typeOf(obj) !== "object") {
        return false;
      }
      if (has(obj, "value") || has(obj, "writable")) {
        return false;
      }
      if (!has(obj, "get") || typeof obj.get !== "function") {
        return false;
      }
      if (has(obj, "set") && typeof obj[key] !== "function" && typeof obj[key] !== "undefined") {
        return false;
      }
      for (var key in obj) {
        if (!accessor.hasOwnProperty(key)) {
          continue;
        }
        if (typeOf(obj[key]) === accessor[key]) {
          continue;
        }
        if (typeof obj[key] !== "undefined") {
          return false;
        }
      }
      return true;
    }
    function has(obj, key) {
      return {}.hasOwnProperty.call(obj, key);
    }
    module2.exports = isAccessorDescriptor;
  }
});

// node_modules/is-data-descriptor/index.js
var require_is_data_descriptor = __commonJS({
  "node_modules/is-data-descriptor/index.js"(exports, module2) {
    "use strict";
    var typeOf = require_kind_of();
    module2.exports = function isDataDescriptor(obj, prop) {
      var data = {
        configurable: "boolean",
        enumerable: "boolean",
        writable: "boolean"
      };
      if (typeOf(obj) !== "object") {
        return false;
      }
      if (typeof prop === "string") {
        var val = Object.getOwnPropertyDescriptor(obj, prop);
        return typeof val !== "undefined";
      }
      if (!("value" in obj) && !("writable" in obj)) {
        return false;
      }
      for (var key in obj) {
        if (key === "value")
          continue;
        if (!data.hasOwnProperty(key)) {
          continue;
        }
        if (typeOf(obj[key]) === data[key]) {
          continue;
        }
        if (typeof obj[key] !== "undefined") {
          return false;
        }
      }
      return true;
    };
  }
});

// node_modules/is-descriptor/index.js
var require_is_descriptor = __commonJS({
  "node_modules/is-descriptor/index.js"(exports, module2) {
    "use strict";
    var typeOf = require_kind_of();
    var isAccessor = require_is_accessor_descriptor();
    var isData = require_is_data_descriptor();
    module2.exports = function isDescriptor(obj, key) {
      if (typeOf(obj) !== "object") {
        return false;
      }
      if ("get" in obj) {
        return isAccessor(obj, key);
      }
      return isData(obj, key);
    };
  }
});

// node_modules/@budibase/handlebars-helpers/node_modules/define-property/index.js
var require_define_property = __commonJS({
  "node_modules/@budibase/handlebars-helpers/node_modules/define-property/index.js"(exports, module2) {
    "use strict";
    var isobject = require_isobject();
    var isDescriptor = require_is_descriptor();
    var define2 = typeof Reflect !== "undefined" && Reflect.defineProperty ? Reflect.defineProperty : Object.defineProperty;
    module2.exports = function defineProperty(obj, key, val) {
      if (!isobject(obj) && typeof obj !== "function" && !Array.isArray(obj)) {
        throw new TypeError("expected an object, function, or array");
      }
      if (typeof key !== "string") {
        throw new TypeError('expected "key" to be a string');
      }
      if (isDescriptor(val)) {
        define2(obj, key, val);
        return obj;
      }
      define2(obj, key, {
        configurable: true,
        enumerable: false,
        writable: true,
        value: val
      });
      return obj;
    };
  }
});

// node_modules/is-buffer/index.js
var require_is_buffer = __commonJS({
  "node_modules/is-buffer/index.js"(exports, module2) {
    module2.exports = function(obj) {
      return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer);
    };
    function isBuffer(obj) {
      return !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
    }
    function isSlowBuffer(obj) {
      return typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isBuffer(obj.slice(0, 0));
    }
  }
});

// node_modules/typeof-article/node_modules/kind-of/index.js
var require_kind_of2 = __commonJS({
  "node_modules/typeof-article/node_modules/kind-of/index.js"(exports, module2) {
    var isBuffer = require_is_buffer();
    var toString = Object.prototype.toString;
    module2.exports = function kindOf(val) {
      if (typeof val === "undefined") {
        return "undefined";
      }
      if (val === null) {
        return "null";
      }
      if (val === true || val === false || val instanceof Boolean) {
        return "boolean";
      }
      if (typeof val === "string" || val instanceof String) {
        return "string";
      }
      if (typeof val === "number" || val instanceof Number) {
        return "number";
      }
      if (typeof val === "function" || val instanceof Function) {
        return "function";
      }
      if (typeof Array.isArray !== "undefined" && Array.isArray(val)) {
        return "array";
      }
      if (val instanceof RegExp) {
        return "regexp";
      }
      if (val instanceof Date) {
        return "date";
      }
      var type = toString.call(val);
      if (type === "[object RegExp]") {
        return "regexp";
      }
      if (type === "[object Date]") {
        return "date";
      }
      if (type === "[object Arguments]") {
        return "arguments";
      }
      if (type === "[object Error]") {
        return "error";
      }
      if (isBuffer(val)) {
        return "buffer";
      }
      if (type === "[object Set]") {
        return "set";
      }
      if (type === "[object WeakSet]") {
        return "weakset";
      }
      if (type === "[object Map]") {
        return "map";
      }
      if (type === "[object WeakMap]") {
        return "weakmap";
      }
      if (type === "[object Symbol]") {
        return "symbol";
      }
      if (type === "[object Int8Array]") {
        return "int8array";
      }
      if (type === "[object Uint8Array]") {
        return "uint8array";
      }
      if (type === "[object Uint8ClampedArray]") {
        return "uint8clampedarray";
      }
      if (type === "[object Int16Array]") {
        return "int16array";
      }
      if (type === "[object Uint16Array]") {
        return "uint16array";
      }
      if (type === "[object Int32Array]") {
        return "int32array";
      }
      if (type === "[object Uint32Array]") {
        return "uint32array";
      }
      if (type === "[object Float32Array]") {
        return "float32array";
      }
      if (type === "[object Float64Array]") {
        return "float64array";
      }
      return "object";
    };
  }
});

// node_modules/typeof-article/index.js
var require_typeof_article = __commonJS({
  "node_modules/typeof-article/index.js"(exports, module2) {
    "use strict";
    var typeOf = require_kind_of2();
    var types = {
      "arguments": "an arguments object",
      "array": "an array",
      "boolean": "a boolean",
      "buffer": "a buffer",
      "date": "a date",
      "error": "an error",
      "float32array": "a float32array",
      "float64array": "a float64array",
      "function": "a function",
      "int16array": "an int16array",
      "int32array": "an int32array",
      "int8array": "an int8array",
      "map": "a Map",
      "null": "null",
      "number": "a number",
      "object": "an object",
      "regexp": "a regular expression",
      "set": "a Set",
      "string": "a string",
      "symbol": "a symbol",
      "uint16array": "an uint16array",
      "uint32array": "an uint32array",
      "uint8array": "an uint8array",
      "uint8clampedarray": "an uint8clampedarray",
      "undefined": "undefined",
      "weakmap": "a WeakMap",
      "weakset": "a WeakSet"
    };
    function type(val) {
      return types[typeOf(val)];
    }
    type.types = types;
    type.typeOf = typeOf;
    module2.exports = type;
  }
});

// node_modules/handlebars-utils/index.js
var require_handlebars_utils = __commonJS({
  "node_modules/handlebars-utils/index.js"(exports, module2) {
    "use strict";
    var util = require("util");
    var type = require_typeof_article();
    var typeOf = require_kind_of();
    var utils = exports = module2.exports;
    utils.extend = extend;
    utils.indexOf = indexOf;
    utils.escapeExpression = escapeExpression;
    utils.isEmpty = isEmpty;
    utils.createFrame = createFrame;
    utils.blockParams = blockParams;
    utils.appendContextPath = appendContextPath;
    var escape = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#x27;",
      "`": "&#x60;",
      "=": "&#x3D;"
    };
    var badChars = /[&<>"'`=]/g;
    var possible = /[&<>"'`=]/;
    function escapeChar(chr) {
      return escape[chr];
    }
    function extend(obj) {
      for (var i = 1; i < arguments.length; i++) {
        for (var key in arguments[i]) {
          if (Object.prototype.hasOwnProperty.call(arguments[i], key)) {
            obj[key] = arguments[i][key];
          }
        }
      }
      return obj;
    }
    var toString = Object.prototype.toString;
    utils.toString = toString;
    var isFunction = function isFunction2(value2) {
      return typeof value2 === "function";
    };
    if (isFunction(/x/)) {
      utils.isFunction = isFunction = function(value2) {
        return typeof value2 === "function" && toString.call(value2) === "[object Function]";
      };
    }
    utils.isFunction = isFunction;
    var isArray = Array.isArray || function(value2) {
      return value2 && typeof value2 === "object" ? toString.call(value2) === "[object Array]" : false;
    };
    utils.isArray = isArray;
    function indexOf(array, value2) {
      for (var i = 0, len = array.length; i < len; i++) {
        if (array[i] === value2) {
          return i;
        }
      }
      return -1;
    }
    function escapeExpression(string) {
      if (typeof string !== "string") {
        if (string && string.toHTML) {
          return string.toHTML();
        } else if (string == null) {
          return "";
        } else if (!string) {
          return string + "";
        }
        string = "" + string;
      }
      if (!possible.test(string)) {
        return string;
      }
      return string.replace(badChars, escapeChar);
    }
    function createFrame(object) {
      var frame = extend({}, object);
      frame._parent = object;
      return frame;
    }
    function blockParams(params, ids) {
      params.path = ids;
      return params;
    }
    function appendContextPath(contextPath, id) {
      return (contextPath ? contextPath + "." : "") + id;
    }
    utils.expectedType = function(param, expected, actual) {
      var exp = type.types[expected];
      var val = util.inspect(actual);
      return "expected " + param + " to be " + exp + " but received " + type(actual) + ": " + val;
    };
    utils.isBlock = function(options) {
      return utils.isOptions(options) && typeof options.fn === "function" && typeof options.inverse === "function";
    };
    utils.fn = function(val, context, options) {
      if (utils.isOptions(val)) {
        return utils.fn("", val, options);
      }
      if (utils.isOptions(context)) {
        return utils.fn(val, {}, context);
      }
      return utils.isBlock(options) ? options.fn(context) : val;
    };
    utils.inverse = function(val, context, options) {
      if (utils.isOptions(val)) {
        return utils.identity("", val, options);
      }
      if (utils.isOptions(context)) {
        return utils.inverse(val, {}, context);
      }
      return utils.isBlock(options) ? options.inverse(context) : val;
    };
    utils.value = function(val, context, options) {
      if (utils.isOptions(val)) {
        return utils.value(null, val, options);
      }
      if (utils.isOptions(context)) {
        return utils.value(val, {}, context);
      }
      if (utils.isBlock(options)) {
        return !!val ? options.fn(context) : options.inverse(context);
      }
      return val;
    };
    utils.isOptions = function(val) {
      return utils.isObject(val) && utils.isObject(val.hash);
    };
    utils.isUndefined = function(val) {
      return val == null || utils.isOptions(val) && val.hash != null;
    };
    utils.isApp = function(thisArg) {
      return utils.isObject(thisArg) && utils.isObject(thisArg.options) && utils.isObject(thisArg.app);
    };
    utils.options = function(thisArg, locals, options) {
      if (utils.isOptions(thisArg)) {
        return utils.options({}, locals, thisArg);
      }
      if (utils.isOptions(locals)) {
        return utils.options(thisArg, options, locals);
      }
      options = options || {};
      if (!utils.isOptions(options)) {
        locals = Object.assign({}, locals, options);
      }
      var opts = Object.assign({}, locals, options.hash);
      if (utils.isObject(thisArg)) {
        opts = Object.assign({}, thisArg.options, opts);
      }
      if (opts[options.name]) {
        opts = Object.assign({}, opts[options.name], opts);
      }
      return opts;
    };
    utils.context = function(thisArg, locals, options) {
      if (utils.isOptions(thisArg)) {
        return utils.context({}, locals, thisArg);
      }
      if (utils.isOptions(locals)) {
        return utils.context(thisArg, options, locals);
      }
      var appContext = utils.isApp(thisArg) ? thisArg.context : {};
      options = options || {};
      if (!utils.isOptions(options)) {
        locals = Object.assign({}, locals, options);
      }
      if (utils.isOptions(options) && options.hash.root === true) {
        locals = Object.assign({}, options.data.root, locals);
      }
      var context = Object.assign({}, appContext, locals, options.hash);
      if (!utils.isApp(thisArg)) {
        context = Object.assign({}, thisArg, context);
      }
      if (utils.isApp(thisArg) && thisArg.view && thisArg.view.data) {
        context = Object.assign({}, context, thisArg.view.data);
      }
      return context;
    };
    utils.isObject = function(val) {
      return typeOf(val) === "object";
    };
    function isEmpty(val) {
      if (val === 0 || typeof val === "boolean") {
        return false;
      }
      if (val == null) {
        return true;
      }
      if (utils.isObject(val)) {
        val = Object.keys(val);
      }
      if (!val.length) {
        return true;
      }
      return false;
    }
    utils.result = function(val) {
      if (typeof val === "function") {
        return val.apply(this, [].slice.call(arguments, 1));
      }
      return val;
    };
    utils.identity = function(val) {
      return val;
    };
    utils.isString = function(val) {
      return typeof val === "string" && val !== "";
    };
    utils.arrayify = function(val) {
      return val != null ? Array.isArray(val) ? val : [val] : [];
    };
    utils.tryParse = function(str) {
      try {
        return JSON.parse(str);
      } catch (err) {
      }
      return {};
    };
  }
});

// node_modules/default-compare/node_modules/kind-of/index.js
var require_kind_of3 = __commonJS({
  "node_modules/default-compare/node_modules/kind-of/index.js"(exports, module2) {
    var toString = Object.prototype.toString;
    module2.exports = function kindOf(val) {
      var type = typeof val;
      if (type === "undefined") {
        return "undefined";
      }
      if (val === null) {
        return "null";
      }
      if (val === true || val === false || val instanceof Boolean) {
        return "boolean";
      }
      if (type === "string" || val instanceof String) {
        return "string";
      }
      if (type === "number" || val instanceof Number) {
        return "number";
      }
      if (type === "function" || val instanceof Function) {
        if (typeof val.constructor.name !== "undefined" && val.constructor.name.slice(0, 9) === "Generator") {
          return "generatorfunction";
        }
        return "function";
      }
      if (typeof Array.isArray !== "undefined" && Array.isArray(val)) {
        return "array";
      }
      if (val instanceof RegExp) {
        return "regexp";
      }
      if (val instanceof Date) {
        return "date";
      }
      type = toString.call(val);
      if (type === "[object RegExp]") {
        return "regexp";
      }
      if (type === "[object Date]") {
        return "date";
      }
      if (type === "[object Arguments]") {
        return "arguments";
      }
      if (type === "[object Error]") {
        return "error";
      }
      if (type === "[object Promise]") {
        return "promise";
      }
      if (isBuffer(val)) {
        return "buffer";
      }
      if (type === "[object Set]") {
        return "set";
      }
      if (type === "[object WeakSet]") {
        return "weakset";
      }
      if (type === "[object Map]") {
        return "map";
      }
      if (type === "[object WeakMap]") {
        return "weakmap";
      }
      if (type === "[object Symbol]") {
        return "symbol";
      }
      if (type === "[object Map Iterator]") {
        return "mapiterator";
      }
      if (type === "[object Set Iterator]") {
        return "setiterator";
      }
      if (type === "[object String Iterator]") {
        return "stringiterator";
      }
      if (type === "[object Array Iterator]") {
        return "arrayiterator";
      }
      if (type === "[object Int8Array]") {
        return "int8array";
      }
      if (type === "[object Uint8Array]") {
        return "uint8array";
      }
      if (type === "[object Uint8ClampedArray]") {
        return "uint8clampedarray";
      }
      if (type === "[object Int16Array]") {
        return "int16array";
      }
      if (type === "[object Uint16Array]") {
        return "uint16array";
      }
      if (type === "[object Int32Array]") {
        return "int32array";
      }
      if (type === "[object Uint32Array]") {
        return "uint32array";
      }
      if (type === "[object Float32Array]") {
        return "float32array";
      }
      if (type === "[object Float64Array]") {
        return "float64array";
      }
      return "object";
    };
    function isBuffer(val) {
      return val.constructor && typeof val.constructor.isBuffer === "function" && val.constructor.isBuffer(val);
    }
  }
});

// node_modules/default-compare/index.js
var require_default_compare = __commonJS({
  "node_modules/default-compare/index.js"(exports, module2) {
    "use strict";
    var typeOf = require_kind_of3();
    module2.exports = function defaultCompare(a, b, prop) {
      if (prop != null && typeOf(prop) !== "string") {
        throw new TypeError('expected "prop" to be undefined or a string');
      }
      var typeA = typeOf(a);
      var typeB = typeOf(b);
      if (prop) {
        if (typeA === "object") {
          a = a[prop];
          typeA = typeOf(a);
        }
        if (typeB === "object") {
          b = b[prop];
          typeB = typeOf(b);
        }
      }
      if (typeA === "null") {
        return typeB === "null" ? 0 : typeB === "undefined" ? -1 : 1;
      } else if (typeA === "undefined") {
        return typeB === "null" ? 1 : typeB === "undefined" ? 0 : 1;
      } else if (typeB === "null" || typeB === "undefined") {
        return -1;
      } else {
        return a < b ? -1 : a > b ? 1 : 0;
      }
    };
  }
});

// node_modules/array-sort/node_modules/kind-of/index.js
var require_kind_of4 = __commonJS({
  "node_modules/array-sort/node_modules/kind-of/index.js"(exports, module2) {
    var toString = Object.prototype.toString;
    module2.exports = function kindOf(val) {
      var type = typeof val;
      if (type === "undefined") {
        return "undefined";
      }
      if (val === null) {
        return "null";
      }
      if (val === true || val === false || val instanceof Boolean) {
        return "boolean";
      }
      if (type === "string" || val instanceof String) {
        return "string";
      }
      if (type === "number" || val instanceof Number) {
        return "number";
      }
      if (type === "function" || val instanceof Function) {
        if (typeof val.constructor.name !== "undefined" && val.constructor.name.slice(0, 9) === "Generator") {
          return "generatorfunction";
        }
        return "function";
      }
      if (typeof Array.isArray !== "undefined" && Array.isArray(val)) {
        return "array";
      }
      if (val instanceof RegExp) {
        return "regexp";
      }
      if (val instanceof Date) {
        return "date";
      }
      type = toString.call(val);
      if (type === "[object RegExp]") {
        return "regexp";
      }
      if (type === "[object Date]") {
        return "date";
      }
      if (type === "[object Arguments]") {
        return "arguments";
      }
      if (type === "[object Error]") {
        return "error";
      }
      if (type === "[object Promise]") {
        return "promise";
      }
      if (isBuffer(val)) {
        return "buffer";
      }
      if (type === "[object Set]") {
        return "set";
      }
      if (type === "[object WeakSet]") {
        return "weakset";
      }
      if (type === "[object Map]") {
        return "map";
      }
      if (type === "[object WeakMap]") {
        return "weakmap";
      }
      if (type === "[object Symbol]") {
        return "symbol";
      }
      if (type === "[object Map Iterator]") {
        return "mapiterator";
      }
      if (type === "[object Set Iterator]") {
        return "setiterator";
      }
      if (type === "[object String Iterator]") {
        return "stringiterator";
      }
      if (type === "[object Array Iterator]") {
        return "arrayiterator";
      }
      if (type === "[object Int8Array]") {
        return "int8array";
      }
      if (type === "[object Uint8Array]") {
        return "uint8array";
      }
      if (type === "[object Uint8ClampedArray]") {
        return "uint8clampedarray";
      }
      if (type === "[object Int16Array]") {
        return "int16array";
      }
      if (type === "[object Uint16Array]") {
        return "uint16array";
      }
      if (type === "[object Int32Array]") {
        return "int32array";
      }
      if (type === "[object Uint32Array]") {
        return "uint32array";
      }
      if (type === "[object Float32Array]") {
        return "float32array";
      }
      if (type === "[object Float64Array]") {
        return "float64array";
      }
      return "object";
    };
    function isBuffer(val) {
      return val.constructor && typeof val.constructor.isBuffer === "function" && val.constructor.isBuffer(val);
    }
  }
});

// node_modules/get-value/index.js
var require_get_value = __commonJS({
  "node_modules/get-value/index.js"(exports, module2) {
    module2.exports = function(obj, prop, a, b, c) {
      if (!isObject(obj) || !prop) {
        return obj;
      }
      prop = toString(prop);
      if (a)
        prop += "." + toString(a);
      if (b)
        prop += "." + toString(b);
      if (c)
        prop += "." + toString(c);
      if (prop in obj) {
        return obj[prop];
      }
      var segs = prop.split(".");
      var len = segs.length;
      var i = -1;
      while (obj && ++i < len) {
        var key = segs[i];
        while (key[key.length - 1] === "\\") {
          key = key.slice(0, -1) + "." + segs[++i];
        }
        obj = obj[key];
      }
      return obj;
    };
    function isObject(val) {
      return val !== null && (typeof val === "object" || typeof val === "function");
    }
    function toString(val) {
      if (!val)
        return "";
      if (Array.isArray(val)) {
        return val.join(".");
      }
      return val;
    }
  }
});

// node_modules/array-sort/index.js
var require_array_sort = __commonJS({
  "node_modules/array-sort/index.js"(exports, module2) {
    "use strict";
    var defaultCompare = require_default_compare();
    var typeOf = require_kind_of4();
    var get = require_get_value();
    function arraySort(arr, props, opts) {
      if (arr == null) {
        return [];
      }
      if (!Array.isArray(arr)) {
        throw new TypeError("array-sort expects an array.");
      }
      if (arguments.length === 1) {
        return arr.sort();
      }
      var args = flatten([].slice.call(arguments, 1));
      if (typeOf(args[args.length - 1]) === "object") {
        opts = args.pop();
      }
      return arr.sort(sortBy(args, opts));
    }
    function sortBy(props, opts) {
      opts = opts || {};
      return function compareFn(a, b) {
        var len = props.length, i = -1;
        var result;
        while (++i < len) {
          result = compare(props[i], a, b);
          if (result !== 0) {
            break;
          }
        }
        if (opts.reverse === true) {
          return result * -1;
        }
        return result;
      };
    }
    function compare(prop, a, b) {
      if (typeof prop === "function") {
        return prop(a, b, compare.bind(null, null));
      }
      if (prop && typeof a === "object" && typeof b === "object") {
        return compare(null, get(a, prop), get(b, prop));
      }
      return defaultCompare(a, b);
    }
    function flatten(arr) {
      return [].concat.apply([], arr);
    }
    module2.exports = arraySort;
  }
});

// node_modules/@budibase/handlebars-helpers/node_modules/get-value/index.js
var require_get_value2 = __commonJS({
  "node_modules/@budibase/handlebars-helpers/node_modules/get-value/index.js"(exports, module2) {
    var isObject = require_isobject();
    module2.exports = function(target, path, options) {
      if (!isObject(options)) {
        options = { default: options };
      }
      if (!isValidObject(target)) {
        return typeof options.default !== "undefined" ? options.default : target;
      }
      if (typeof path === "number") {
        path = String(path);
      }
      const isArray = Array.isArray(path);
      const isString = typeof path === "string";
      const splitChar = options.separator || ".";
      const joinChar = options.joinChar || (typeof splitChar === "string" ? splitChar : ".");
      if (!isString && !isArray) {
        return target;
      }
      if (isString && path in target) {
        return isValid(path, target, options) ? target[path] : options.default;
      }
      let segs = isArray ? path : split(path, splitChar, options);
      let len = segs.length;
      let idx = 0;
      do {
        let prop = segs[idx];
        if (typeof prop === "number") {
          prop = String(prop);
        }
        while (prop && prop.slice(-1) === "\\") {
          prop = join([prop.slice(0, -1), segs[++idx] || ""], joinChar, options);
        }
        if (prop in target) {
          if (!isValid(prop, target, options)) {
            return options.default;
          }
          target = target[prop];
        } else {
          let hasProp = false;
          let n = idx + 1;
          while (n < len) {
            prop = join([prop, segs[n++]], joinChar, options);
            if (hasProp = prop in target) {
              if (!isValid(prop, target, options)) {
                return options.default;
              }
              target = target[prop];
              idx = n - 1;
              break;
            }
          }
          if (!hasProp) {
            return options.default;
          }
        }
      } while (++idx < len && isValidObject(target));
      if (idx === len) {
        return target;
      }
      return options.default;
    };
    function join(segs, joinChar, options) {
      if (typeof options.join === "function") {
        return options.join(segs);
      }
      return segs[0] + joinChar + segs[1];
    }
    function split(path, splitChar, options) {
      if (typeof options.split === "function") {
        return options.split(path);
      }
      return path.split(splitChar);
    }
    function isValid(key, target, options) {
      if (typeof options.isValid === "function") {
        return options.isValid(key, target);
      }
      return true;
    }
    function isValidObject(val) {
      return isObject(val) || Array.isArray(val) || typeof val === "function";
    }
  }
});

// node_modules/is-plain-object/index.js
var require_is_plain_object = __commonJS({
  "node_modules/is-plain-object/index.js"(exports, module2) {
    "use strict";
    var isObject = require_isobject();
    function isObjectObject(o) {
      return isObject(o) === true && Object.prototype.toString.call(o) === "[object Object]";
    }
    module2.exports = function isPlainObject(o) {
      var ctor, prot;
      if (isObjectObject(o) === false)
        return false;
      ctor = o.constructor;
      if (typeof ctor !== "function")
        return false;
      prot = ctor.prototype;
      if (isObjectObject(prot) === false)
        return false;
      if (prot.hasOwnProperty("isPrototypeOf") === false) {
        return false;
      }
      return true;
    };
  }
});

// node_modules/@budibase/handlebars-helpers/node_modules/is-extendable/index.js
var require_is_extendable = __commonJS({
  "node_modules/@budibase/handlebars-helpers/node_modules/is-extendable/index.js"(exports, module2) {
    "use strict";
    var isPlainObject = require_is_plain_object();
    module2.exports = function isExtendable(val) {
      return isPlainObject(val) || typeof val === "function" || Array.isArray(val);
    };
  }
});

// node_modules/assign-symbols/index.js
var require_assign_symbols = __commonJS({
  "node_modules/assign-symbols/index.js"(exports, module2) {
    "use strict";
    module2.exports = function(receiver, objects) {
      if (receiver === null || typeof receiver === "undefined") {
        throw new TypeError("expected first argument to be an object.");
      }
      if (typeof objects === "undefined" || typeof Symbol === "undefined") {
        return receiver;
      }
      if (typeof Object.getOwnPropertySymbols !== "function") {
        return receiver;
      }
      var isEnumerable = Object.prototype.propertyIsEnumerable;
      var target = Object(receiver);
      var len = arguments.length, i = 0;
      while (++i < len) {
        var provider = Object(arguments[i]);
        var names = Object.getOwnPropertySymbols(provider);
        for (var j = 0; j < names.length; j++) {
          var key = names[j];
          if (isEnumerable.call(provider, key)) {
            target[key] = provider[key];
          }
        }
      }
      return target;
    };
  }
});

// node_modules/@budibase/handlebars-helpers/node_modules/extend-shallow/index.js
var require_extend_shallow = __commonJS({
  "node_modules/@budibase/handlebars-helpers/node_modules/extend-shallow/index.js"(exports, module2) {
    "use strict";
    var isExtendable = require_is_extendable();
    var assignSymbols = require_assign_symbols();
    module2.exports = Object.assign || function(obj) {
      if (obj === null || typeof obj === "undefined") {
        throw new TypeError("Cannot convert undefined or null to object");
      }
      if (!isObject(obj)) {
        obj = {};
      }
      for (var i = 1; i < arguments.length; i++) {
        var val = arguments[i];
        if (isString(val)) {
          val = toObject(val);
        }
        if (isObject(val)) {
          assign(obj, val);
          assignSymbols(obj, val);
        }
      }
      return obj;
    };
    function assign(a, b) {
      for (var key in b) {
        if (hasOwn(b, key)) {
          a[key] = b[key];
        }
      }
    }
    function isString(val) {
      return val && typeof val === "string";
    }
    function toObject(str) {
      var obj = {};
      for (var i in str) {
        obj[i] = str[i];
      }
      return obj;
    }
    function isObject(val) {
      return val && typeof val === "object" || isExtendable(val);
    }
    function hasOwn(obj, key) {
      return Object.prototype.hasOwnProperty.call(obj, key);
    }
  }
});

// node_modules/@budibase/handlebars-helpers/lib/utils/createFrame.js
var require_createFrame = __commonJS({
  "node_modules/@budibase/handlebars-helpers/lib/utils/createFrame.js"(exports, module2) {
    "use strict";
    var define2 = require_define_property();
    var extend = require_extend_shallow();
    module2.exports = function createFrame(data) {
      if (typeof data !== "object") {
        throw new TypeError("createFrame expects data to be an object");
      }
      var frame = extend({}, data);
      frame._parent = data;
      define2(frame, "extend", function(data2) {
        extend(this, data2);
      });
      if (arguments.length > 1) {
        var args = [].slice.call(arguments, 1);
        var len = args.length, i = -1;
        while (++i < len) {
          frame.extend(args[i] || {});
        }
      }
      return frame;
    };
  }
});

// node_modules/@budibase/handlebars-helpers/lib/array.js
var require_array = __commonJS({
  "node_modules/@budibase/handlebars-helpers/lib/array.js"(exports, module2) {
    "use strict";
    var util = require_handlebars_utils();
    var helpers = module2.exports;
    var arraySort = require_array_sort();
    var getValue = require_get_value2();
    var createFrame = require_createFrame();
    helpers.after = function(array, n) {
      if (util.isUndefined(array))
        return "";
      array = util.result(array);
      if (Array.isArray(array)) {
        return array.slice(n);
      }
      return "";
    };
    helpers.arrayify = function(value2) {
      if (util.isUndefined(value2))
        return [];
      return value2 ? Array.isArray(value2) ? value2 : [value2] : [];
    };
    helpers.before = function(array, n) {
      if (util.isUndefined(array))
        return "";
      array = util.result(array);
      if (Array.isArray(array)) {
        return array.slice(0, -n);
      }
      return "";
    };
    helpers.eachIndex = function(array, options) {
      var result = "";
      if (util.isUndefined(array))
        return "";
      array = util.result(array);
      if (Array.isArray(array)) {
        for (var i = 0; i < array.length; i++) {
          result += options.fn({ item: array[i], index: i });
        }
      }
      return result;
    };
    helpers.filter = function(array, value2, options) {
      if (util.isUndefined(array))
        return options.inverse(this);
      array = util.result(array);
      if (Array.isArray(array)) {
        var content = "";
        var results = [];
        var prop = options.hash && (options.hash.property || options.hash.prop);
        if (prop) {
          results = array.filter(function(val) {
            return value2 === getValue(val, prop);
          });
        } else {
          results = array.filter(function(v) {
            return value2 === v;
          });
        }
        if (results && results.length > 0) {
          for (var i = 0; i < results.length; i++) {
            content += options.fn(results[i]);
          }
          return content;
        }
      }
      return options.inverse(this);
    };
    helpers.first = function(array, n) {
      if (util.isUndefined(array))
        return [];
      array = util.result(array);
      if (Array.isArray(array)) {
        if (isNaN(n)) {
          return array[0];
        }
        return array.slice(0, n);
      }
      return [];
    };
    helpers.forEach = function(array, options) {
      if (util.isUndefined(array))
        return options.inverse(this);
      array = util.result(array);
      if (Array.isArray(array)) {
        var data = createFrame(options, options.hash);
        var len = array.length;
        var buffer = "";
        var i = -1;
        while (++i < len) {
          var item = array[i];
          data.index = i;
          item.index = i + 1;
          item.total = len;
          item.isFirst = i === 0;
          item.isLast = i === len - 1;
          buffer += options.fn(item, { data });
        }
        return buffer;
      }
      return options.inverse(this);
    };
    helpers.inArray = function(array, value2, options) {
      if (util.isUndefined(array))
        return "";
      array = util.result(array);
      if (Array.isArray(array)) {
        return util.value(util.indexOf(array, value2) > -1, this, options);
      }
      return "";
    };
    helpers.isArray = function(value2) {
      return Array.isArray(value2);
    };
    helpers.itemAt = function(array, idx) {
      if (util.isUndefined(array))
        return null;
      array = util.result(array);
      if (Array.isArray(array)) {
        idx = !isNaN(idx) ? +idx : 0;
        if (idx < 0) {
          return array[array.length + idx];
        }
        if (idx < array.length) {
          return array[idx];
        }
      }
      return null;
    };
    helpers.join = function(array, separator) {
      if (util.isUndefined(array))
        return "";
      if (typeof array === "string")
        return array;
      array = util.result(array);
      if (Array.isArray(array)) {
        separator = util.isString(separator) ? separator : ", ";
        return array.join(separator);
      }
      return "";
    };
    helpers.equalsLength = function(value2, length, options) {
      if (util.isOptions(length)) {
        options = length;
        length = 0;
      }
      var len = helpers.length(value2);
      return util.value(len === length, this, options);
    };
    helpers.last = function(array, n) {
      if (util.isUndefined(array))
        return "";
      if (!Array.isArray(array) && typeof value !== "string") {
        return "";
      }
      if (isNaN(n)) {
        return array[array.length - 1];
      }
      return array.slice(-Math.abs(n));
    };
    helpers.length = function(array) {
      if (util.isUndefined(array))
        return 0;
      if (util.isObject(array) && !util.isOptions(array)) {
        array = Object.keys(array);
      }
      if (typeof array === "string" && array.startsWith("[") && array.endsWith("]")) {
        return array.split(",").length;
      }
      if (typeof array === "string" || Array.isArray(array)) {
        return array.length;
      }
      return 0;
    };
    helpers.lengthEqual = helpers.equalsLength;
    helpers.map = function(array, iter) {
      if (util.isUndefined(array))
        return "";
      if (!Array.isArray(array))
        return "";
      var len = array.length;
      var res = new Array(len);
      var i = -1;
      if (typeof iter !== "function") {
        return array;
      }
      while (++i < len) {
        res[i] = iter(array[i], i, array);
      }
      return res;
    };
    helpers.pluck = function(array, prop) {
      if (util.isUndefined(array))
        return "";
      array = util.result(array);
      if (Array.isArray(array)) {
        var res = [];
        for (var i = 0; i < array.length; i++) {
          var val = getValue(array[i], prop);
          if (typeof val !== "undefined") {
            res.push(val);
          }
        }
        return res;
      }
      return "";
    };
    helpers.reverse = function(array) {
      if (util.isUndefined(array))
        return "";
      array = util.result(array);
      if (Array.isArray(array)) {
        array.reverse();
        return array;
      }
      if (array && typeof array === "string") {
        return array.split("").reverse().join("");
      }
      return "";
    };
    helpers.some = function(array, iter, options) {
      if (util.isUndefined(array))
        return options.inverse(this);
      array = util.result(array);
      if (Array.isArray(array)) {
        for (var i = 0; i < array.length; i++) {
          if (iter(array[i], i, array)) {
            return options.fn(this);
          }
        }
      }
      return options.inverse(this);
    };
    helpers.sort = function(array, options) {
      if (util.isUndefined(array))
        return "";
      array = util.result(array);
      if (Array.isArray(array)) {
        if (getValue(options, "hash.reverse")) {
          return array.sort().reverse();
        }
        return array.sort();
      }
      return "";
    };
    helpers.sortBy = function(array, prop, options) {
      if (util.isUndefined(array))
        return "";
      array = util.result(array);
      if (Array.isArray(array)) {
        var args = [].slice.call(arguments);
        args.pop();
        if (!util.isString(prop) && typeof prop !== "function") {
          return array.sort();
        }
        return arraySort.apply(null, args);
      }
      return "";
    };
    helpers.withAfter = function(array, idx, options) {
      if (util.isUndefined(array))
        return "";
      array = util.result(array);
      if (Array.isArray(array)) {
        array = array.slice(idx);
        var result = "";
        for (var i = 0; i < array.length; i++) {
          result += options.fn(array[i]);
        }
        return result;
      }
      return "";
    };
    helpers.withBefore = function(array, idx, options) {
      if (util.isUndefined(array))
        return "";
      array = util.result(array);
      if (Array.isArray(array)) {
        array = array.slice(0, -idx);
        var result = "";
        for (var i = 0; i < array.length; i++) {
          result += options.fn(array[i]);
        }
        return result;
      }
      return "";
    };
    helpers.withFirst = function(array, idx, options) {
      if (util.isUndefined(array))
        return "";
      array = util.result(array);
      if (Array.isArray(array)) {
        if (!util.isUndefined(idx)) {
          idx = parseFloat(util.result(idx));
        }
        if (util.isUndefined(idx)) {
          options = idx;
          return options.fn(array[0]);
        }
        array = array.slice(0, idx);
        var result = "";
        for (var i = 0; i < array.length; i++) {
          result += options.fn(array[i]);
        }
        return result;
      }
      return "";
    };
    helpers.withGroup = function(array, size, options) {
      if (util.isUndefined(array))
        return "";
      var result = "";
      array = util.result(array);
      if (Array.isArray(array) && array.length > 0) {
        var subcontext = [];
        for (var i = 0; i < array.length; i++) {
          if (i > 0 && i % size === 0) {
            result += options.fn(subcontext);
            subcontext = [];
          }
          subcontext.push(array[i]);
        }
        result += options.fn(subcontext);
      }
      return result;
    };
    helpers.withLast = function(array, idx, options) {
      if (util.isUndefined(array))
        return "";
      array = util.result(array);
      if (Array.isArray(array)) {
        if (!util.isUndefined(idx)) {
          idx = parseFloat(util.result(idx));
        }
        if (util.isUndefined(idx)) {
          options = idx;
          return options.fn(array[array.length - 1]);
        }
        array = array.slice(-idx);
        var len = array.length, i = -1;
        var result = "";
        while (++i < len) {
          result += options.fn(array[i]);
        }
        return result;
      }
      return "";
    };
    helpers.withSort = function(array, prop, options) {
      if (util.isUndefined(array))
        return "";
      array = util.result(array);
      if (Array.isArray(array)) {
        var result = "";
        if (util.isUndefined(prop)) {
          options = prop;
          array = array.sort();
          if (getValue(options, "hash.reverse")) {
            array = array.reverse();
          }
          for (var i = 0, len = array.length; i < len; i++) {
            result += options.fn(array[i]);
          }
          return result;
        }
        array.sort(function(a, b) {
          a = getValue(a, prop);
          b = getValue(b, prop);
          return a > b ? 1 : a < b ? -1 : 0;
        });
        if (getValue(options, "hash.reverse")) {
          array = array.reverse();
        }
        var alen = array.length, j = -1;
        while (++j < alen) {
          result += options.fn(array[j]);
        }
        return result;
      }
      return "";
    };
    helpers.unique = function(array, options) {
      if (util.isUndefined(array))
        return "";
      array = util.result(array);
      if (Array.isArray(array)) {
        return array.filter(function(item, index, arr) {
          return arr.indexOf(item) === index;
        });
      }
      return "";
    };
  }
});

// node_modules/to-gfm-code-block/index.js
var require_to_gfm_code_block = __commonJS({
  "node_modules/to-gfm-code-block/index.js"(exports, module2) {
    "use strict";
    module2.exports = function pre(str, lang) {
      if (typeof str !== "string") {
        throw new TypeError("markdown-pre expects a string.");
      }
      var code = "";
      code += "```" + (typeof lang === "string" ? lang : "");
      code += "\n";
      code += str;
      code += "\n";
      code += "```";
      return code;
    };
  }
});

// node_modules/self-closing-tags/index.js
var require_self_closing_tags = __commonJS({
  "node_modules/self-closing-tags/index.js"(exports, module2) {
    "use strict";
    var svgElements = [
      "circle",
      "ellipse",
      "line",
      "path",
      "polygon",
      "polyline",
      "rect",
      "stop",
      "use"
    ];
    var voidElements = [
      "area",
      "base",
      "br",
      "col",
      "command",
      "embed",
      "hr",
      "img",
      "input",
      "keygen",
      "link",
      "meta",
      "param",
      "source",
      "track",
      "wbr"
    ];
    module2.exports = voidElements.concat(svgElements);
    module2.exports.voidElements = voidElements;
    module2.exports.svgElements = svgElements;
  }
});

// node_modules/is-self-closing/index.js
var require_is_self_closing = __commonJS({
  "node_modules/is-self-closing/index.js"(exports, module2) {
    "use strict";
    var tags = require_self_closing_tags();
    module2.exports = function(name) {
      if (typeof name !== "string") {
        throw new TypeError("expected name to be a string");
      }
      return tags.indexOf(name.toLowerCase()) !== -1;
    };
  }
});

// node_modules/html-tag/index.js
var require_html_tag = __commonJS({
  "node_modules/html-tag/index.js"(exports, module2) {
    "use strict";
    var typeOf = require_kind_of();
    var isVoid = require_is_self_closing();
    module2.exports = function(tag, attribs, text) {
      var voided = text === false || attribs === false;
      if (typeOf(attribs) !== "object") {
        text = attribs;
        attribs = {};
      }
      if (typeof text === "undefined" || text === false) {
        text = "";
      }
      if (typeof text !== "string") {
        throw new TypeError("expected text to be a string");
      }
      var html = "<" + tag;
      for (var key in attribs) {
        var val = attribs[key];
        if (val === true) {
          html += " " + key;
        }
        if (typeof val === "string") {
          html += " " + key + '="' + val + '"';
        }
      }
      if (isVoid(tag) || voided === true) {
        return html + ">" + text;
      }
      return html + ">" + text + "</" + tag + ">";
    };
  }
});

// node_modules/@budibase/handlebars-helpers/lib/code.js
var require_code = __commonJS({
  "node_modules/@budibase/handlebars-helpers/lib/code.js"(exports, module2) {
    "use strict";
    var fs = require("fs");
    var path = require("path");
    var codeBlock = require_to_gfm_code_block();
    var htmlTag = require_html_tag();
    var helpers = module2.exports;
    helpers.embed = function embed(filepath, ext) {
      ext = typeof ext !== "string" ? path.extname(filepath).slice(1) : ext;
      var code = fs.readFileSync(filepath, "utf8");
      if (ext === "markdown" || ext === "md") {
        ext = "markdown";
        code = code.split("`").join("&#x60");
      }
      return codeBlock(code, ext).trim() + "\n";
    };
    helpers.gist = function(id) {
      return htmlTag("script", { src: "https://gist.github.com/" + id + ".js" });
    };
    helpers.jsfiddle = function jsFiddle(options) {
      var attr = Object.assign({}, options && options.hash);
      if (typeof attr.id === "undefined") {
        throw new Error("jsfiddle helper expects an `id`");
      }
      attr.id = "http://jsfiddle.net/" + attr.id;
      attr.width = attr.width || "100%";
      attr.height = attr.height || "300";
      attr.skin = attr.skin || "/presentation/";
      attr.tabs = (attr.tabs || "result,js,html,css") + attr.skin;
      attr.src = attr.id + "/embedded/" + attr.tabs;
      attr.allowfullscreen = attr.allowfullscreen || "allowfullscreen";
      attr.frameborder = attr.frameborder || "0";
      delete attr.tabs;
      delete attr.skin;
      delete attr.id;
      return htmlTag("iframe", attr);
    };
  }
});

// node_modules/get-object/node_modules/kind-of/index.js
var require_kind_of5 = __commonJS({
  "node_modules/get-object/node_modules/kind-of/index.js"(exports, module2) {
    var isBuffer = require_is_buffer();
    var toString = Object.prototype.toString;
    module2.exports = function kindOf(val) {
      if (typeof val === "undefined") {
        return "undefined";
      }
      if (val === null) {
        return "null";
      }
      if (val === true || val === false || val instanceof Boolean) {
        return "boolean";
      }
      if (typeof val === "string" || val instanceof String) {
        return "string";
      }
      if (typeof val === "number" || val instanceof Number) {
        return "number";
      }
      if (typeof val === "function" || val instanceof Function) {
        return "function";
      }
      if (typeof Array.isArray !== "undefined" && Array.isArray(val)) {
        return "array";
      }
      if (val instanceof RegExp) {
        return "regexp";
      }
      if (val instanceof Date) {
        return "date";
      }
      var type = toString.call(val);
      if (type === "[object RegExp]") {
        return "regexp";
      }
      if (type === "[object Date]") {
        return "date";
      }
      if (type === "[object Arguments]") {
        return "arguments";
      }
      if (type === "[object Error]") {
        return "error";
      }
      if (isBuffer(val)) {
        return "buffer";
      }
      if (type === "[object Set]") {
        return "set";
      }
      if (type === "[object WeakSet]") {
        return "weakset";
      }
      if (type === "[object Map]") {
        return "map";
      }
      if (type === "[object WeakMap]") {
        return "weakmap";
      }
      if (type === "[object Symbol]") {
        return "symbol";
      }
      if (type === "[object Int8Array]") {
        return "int8array";
      }
      if (type === "[object Uint8Array]") {
        return "uint8array";
      }
      if (type === "[object Uint8ClampedArray]") {
        return "uint8clampedarray";
      }
      if (type === "[object Int16Array]") {
        return "int16array";
      }
      if (type === "[object Uint16Array]") {
        return "uint16array";
      }
      if (type === "[object Int32Array]") {
        return "int32array";
      }
      if (type === "[object Uint32Array]") {
        return "uint32array";
      }
      if (type === "[object Float32Array]") {
        return "float32array";
      }
      if (type === "[object Float64Array]") {
        return "float64array";
      }
      return "object";
    };
  }
});

// node_modules/get-object/node_modules/is-number/index.js
var require_is_number = __commonJS({
  "node_modules/get-object/node_modules/is-number/index.js"(exports, module2) {
    "use strict";
    var typeOf = require_kind_of5();
    module2.exports = function isNumber(num) {
      var type = typeOf(num);
      if (type !== "number" && type !== "string") {
        return false;
      }
      var n = +num;
      return n - n + 1 >= 0 && num !== "";
    };
  }
});

// node_modules/get-object/index.js
var require_get_object = __commonJS({
  "node_modules/get-object/index.js"(exports, module2) {
    "use strict";
    var isNumber = require_is_number();
    module2.exports = function getObject(obj, prop) {
      if (!prop)
        return obj;
      if (!obj)
        return {};
      var segs = String(prop).split(/[[.\]]/).filter(Boolean);
      var last = segs[segs.length - 1], res = {};
      while (prop = segs.shift()) {
        obj = obj[prop];
        if (!obj)
          return {};
      }
      if (isNumber(last))
        return [obj];
      res[last] = obj;
      return res;
    };
  }
});

// node_modules/@budibase/handlebars-helpers/lib/object.js
var require_object = __commonJS({
  "node_modules/@budibase/handlebars-helpers/lib/object.js"(exports, module2) {
    "use strict";
    var hasOwn = Object.hasOwnProperty;
    var util = require_handlebars_utils();
    var array = require_array();
    var helpers = module2.exports;
    var getValue = require_get_value2();
    var kindOf = require_kind_of();
    var getObject = require_get_object();
    var createFrame = require_createFrame();
    helpers.extend = function() {
      var args = [].slice.call(arguments);
      var opts = {};
      if (util.isOptions(args[args.length - 1])) {
        opts = args.pop().hash;
        args.push(opts);
      }
      var context = {};
      for (var i = 0; i < args.length; i++) {
        var obj = args[i];
        if (util.isObject(obj)) {
          var keys = Object.keys(obj);
          for (var j = 0; j < keys.length; j++) {
            var key = keys[j];
            context[key] = obj[key];
          }
        }
      }
      return context;
    };
    helpers.forIn = function(obj, options) {
      if (!util.isOptions(options)) {
        return obj.inverse(this);
      }
      var data = createFrame(options, options.hash);
      var result = "";
      for (var key in obj) {
        data.key = key;
        result += options.fn(obj[key], { data });
      }
      return result;
    };
    helpers.forOwn = function(obj, options) {
      if (!util.isOptions(options)) {
        return obj.inverse(this);
      }
      var data = createFrame(options, options.hash);
      var result = "";
      for (var key in obj) {
        if (obj.hasOwnProperty(key)) {
          data.key = key;
          result += options.fn(obj[key], { data });
        }
      }
      return result;
    };
    helpers.toPath = function() {
      var prop = [];
      for (var i = 0; i < arguments.length; i++) {
        if (typeof arguments[i] === "string" || typeof arguments[i] === "number") {
          prop.push(arguments[i]);
        }
      }
      return prop.join(".");
    };
    helpers.get = function(prop, context, options) {
      var val = getValue(context, prop);
      if (options && options.fn) {
        return val ? options.fn(val) : options.inverse(context);
      }
      return val;
    };
    helpers.getObject = function(prop, context) {
      return getObject(context, prop);
    };
    helpers.hasOwn = function(context, key) {
      return hasOwn.call(context, key);
    };
    helpers.isObject = function(value2) {
      return kindOf(value2) === "object";
    };
    helpers.JSONparse = function(str, options) {
      return JSON.parse(str);
    };
    helpers.JSONstringify = function(obj, indent) {
      if (isNaN(indent)) {
        indent = 0;
      }
      return JSON.stringify(obj, null, indent);
    };
    helpers.merge = function(context) {
      var args = [].slice.call(arguments);
      var opts = {};
      if (util.isOptions(args[args.length - 1])) {
        opts = args.pop().hash;
        args.push(opts);
      }
      return Object.assign.apply(null, args);
    };
    helpers.parseJSON = helpers.JSONparse;
    helpers.pick = function(props, context, options) {
      var keys = array.arrayify(props);
      var len = keys.length, i = -1;
      var result = {};
      while (++i < len) {
        result = helpers.extend({}, result, getObject(context, keys[i]));
      }
      if (options.fn) {
        if (Object.keys(result).length) {
          return options.fn(result);
        }
        return options.inverse(context);
      }
      return result;
    };
    helpers.stringify = helpers.JSONstringify;
  }
});

// node_modules/@budibase/handlebars-helpers/lib/collection.js
var require_collection = __commonJS({
  "node_modules/@budibase/handlebars-helpers/lib/collection.js"(exports, module2) {
    "use strict";
    var util = require_handlebars_utils();
    var object = require_object();
    var array = require_array();
    var forEach = array.forEach;
    var forOwn = object.forOwn;
    var helpers = module2.exports;
    helpers.isEmpty = function(collection, options) {
      if (!util.isOptions(options)) {
        options = collection;
        return util.fn(true, this, options);
      }
      if (Array.isArray(collection) && !collection.length) {
        return util.fn(true, this, options);
      }
      var keys = Object.keys(collection);
      var isEmpty = typeof collection === "object" && !keys.length;
      return util.value(isEmpty, this, options);
    };
    helpers.iterate = function(collection, options) {
      if (Array.isArray(collection)) {
        return forEach.apply(null, arguments);
      }
      if (util.isObject(collection)) {
        return forOwn.apply(null, arguments);
      }
      return options.inverse(this);
    };
  }
});

// node_modules/has-value/node_modules/get-value/index.js
var require_get_value3 = __commonJS({
  "node_modules/has-value/node_modules/get-value/index.js"(exports, module2) {
    var isObject = require_isobject();
    module2.exports = function(target, path, options) {
      if (!isObject(options)) {
        options = { default: options };
      }
      if (!isValidObject(target)) {
        return typeof options.default !== "undefined" ? options.default : target;
      }
      if (typeof path === "number") {
        path = String(path);
      }
      const isArray = Array.isArray(path);
      const isString = typeof path === "string";
      const splitChar = options.separator || ".";
      const joinChar = options.joinChar || (typeof splitChar === "string" ? splitChar : ".");
      if (!isString && !isArray) {
        return target;
      }
      if (isString && path in target) {
        return isValid(path, target, options) ? target[path] : options.default;
      }
      let segs = isArray ? path : split(path, splitChar, options);
      let len = segs.length;
      let idx = 0;
      do {
        let prop = segs[idx];
        if (typeof prop === "number") {
          prop = String(prop);
        }
        while (prop && prop.slice(-1) === "\\") {
          prop = join([prop.slice(0, -1), segs[++idx] || ""], joinChar, options);
        }
        if (prop in target) {
          if (!isValid(prop, target, options)) {
            return options.default;
          }
          target = target[prop];
        } else {
          let hasProp = false;
          let n = idx + 1;
          while (n < len) {
            prop = join([prop, segs[n++]], joinChar, options);
            if (hasProp = prop in target) {
              if (!isValid(prop, target, options)) {
                return options.default;
              }
              target = target[prop];
              idx = n - 1;
              break;
            }
          }
          if (!hasProp) {
            return options.default;
          }
        }
      } while (++idx < len && isValidObject(target));
      if (idx === len) {
        return target;
      }
      return options.default;
    };
    function join(segs, joinChar, options) {
      if (typeof options.join === "function") {
        return options.join(segs);
      }
      return segs[0] + joinChar + segs[1];
    }
    function split(path, splitChar, options) {
      if (typeof options.split === "function") {
        return options.split(path);
      }
      return path.split(splitChar);
    }
    function isValid(key, target, options) {
      if (typeof options.isValid === "function") {
        return options.isValid(key, target);
      }
      return true;
    }
    function isValidObject(val) {
      return isObject(val) || Array.isArray(val) || typeof val === "function";
    }
  }
});

// node_modules/has-values/index.js
var require_has_values = __commonJS({
  "node_modules/has-values/index.js"(exports, module2) {
    "use strict";
    var typeOf = require_kind_of();
    module2.exports = function has(val) {
      switch (typeOf(val)) {
        case "boolean":
        case "date":
        case "function":
        case "null":
        case "number":
          return true;
        case "undefined":
          return false;
        case "regexp":
          return val.source !== "(?:)" && val.source !== "";
        case "buffer":
          return val.toString() !== "";
        case "error":
          return val.message !== "";
        case "string":
        case "arguments":
          return val.length !== 0;
        case "file":
        case "map":
        case "set":
          return val.size !== 0;
        case "array":
        case "object":
          for (const key of Object.keys(val)) {
            if (has(val[key])) {
              return true;
            }
          }
          return false;
        default: {
          return true;
        }
      }
    };
  }
});

// node_modules/has-value/index.js
var require_has_value = __commonJS({
  "node_modules/has-value/index.js"(exports, module2) {
    "use strict";
    var get = require_get_value3();
    var has = require_has_values();
    module2.exports = function(obj, path, options) {
      if (isObject(obj) && (typeof path === "string" || Array.isArray(path))) {
        return has(get(obj, path, options));
      }
      return false;
    };
    function isObject(val) {
      return val != null && (typeof val === "object" || typeof val === "function" || Array.isArray(val));
    }
  }
});

// node_modules/@budibase/handlebars-helpers/lib/utils/index.js
var require_utils2 = __commonJS({
  "node_modules/@budibase/handlebars-helpers/lib/utils/index.js"(exports) {
    "use strict";
    var util = require_handlebars_utils();
    exports.contains = function(val, obj, start) {
      if (val == null || obj == null || isNaN(val.length)) {
        return false;
      }
      return val.indexOf(obj, start) !== -1;
    };
    exports.chop = function(str) {
      if (typeof str !== "string")
        return "";
      var re = /^[-_.\W\s]+|[-_.\W\s]+$/g;
      return str.trim().replace(re, "");
    };
    exports.changecase = function(str, fn) {
      if (typeof str !== "string")
        return "";
      if (str.length === 1) {
        return str.toLowerCase();
      }
      str = exports.chop(str).toLowerCase();
      if (typeof fn !== "function") {
        fn = util.identity;
      }
      var re = /[-_.\W\s]+(\w|$)/g;
      return str.replace(re, function(_, ch) {
        return fn(ch);
      });
    };
    exports.random = function(min, max) {
      return min + Math.floor(Math.random() * (max - min + 1));
    };
  }
});

// node_modules/@budibase/handlebars-helpers/lib/utils/falsey.js
var require_falsey = __commonJS({
  "node_modules/@budibase/handlebars-helpers/lib/utils/falsey.js"(exports, module2) {
    "use strict";
    function falsey(val, keywords) {
      if (!val)
        return true;
      let words = keywords || falsey.keywords;
      if (!Array.isArray(words))
        words = [words];
      const lower = typeof val === "string" ? val.toLowerCase() : null;
      for (const word of words) {
        if (word === val) {
          return true;
        }
        if (word === lower) {
          return true;
        }
      }
      return false;
    }
    falsey.keywords = [
      "0",
      "false",
      "nada",
      "nil",
      "nay",
      "nah",
      "negative",
      "no",
      "none",
      "nope",
      "nul",
      "null",
      "nix",
      "nyet",
      "uh-uh",
      "veto",
      "zero"
    ];
    module2.exports = falsey;
  }
});

// node_modules/@budibase/handlebars-helpers/lib/utils/odd.js
var require_odd = __commonJS({
  "node_modules/@budibase/handlebars-helpers/lib/utils/odd.js"(exports, module2) {
    "use strict";
    module2.exports = function isOdd(value2) {
      const n = Math.abs(value2);
      if (isNaN(n)) {
        throw new TypeError("expected a number");
      }
      if (!Number.isInteger(n)) {
        throw new Error("expected an integer");
      }
      if (!Number.isSafeInteger(n)) {
        throw new Error("value exceeds maximum safe integer");
      }
      return n % 2 === 1;
    };
  }
});

// node_modules/@budibase/handlebars-helpers/lib/comparison.js
var require_comparison = __commonJS({
  "node_modules/@budibase/handlebars-helpers/lib/comparison.js"(exports, module2) {
    "use strict";
    var has = require_has_value();
    var util = require_handlebars_utils();
    var utils = require_utils2();
    var falsey = require_falsey();
    var isOdd = require_odd();
    var helpers = module2.exports;
    helpers.and = function() {
      var len = arguments.length - 1;
      var options = arguments[len];
      var val = true;
      for (var i = 0; i < len; i++) {
        if (!arguments[i]) {
          val = false;
          break;
        }
      }
      return util.value(val, this, options);
    };
    helpers.compare = function(a, operator, b, options) {
      if (arguments.length < 4) {
        throw new Error("handlebars Helper {{compare}} expects 4 arguments");
      }
      var result;
      switch (operator) {
        case "==":
          result = a == b;
          break;
        case "===":
          result = a === b;
          break;
        case "!=":
          result = a != b;
          break;
        case "!==":
          result = a !== b;
          break;
        case "<":
          result = a < b;
          break;
        case ">":
          result = a > b;
          break;
        case "<=":
          result = a <= b;
          break;
        case ">=":
          result = a >= b;
          break;
        case "typeof":
          result = typeof a === b;
          break;
        default: {
          throw new Error("helper {{compare}}: invalid operator: `" + operator + "`");
        }
      }
      return util.value(result, this, options);
    };
    helpers.contains = function(collection, value2, startIndex, options) {
      if (typeof startIndex === "object") {
        options = startIndex;
        startIndex = void 0;
      }
      var val = utils.contains(collection, value2, startIndex);
      return util.value(val, this, options);
    };
    helpers.default = function() {
      for (var i = 0; i < arguments.length - 1; i++) {
        if (arguments[i] != null)
          return arguments[i];
      }
      return "";
    };
    helpers.eq = function(a, b, options) {
      if (arguments.length === 2) {
        options = b;
        b = options.hash.compare;
      }
      return util.value(a === b, this, options);
    };
    helpers.gt = function(a, b, options) {
      if (arguments.length === 2) {
        options = b;
        b = options.hash.compare;
      }
      return util.value(a > b, this, options);
    };
    helpers.gte = function(a, b, options) {
      if (arguments.length === 2) {
        options = b;
        b = options.hash.compare;
      }
      return util.value(a >= b, this, options);
    };
    helpers.has = function(value2, pattern, options) {
      if (util.isOptions(value2)) {
        options = value2;
        pattern = null;
        value2 = null;
      }
      if (util.isOptions(pattern)) {
        options = pattern;
        pattern = null;
      }
      if (value2 === null) {
        return util.value(false, this, options);
      }
      if (arguments.length === 2) {
        return util.value(has(this, value2), this, options);
      }
      if ((Array.isArray(value2) || util.isString(value2)) && util.isString(pattern)) {
        if (value2.indexOf(pattern) > -1) {
          return util.fn(true, this, options);
        }
      }
      if (util.isObject(value2) && util.isString(pattern) && pattern in value2) {
        return util.fn(true, this, options);
      }
      return util.inverse(false, this, options);
    };
    helpers.isFalsey = function(val, options) {
      return util.value(falsey(val), this, options);
    };
    helpers.isTruthy = function(val, options) {
      return util.value(!falsey(val), this, options);
    };
    helpers.ifEven = function(num, options) {
      return util.value(!isOdd(num), this, options);
    };
    helpers.ifNth = function(a, b, options) {
      var isNth = !isNaN(a) && !isNaN(b) && b % a === 0;
      return util.value(isNth, this, options);
    };
    helpers.ifOdd = function(val, options) {
      return util.value(isOdd(val), this, options);
    };
    helpers.is = function(a, b, options) {
      if (arguments.length === 2) {
        options = b;
        b = options.hash.compare;
      }
      return util.value(a == b, this, options);
    };
    helpers.isnt = function(a, b, options) {
      if (arguments.length === 2) {
        options = b;
        b = options.hash.compare;
      }
      return util.value(a != b, this, options);
    };
    helpers.lt = function(a, b, options) {
      if (arguments.length === 2) {
        options = b;
        b = options.hash.compare;
      }
      return util.value(a < b, this, options);
    };
    helpers.lte = function(a, b, options) {
      if (arguments.length === 2) {
        options = b;
        b = options.hash.compare;
      }
      return util.value(a <= b, this, options);
    };
    helpers.neither = function(a, b, options) {
      return util.value(!a && !b, this, options);
    };
    helpers.not = function(val, options) {
      return util.value(!val, this, options);
    };
    helpers.or = function() {
      var len = arguments.length - 1;
      var options = arguments[len];
      var val = false;
      for (var i = 0; i < len; i++) {
        if (arguments[i]) {
          val = true;
          break;
        }
      }
      return util.value(val, this, options);
    };
    helpers.unlessEq = function(a, b, options) {
      if (util.isOptions(b)) {
        options = b;
        b = options.hash.compare;
      }
      return util.value(a !== b, this, options);
    };
    helpers.unlessGt = function(a, b, options) {
      if (util.isOptions(b)) {
        options = b;
        b = options.hash.compare;
      }
      return util.value(a <= b, this, options);
    };
    helpers.unlessLt = function(a, b, options) {
      if (util.isOptions(b)) {
        options = b;
        b = options.hash.compare;
      }
      return util.value(a >= b, this, options);
    };
    helpers.unlessGteq = function(a, b, options) {
      if (util.isOptions(b)) {
        options = b;
        b = options.hash.compare;
      }
      return util.value(a < b, this, options);
    };
    helpers.unlessLteq = function(a, b, options) {
      if (util.isOptions(b)) {
        options = b;
        b = options.hash.compare;
      }
      return util.value(a > b, this, options);
    };
  }
});

// node_modules/striptags/src/striptags.js
var require_striptags = __commonJS({
  "node_modules/striptags/src/striptags.js"(exports, module2) {
    "use strict";
    (function(global2) {
      if (typeof Symbol2 !== "function") {
        var Symbol2 = function(name) {
          return name;
        };
        Symbol2.nonNative = true;
      }
      const STATE_PLAINTEXT = Symbol2("plaintext");
      const STATE_HTML = Symbol2("html");
      const STATE_COMMENT = Symbol2("comment");
      const ALLOWED_TAGS_REGEX = /<(\w*)>/g;
      const NORMALIZE_TAG_REGEX = /<\/?([^\s\/>]+)/;
      function striptags(html, allowable_tags, tag_replacement) {
        html = html || "";
        allowable_tags = allowable_tags || [];
        tag_replacement = tag_replacement || "";
        let context = init_context(allowable_tags, tag_replacement);
        return striptags_internal(html, context);
      }
      function init_striptags_stream(allowable_tags, tag_replacement) {
        allowable_tags = allowable_tags || [];
        tag_replacement = tag_replacement || "";
        let context = init_context(allowable_tags, tag_replacement);
        return function striptags_stream(html) {
          return striptags_internal(html || "", context);
        };
      }
      striptags.init_streaming_mode = init_striptags_stream;
      function init_context(allowable_tags, tag_replacement) {
        allowable_tags = parse_allowable_tags(allowable_tags);
        return {
          allowable_tags,
          tag_replacement,
          state: STATE_PLAINTEXT,
          tag_buffer: "",
          depth: 0,
          in_quote_char: ""
        };
      }
      function striptags_internal(html, context) {
        if (typeof html != "string") {
          throw new TypeError("'html' parameter must be a string");
        }
        let allowable_tags = context.allowable_tags;
        let tag_replacement = context.tag_replacement;
        let state = context.state;
        let tag_buffer = context.tag_buffer;
        let depth = context.depth;
        let in_quote_char = context.in_quote_char;
        let output = "";
        for (let idx = 0, length = html.length; idx < length; idx++) {
          let char = html[idx];
          if (state === STATE_PLAINTEXT) {
            switch (char) {
              case "<":
                state = STATE_HTML;
                tag_buffer += char;
                break;
              default:
                output += char;
                break;
            }
          } else if (state === STATE_HTML) {
            switch (char) {
              case "<":
                if (in_quote_char) {
                  break;
                }
                depth++;
                break;
              case ">":
                if (in_quote_char) {
                  break;
                }
                if (depth) {
                  depth--;
                  break;
                }
                in_quote_char = "";
                state = STATE_PLAINTEXT;
                tag_buffer += ">";
                if (allowable_tags.has(normalize_tag(tag_buffer))) {
                  output += tag_buffer;
                } else {
                  output += tag_replacement;
                }
                tag_buffer = "";
                break;
              case '"':
              case "'":
                if (char === in_quote_char) {
                  in_quote_char = "";
                } else {
                  in_quote_char = in_quote_char || char;
                }
                tag_buffer += char;
                break;
              case "-":
                if (tag_buffer === "<!-") {
                  state = STATE_COMMENT;
                }
                tag_buffer += char;
                break;
              case " ":
              case "\n":
                if (tag_buffer === "<") {
                  state = STATE_PLAINTEXT;
                  output += "< ";
                  tag_buffer = "";
                  break;
                }
                tag_buffer += char;
                break;
              default:
                tag_buffer += char;
                break;
            }
          } else if (state === STATE_COMMENT) {
            switch (char) {
              case ">":
                if (tag_buffer.slice(-2) == "--") {
                  state = STATE_PLAINTEXT;
                }
                tag_buffer = "";
                break;
              default:
                tag_buffer += char;
                break;
            }
          }
        }
        context.state = state;
        context.tag_buffer = tag_buffer;
        context.depth = depth;
        context.in_quote_char = in_quote_char;
        return output;
      }
      function parse_allowable_tags(allowable_tags) {
        let tag_set = new Set();
        if (typeof allowable_tags === "string") {
          let match;
          while (match = ALLOWED_TAGS_REGEX.exec(allowable_tags)) {
            tag_set.add(match[1]);
          }
        } else if (!Symbol2.nonNative && typeof allowable_tags[Symbol2.iterator] === "function") {
          tag_set = new Set(allowable_tags);
        } else if (typeof allowable_tags.forEach === "function") {
          allowable_tags.forEach(tag_set.add, tag_set);
        }
        return tag_set;
      }
      function normalize_tag(tag_buffer) {
        let match = NORMALIZE_TAG_REGEX.exec(tag_buffer);
        return match ? match[1].toLowerCase() : null;
      }
      if (typeof define === "function" && define.amd) {
        define(function module_factory() {
          return striptags;
        });
      } else if (typeof module2 === "object" && module2.exports) {
        module2.exports = striptags;
      } else {
        global2.striptags = striptags;
      }
    })(exports);
  }
});

// node_modules/@budibase/handlebars-helpers/lib/utils/html.js
var require_html = __commonJS({
  "node_modules/@budibase/handlebars-helpers/lib/utils/html.js"(exports, module2) {
    "use strict";
    var util = require_handlebars_utils();
    var striptags = require_striptags();
    var html = module2.exports;
    html.condense = function(str) {
      return str.replace(/(\r\n|\r|\n|\u2028|\u2029) {2,}/g, "\n");
    };
    html.padcomments = function(str) {
      return str.replace(/(\s*<!--)/g, "\n$1");
    };
    html.parseAttributes = function parseAttributes(hash) {
      return Object.keys(hash).map(function(key) {
        var val = String(hash[key]).replace(/^['"]|["']$/g, "");
        return key + '="' + val + '"';
      }).join(" ");
    };
    html.sanitize = function(str) {
      if (!util.isString(str))
        return "";
      return striptags(str).trim();
    };
    html.toAttributes = function toAttributes(hash) {
      var res = "";
      var keys = Object.keys(hash);
      for (var i = 0; i < keys.length; i++) {
        var val = hash[keys[i]];
        if (val === true) {
          res += " " + keys[i];
        } else {
          res += " " + keys[i] + '="' + String(val) + '"';
        }
      }
      return res;
    };
  }
});

// node_modules/@budibase/handlebars-helpers/lib/html.js
var require_html2 = __commonJS({
  "node_modules/@budibase/handlebars-helpers/lib/html.js"(exports, module2) {
    "use strict";
    var path = require("path");
    var util = require_handlebars_utils();
    var html = require_html();
    var parseAttr = html.parseAttributes;
    var helpers = module2.exports;
    var kindOf = require_kind_of();
    var htmlTag = require_html_tag();
    helpers.attr = function(options) {
      var val = parseAttr(options && options.hash || {});
      return val.trim() ? " " + val : "";
    };
    helpers.css = function(list, options) {
      if (arguments.length < 2) {
        options = list;
        list = [];
      }
      var styles = util.arrayify(list);
      var assets = "";
      if (this && this.options) {
        assets = this.options.assets || "";
      }
      if (options.hash.href) {
        styles = util.arrayify(options.hash.href);
      }
      return styles.map(function(item) {
        var ext = path.extname(item);
        var fp = item;
        if (!/(^\/\/)|(:\/\/)/.test(item)) {
          fp = path.posix.join(assets, item);
        }
        if (ext === ".less") {
          return `<link type="text/css" rel="stylesheet/less" href="${fp}">`;
        }
        return `<link type="text/css" rel="stylesheet" href="${fp}">`;
      }).join("\n");
    };
    helpers.js = function(context) {
      if (kindOf(context) === "object") {
        var attr = parseAttr(context.hash);
        return `<script${attr ? " " + attr : ""}><\/script>`;
      }
      if (kindOf(context) === "string") {
        return `<script src="${context}"><\/script>`;
      }
      context = util.arrayify(context);
      return context.map(function(fp) {
        return path.extname(fp) === ".coffee" ? htmlTag("script", { type: "text/coffeescript", src: fp }) : htmlTag("script", { src: fp });
      }).join("\n");
    };
    helpers.sanitize = function(str) {
      return html.sanitize(str);
    };
    helpers.ul = function(context, options) {
      return "<ul " + parseAttr(options.hash) + ">" + context.map(function(item) {
        if (typeof item !== "string") {
          item = options.fn(item);
        }
        return "<li>" + item + "</li>";
      }).join("\n") + "</ul>";
    };
    helpers.ol = function(context, options) {
      return "<ol " + parseAttr(options.hash) + ">" + context.map(function(item) {
        if (typeof item !== "string") {
          item = options.fn(item);
        }
        return "<li>" + item + "</li>";
      }).join("\n") + "</ol>";
    };
    helpers.thumbnailImage = function(context) {
      var figure = "";
      var image = "";
      var link = context.full || false;
      var imageAttributes = {
        alt: context.alt,
        src: context.thumbnail,
        width: context.size.width,
        height: context.size.height
      };
      var figureAttributes = { id: "image-" + context.id };
      var linkAttributes = { href: link, rel: "thumbnail" };
      if (context.classes) {
        if (context.classes.image) {
          imageAttributes.class = context.classes.image.join(" ");
        }
        if (context.classes.figure) {
          figureAttributes.class = context.classes.figure.join(" ");
        }
        if (context.classes.link) {
          linkAttributes.class = context.classes.link.join(" ");
        }
      }
      figure += "<figure " + parseAttr(figureAttributes) + ">\n";
      image += "<img " + parseAttr(imageAttributes) + ">\n";
      if (link) {
        figure += "<a " + parseAttr(linkAttributes) + ">\n" + image + "</a>\n";
      } else {
        figure += image;
      }
      if (context.caption) {
        figure += "<figcaption>" + context.caption + "</figcaption>\n";
      }
      figure += "</figure>";
      return figure;
    };
  }
});

// node_modules/@budibase/handlebars-helpers/lib/i18n.js
var require_i18n = __commonJS({
  "node_modules/@budibase/handlebars-helpers/lib/i18n.js"(exports, module2) {
    "use strict";
    var util = require_handlebars_utils();
    var helpers = module2.exports;
    var getValue = require_get_value2();
    helpers.i18n = function(prop, locals, options) {
      if (util.isOptions(locals)) {
        options = locals;
        locals = {};
      }
      if (!util.isString(prop)) {
        throw new Error('{{i18n}} helper expected "key" to be a string');
      }
      var opts = util.options(this, locals, options);
      var context = Object.assign({}, this, opts);
      var lang = context.language || context.lang;
      if (typeof lang !== "string") {
        throw new TypeError('{{i18n}} helper expected "language" to be a string');
      }
      var cache = context[lang];
      if (typeof cache === "undefined") {
        throw new Error('{{i18n}} helper cannot find language "' + lang + '"');
      }
      var result = getValue(cache, prop);
      if (typeof result === "undefined") {
        throw new Error('{{i18n}} helper cannot find property "' + prop + '" for language "' + lang + '"');
      }
      return result;
    };
  }
});

// node_modules/@budibase/handlebars-helpers/lib/inflection.js
var require_inflection = __commonJS({
  "node_modules/@budibase/handlebars-helpers/lib/inflection.js"(exports, module2) {
    "use strict";
    var util = require_handlebars_utils();
    var helpers = module2.exports;
    helpers.inflect = function(count, singular, plural, includeCount) {
      var word = count > 1 || count === 0 ? plural : singular;
      if (includeCount === true) {
        return String(count) + " " + word;
      } else {
        return word;
      }
    };
    helpers.ordinalize = function(val) {
      var num = Math.abs(Math.round(val));
      var str = String(val);
      var res = num % 100;
      if (util.indexOf([11, 12, 13], res) >= 0) {
        return str + "th";
      }
      switch (num % 10) {
        case 1:
          return str + "st";
        case 2:
          return str + "nd";
        case 3:
          return str + "rd";
        default: {
          return str + "th";
        }
      }
    };
  }
});

// node_modules/ret/lib/types.js
var require_types = __commonJS({
  "node_modules/ret/lib/types.js"(exports, module2) {
    module2.exports = {
      ROOT: 0,
      GROUP: 1,
      POSITION: 2,
      SET: 3,
      RANGE: 4,
      REPETITION: 5,
      REFERENCE: 6,
      CHAR: 7
    };
  }
});

// node_modules/ret/lib/sets.js
var require_sets = __commonJS({
  "node_modules/ret/lib/sets.js"(exports) {
    var types = require_types();
    var INTS = function() {
      return [{ type: types.RANGE, from: 48, to: 57 }];
    };
    var WORDS = function() {
      return [
        { type: types.CHAR, value: 95 },
        { type: types.RANGE, from: 97, to: 122 },
        { type: types.RANGE, from: 65, to: 90 }
      ].concat(INTS());
    };
    var WHITESPACE = function() {
      return [
        { type: types.CHAR, value: 9 },
        { type: types.CHAR, value: 10 },
        { type: types.CHAR, value: 11 },
        { type: types.CHAR, value: 12 },
        { type: types.CHAR, value: 13 },
        { type: types.CHAR, value: 32 },
        { type: types.CHAR, value: 160 },
        { type: types.CHAR, value: 5760 },
        { type: types.CHAR, value: 6158 },
        { type: types.CHAR, value: 8192 },
        { type: types.CHAR, value: 8193 },
        { type: types.CHAR, value: 8194 },
        { type: types.CHAR, value: 8195 },
        { type: types.CHAR, value: 8196 },
        { type: types.CHAR, value: 8197 },
        { type: types.CHAR, value: 8198 },
        { type: types.CHAR, value: 8199 },
        { type: types.CHAR, value: 8200 },
        { type: types.CHAR, value: 8201 },
        { type: types.CHAR, value: 8202 },
        { type: types.CHAR, value: 8232 },
        { type: types.CHAR, value: 8233 },
        { type: types.CHAR, value: 8239 },
        { type: types.CHAR, value: 8287 },
        { type: types.CHAR, value: 12288 },
        { type: types.CHAR, value: 65279 }
      ];
    };
    var NOTANYCHAR = function() {
      return [
        { type: types.CHAR, value: 10 },
        { type: types.CHAR, value: 13 },
        { type: types.CHAR, value: 8232 },
        { type: types.CHAR, value: 8233 }
      ];
    };
    exports.words = function() {
      return { type: types.SET, set: WORDS(), not: false };
    };
    exports.notWords = function() {
      return { type: types.SET, set: WORDS(), not: true };
    };
    exports.ints = function() {
      return { type: types.SET, set: INTS(), not: false };
    };
    exports.notInts = function() {
      return { type: types.SET, set: INTS(), not: true };
    };
    exports.whitespace = function() {
      return { type: types.SET, set: WHITESPACE(), not: false };
    };
    exports.notWhitespace = function() {
      return { type: types.SET, set: WHITESPACE(), not: true };
    };
    exports.anyChar = function() {
      return { type: types.SET, set: NOTANYCHAR(), not: true };
    };
  }
});

// node_modules/ret/lib/util.js
var require_util2 = __commonJS({
  "node_modules/ret/lib/util.js"(exports) {
    var types = require_types();
    var sets = require_sets();
    var CTRL = "@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^ ?";
    var SLSH = { "0": 0, "t": 9, "n": 10, "v": 11, "f": 12, "r": 13 };
    exports.strToChars = function(str) {
      var chars_regex = /(\[\\b\])|(\\)?\\(?:u([A-F0-9]{4})|x([A-F0-9]{2})|(0?[0-7]{2})|c([@A-Z\[\\\]\^?])|([0tnvfr]))/g;
      str = str.replace(chars_regex, function(s, b, lbs, a16, b16, c8, dctrl, eslsh) {
        if (lbs) {
          return s;
        }
        var code = b ? 8 : a16 ? parseInt(a16, 16) : b16 ? parseInt(b16, 16) : c8 ? parseInt(c8, 8) : dctrl ? CTRL.indexOf(dctrl) : SLSH[eslsh];
        var c = String.fromCharCode(code);
        if (/[\[\]{}\^$.|?*+()]/.test(c)) {
          c = "\\" + c;
        }
        return c;
      });
      return str;
    };
    exports.tokenizeClass = function(str, regexpStr) {
      var tokens = [];
      var regexp = /\\(?:(w)|(d)|(s)|(W)|(D)|(S))|((?:(?:\\)(.)|([^\]\\]))-(?:\\)?([^\]]))|(\])|(?:\\)?(.)/g;
      var rs, c;
      while ((rs = regexp.exec(str)) != null) {
        if (rs[1]) {
          tokens.push(sets.words());
        } else if (rs[2]) {
          tokens.push(sets.ints());
        } else if (rs[3]) {
          tokens.push(sets.whitespace());
        } else if (rs[4]) {
          tokens.push(sets.notWords());
        } else if (rs[5]) {
          tokens.push(sets.notInts());
        } else if (rs[6]) {
          tokens.push(sets.notWhitespace());
        } else if (rs[7]) {
          tokens.push({
            type: types.RANGE,
            from: (rs[8] || rs[9]).charCodeAt(0),
            to: rs[10].charCodeAt(0)
          });
        } else if (c = rs[12]) {
          tokens.push({
            type: types.CHAR,
            value: c.charCodeAt(0)
          });
        } else {
          return [tokens, regexp.lastIndex];
        }
      }
      exports.error(regexpStr, "Unterminated character class");
    };
    exports.error = function(regexp, msg) {
      throw new SyntaxError("Invalid regular expression: /" + regexp + "/: " + msg);
    };
  }
});

// node_modules/ret/lib/positions.js
var require_positions = __commonJS({
  "node_modules/ret/lib/positions.js"(exports) {
    var types = require_types();
    exports.wordBoundary = function() {
      return { type: types.POSITION, value: "b" };
    };
    exports.nonWordBoundary = function() {
      return { type: types.POSITION, value: "B" };
    };
    exports.begin = function() {
      return { type: types.POSITION, value: "^" };
    };
    exports.end = function() {
      return { type: types.POSITION, value: "$" };
    };
  }
});

// node_modules/ret/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/ret/lib/index.js"(exports, module2) {
    var util = require_util2();
    var types = require_types();
    var sets = require_sets();
    var positions = require_positions();
    module2.exports = function(regexpStr) {
      var i = 0, l, c, start = { type: types.ROOT, stack: [] }, lastGroup = start, last = start.stack, groupStack = [];
      var repeatErr = function(i2) {
        util.error(regexpStr, "Nothing to repeat at column " + (i2 - 1));
      };
      var str = util.strToChars(regexpStr);
      l = str.length;
      while (i < l) {
        c = str[i++];
        switch (c) {
          case "\\":
            c = str[i++];
            switch (c) {
              case "b":
                last.push(positions.wordBoundary());
                break;
              case "B":
                last.push(positions.nonWordBoundary());
                break;
              case "w":
                last.push(sets.words());
                break;
              case "W":
                last.push(sets.notWords());
                break;
              case "d":
                last.push(sets.ints());
                break;
              case "D":
                last.push(sets.notInts());
                break;
              case "s":
                last.push(sets.whitespace());
                break;
              case "S":
                last.push(sets.notWhitespace());
                break;
              default:
                if (/\d/.test(c)) {
                  last.push({ type: types.REFERENCE, value: parseInt(c, 10) });
                } else {
                  last.push({ type: types.CHAR, value: c.charCodeAt(0) });
                }
            }
            break;
          case "^":
            last.push(positions.begin());
            break;
          case "$":
            last.push(positions.end());
            break;
          case "[":
            var not;
            if (str[i] === "^") {
              not = true;
              i++;
            } else {
              not = false;
            }
            var classTokens = util.tokenizeClass(str.slice(i), regexpStr);
            i += classTokens[1];
            last.push({
              type: types.SET,
              set: classTokens[0],
              not
            });
            break;
          case ".":
            last.push(sets.anyChar());
            break;
          case "(":
            var group = {
              type: types.GROUP,
              stack: [],
              remember: true
            };
            c = str[i];
            if (c === "?") {
              c = str[i + 1];
              i += 2;
              if (c === "=") {
                group.followedBy = true;
              } else if (c === "!") {
                group.notFollowedBy = true;
              } else if (c !== ":") {
                util.error(regexpStr, "Invalid group, character '" + c + "' after '?' at column " + (i - 1));
              }
              group.remember = false;
            }
            last.push(group);
            groupStack.push(lastGroup);
            lastGroup = group;
            last = group.stack;
            break;
          case ")":
            if (groupStack.length === 0) {
              util.error(regexpStr, "Unmatched ) at column " + (i - 1));
            }
            lastGroup = groupStack.pop();
            last = lastGroup.options ? lastGroup.options[lastGroup.options.length - 1] : lastGroup.stack;
            break;
          case "|":
            if (!lastGroup.options) {
              lastGroup.options = [lastGroup.stack];
              delete lastGroup.stack;
            }
            var stack = [];
            lastGroup.options.push(stack);
            last = stack;
            break;
          case "{":
            var rs = /^(\d+)(,(\d+)?)?\}/.exec(str.slice(i)), min, max;
            if (rs !== null) {
              if (last.length === 0) {
                repeatErr(i);
              }
              min = parseInt(rs[1], 10);
              max = rs[2] ? rs[3] ? parseInt(rs[3], 10) : Infinity : min;
              i += rs[0].length;
              last.push({
                type: types.REPETITION,
                min,
                max,
                value: last.pop()
              });
            } else {
              last.push({
                type: types.CHAR,
                value: 123
              });
            }
            break;
          case "?":
            if (last.length === 0) {
              repeatErr(i);
            }
            last.push({
              type: types.REPETITION,
              min: 0,
              max: 1,
              value: last.pop()
            });
            break;
          case "+":
            if (last.length === 0) {
              repeatErr(i);
            }
            last.push({
              type: types.REPETITION,
              min: 1,
              max: Infinity,
              value: last.pop()
            });
            break;
          case "*":
            if (last.length === 0) {
              repeatErr(i);
            }
            last.push({
              type: types.REPETITION,
              min: 0,
              max: Infinity,
              value: last.pop()
            });
            break;
          default:
            last.push({
              type: types.CHAR,
              value: c.charCodeAt(0)
            });
        }
      }
      if (groupStack.length !== 0) {
        util.error(regexpStr, "Unterminated group");
      }
      return start;
    };
    module2.exports.types = types;
  }
});

// node_modules/safe-regex/index.js
var require_safe_regex = __commonJS({
  "node_modules/safe-regex/index.js"(exports, module2) {
    var parse = require_lib2();
    var types = parse.types;
    module2.exports = function(re, opts) {
      if (!opts)
        opts = {};
      var replimit = opts.limit === void 0 ? 25 : opts.limit;
      if (isRegExp(re))
        re = re.source;
      else if (typeof re !== "string")
        re = String(re);
      try {
        re = parse(re);
      } catch (err) {
        return false;
      }
      var reps = 0;
      return function walk(node, starHeight) {
        if (node.type === types.REPETITION) {
          starHeight++;
          reps++;
          if (starHeight > 1)
            return false;
          if (reps > replimit)
            return false;
        }
        if (node.options) {
          for (var i = 0, len = node.options.length; i < len; i++) {
            var ok = walk({ stack: node.options[i] }, starHeight);
            if (!ok)
              return false;
          }
        }
        var stack = node.stack || node.value && node.value.stack;
        if (!stack)
          return true;
        for (var i = 0; i < stack.length; i++) {
          var ok = walk(stack[i], starHeight);
          if (!ok)
            return false;
        }
        return true;
      }(re, 0);
    };
    function isRegExp(x) {
      return {}.toString.call(x) === "[object RegExp]";
    }
  }
});

// node_modules/to-regex/node_modules/define-property/index.js
var require_define_property2 = __commonJS({
  "node_modules/to-regex/node_modules/define-property/index.js"(exports, module2) {
    "use strict";
    var isobject = require_isobject();
    var isDescriptor = require_is_descriptor();
    var define2 = typeof Reflect !== "undefined" && Reflect.defineProperty ? Reflect.defineProperty : Object.defineProperty;
    module2.exports = function defineProperty(obj, key, val) {
      if (!isobject(obj) && typeof obj !== "function" && !Array.isArray(obj)) {
        throw new TypeError("expected an object, function, or array");
      }
      if (typeof key !== "string") {
        throw new TypeError('expected "key" to be a string');
      }
      if (isDescriptor(val)) {
        define2(obj, key, val);
        return obj;
      }
      define2(obj, key, {
        configurable: true,
        enumerable: false,
        writable: true,
        value: val
      });
      return obj;
    };
  }
});

// node_modules/to-regex/node_modules/is-extendable/index.js
var require_is_extendable2 = __commonJS({
  "node_modules/to-regex/node_modules/is-extendable/index.js"(exports, module2) {
    "use strict";
    var isPlainObject = require_is_plain_object();
    module2.exports = function isExtendable(val) {
      return isPlainObject(val) || typeof val === "function" || Array.isArray(val);
    };
  }
});

// node_modules/to-regex/node_modules/extend-shallow/index.js
var require_extend_shallow2 = __commonJS({
  "node_modules/to-regex/node_modules/extend-shallow/index.js"(exports, module2) {
    "use strict";
    var isExtendable = require_is_extendable2();
    var assignSymbols = require_assign_symbols();
    module2.exports = Object.assign || function(obj) {
      if (obj === null || typeof obj === "undefined") {
        throw new TypeError("Cannot convert undefined or null to object");
      }
      if (!isObject(obj)) {
        obj = {};
      }
      for (var i = 1; i < arguments.length; i++) {
        var val = arguments[i];
        if (isString(val)) {
          val = toObject(val);
        }
        if (isObject(val)) {
          assign(obj, val);
          assignSymbols(obj, val);
        }
      }
      return obj;
    };
    function assign(a, b) {
      for (var key in b) {
        if (hasOwn(b, key)) {
          a[key] = b[key];
        }
      }
    }
    function isString(val) {
      return val && typeof val === "string";
    }
    function toObject(str) {
      var obj = {};
      for (var i in str) {
        obj[i] = str[i];
      }
      return obj;
    }
    function isObject(val) {
      return val && typeof val === "object" || isExtendable(val);
    }
    function hasOwn(obj, key) {
      return Object.prototype.hasOwnProperty.call(obj, key);
    }
  }
});

// node_modules/regex-not/node_modules/is-extendable/index.js
var require_is_extendable3 = __commonJS({
  "node_modules/regex-not/node_modules/is-extendable/index.js"(exports, module2) {
    "use strict";
    var isPlainObject = require_is_plain_object();
    module2.exports = function isExtendable(val) {
      return isPlainObject(val) || typeof val === "function" || Array.isArray(val);
    };
  }
});

// node_modules/regex-not/node_modules/extend-shallow/index.js
var require_extend_shallow3 = __commonJS({
  "node_modules/regex-not/node_modules/extend-shallow/index.js"(exports, module2) {
    "use strict";
    var isExtendable = require_is_extendable3();
    var assignSymbols = require_assign_symbols();
    module2.exports = Object.assign || function(obj) {
      if (obj === null || typeof obj === "undefined") {
        throw new TypeError("Cannot convert undefined or null to object");
      }
      if (!isObject(obj)) {
        obj = {};
      }
      for (var i = 1; i < arguments.length; i++) {
        var val = arguments[i];
        if (isString(val)) {
          val = toObject(val);
        }
        if (isObject(val)) {
          assign(obj, val);
          assignSymbols(obj, val);
        }
      }
      return obj;
    };
    function assign(a, b) {
      for (var key in b) {
        if (hasOwn(b, key)) {
          a[key] = b[key];
        }
      }
    }
    function isString(val) {
      return val && typeof val === "string";
    }
    function toObject(str) {
      var obj = {};
      for (var i in str) {
        obj[i] = str[i];
      }
      return obj;
    }
    function isObject(val) {
      return val && typeof val === "object" || isExtendable(val);
    }
    function hasOwn(obj, key) {
      return Object.prototype.hasOwnProperty.call(obj, key);
    }
  }
});

// node_modules/regex-not/index.js
var require_regex_not = __commonJS({
  "node_modules/regex-not/index.js"(exports, module2) {
    "use strict";
    var extend = require_extend_shallow3();
    var safe = require_safe_regex();
    function toRegex(pattern, options) {
      return new RegExp(toRegex.create(pattern, options));
    }
    toRegex.create = function(pattern, options) {
      if (typeof pattern !== "string") {
        throw new TypeError("expected a string");
      }
      var opts = extend({}, options);
      if (opts.contains === true) {
        opts.strictNegate = false;
      }
      var open = opts.strictOpen !== false ? "^" : "";
      var close = opts.strictClose !== false ? "$" : "";
      var endChar = opts.endChar ? opts.endChar : "+";
      var str = pattern;
      if (opts.strictNegate === false) {
        str = "(?:(?!(?:" + pattern + ")).)" + endChar;
      } else {
        str = "(?:(?!^(?:" + pattern + ")$).)" + endChar;
      }
      var res = open + str + close;
      if (opts.safe === true && safe(res) === false) {
        throw new Error("potentially unsafe regular expression: " + res);
      }
      return res;
    };
    module2.exports = toRegex;
  }
});

// node_modules/to-regex/index.js
var require_to_regex = __commonJS({
  "node_modules/to-regex/index.js"(exports, module2) {
    "use strict";
    var safe = require_safe_regex();
    var define2 = require_define_property2();
    var extend = require_extend_shallow2();
    var not = require_regex_not();
    var MAX_LENGTH = 1024 * 64;
    var cache = {};
    module2.exports = function(patterns, options) {
      if (!Array.isArray(patterns)) {
        return makeRe(patterns, options);
      }
      return makeRe(patterns.join("|"), options);
    };
    function makeRe(pattern, options) {
      if (pattern instanceof RegExp) {
        return pattern;
      }
      if (typeof pattern !== "string") {
        throw new TypeError("expected a string");
      }
      if (pattern.length > MAX_LENGTH) {
        throw new Error("expected pattern to be less than " + MAX_LENGTH + " characters");
      }
      var key = pattern;
      if (!options || options && options.cache !== false) {
        key = createKey(pattern, options);
        if (cache.hasOwnProperty(key)) {
          return cache[key];
        }
      }
      var opts = extend({}, options);
      if (opts.contains === true) {
        if (opts.negate === true) {
          opts.strictNegate = false;
        } else {
          opts.strict = false;
        }
      }
      if (opts.strict === false) {
        opts.strictOpen = false;
        opts.strictClose = false;
      }
      var open = opts.strictOpen !== false ? "^" : "";
      var close = opts.strictClose !== false ? "$" : "";
      var flags = opts.flags || "";
      var regex;
      if (opts.nocase === true && !/i/.test(flags)) {
        flags += "i";
      }
      try {
        if (opts.negate || typeof opts.strictNegate === "boolean") {
          pattern = not.create(pattern, opts);
        }
        var str = open + "(?:" + pattern + ")" + close;
        regex = new RegExp(str, flags);
        if (opts.safe === true && safe(regex) === false) {
          throw new Error("potentially unsafe regular expression: " + regex.source);
        }
      } catch (err) {
        if (opts.strictErrors === true || opts.safe === true) {
          err.key = key;
          err.pattern = pattern;
          err.originalOptions = options;
          err.createdOptions = opts;
          throw err;
        }
        try {
          regex = new RegExp("^" + pattern.replace(/(\W)/g, "\\$1") + "$");
        } catch (err2) {
          regex = /.^/;
        }
      }
      if (opts.cache !== false) {
        memoize(regex, key, pattern, opts);
      }
      return regex;
    }
    function memoize(regex, key, pattern, options) {
      define2(regex, "cached", true);
      define2(regex, "pattern", pattern);
      define2(regex, "options", options);
      define2(regex, "key", key);
      cache[key] = regex;
    }
    function createKey(pattern, options) {
      if (!options)
        return pattern;
      var key = pattern;
      for (var prop in options) {
        if (options.hasOwnProperty(prop)) {
          key += ";" + prop + "=" + String(options[prop]);
        }
      }
      return key;
    }
    module2.exports.makeRe = makeRe;
  }
});

// node_modules/array-unique/index.js
var require_array_unique = __commonJS({
  "node_modules/array-unique/index.js"(exports, module2) {
    "use strict";
    module2.exports = function unique(arr) {
      if (!Array.isArray(arr)) {
        throw new TypeError("array-unique expects an array.");
      }
      var len = arr.length;
      var i = -1;
      while (i++ < len) {
        var j = i + 1;
        for (; j < arr.length; ++j) {
          if (arr[i] === arr[j]) {
            arr.splice(j--, 1);
          }
        }
      }
      return arr;
    };
    module2.exports.immutable = function uniqueImmutable(arr) {
      if (!Array.isArray(arr)) {
        throw new TypeError("array-unique expects an array.");
      }
      var arrLen = arr.length;
      var newArr = new Array(arrLen);
      for (var i = 0; i < arrLen; i++) {
        newArr[i] = arr[i];
      }
      return module2.exports(newArr);
    };
  }
});

// node_modules/is-extendable/index.js
var require_is_extendable4 = __commonJS({
  "node_modules/is-extendable/index.js"(exports, module2) {
    "use strict";
    module2.exports = function isExtendable(val) {
      return typeof val !== "undefined" && val !== null && (typeof val === "object" || typeof val === "function");
    };
  }
});

// node_modules/extend-shallow/index.js
var require_extend_shallow4 = __commonJS({
  "node_modules/extend-shallow/index.js"(exports, module2) {
    "use strict";
    var isObject = require_is_extendable4();
    module2.exports = function extend(o) {
      if (!isObject(o)) {
        o = {};
      }
      var len = arguments.length;
      for (var i = 1; i < len; i++) {
        var obj = arguments[i];
        if (isObject(obj)) {
          assign(o, obj);
        }
      }
      return o;
    };
    function assign(a, b) {
      for (var key in b) {
        if (hasOwn(b, key)) {
          a[key] = b[key];
        }
      }
    }
    function hasOwn(obj, key) {
      return Object.prototype.hasOwnProperty.call(obj, key);
    }
  }
});

// node_modules/split-string/node_modules/is-extendable/index.js
var require_is_extendable5 = __commonJS({
  "node_modules/split-string/node_modules/is-extendable/index.js"(exports, module2) {
    "use strict";
    var isPlainObject = require_is_plain_object();
    module2.exports = function isExtendable(val) {
      return isPlainObject(val) || typeof val === "function" || Array.isArray(val);
    };
  }
});

// node_modules/split-string/node_modules/extend-shallow/index.js
var require_extend_shallow5 = __commonJS({
  "node_modules/split-string/node_modules/extend-shallow/index.js"(exports, module2) {
    "use strict";
    var isExtendable = require_is_extendable5();
    var assignSymbols = require_assign_symbols();
    module2.exports = Object.assign || function(obj) {
      if (obj === null || typeof obj === "undefined") {
        throw new TypeError("Cannot convert undefined or null to object");
      }
      if (!isObject(obj)) {
        obj = {};
      }
      for (var i = 1; i < arguments.length; i++) {
        var val = arguments[i];
        if (isString(val)) {
          val = toObject(val);
        }
        if (isObject(val)) {
          assign(obj, val);
          assignSymbols(obj, val);
        }
      }
      return obj;
    };
    function assign(a, b) {
      for (var key in b) {
        if (hasOwn(b, key)) {
          a[key] = b[key];
        }
      }
    }
    function isString(val) {
      return val && typeof val === "string";
    }
    function toObject(str) {
      var obj = {};
      for (var i in str) {
        obj[i] = str[i];
      }
      return obj;
    }
    function isObject(val) {
      return val && typeof val === "object" || isExtendable(val);
    }
    function hasOwn(obj, key) {
      return Object.prototype.hasOwnProperty.call(obj, key);
    }
  }
});

// node_modules/split-string/index.js
var require_split_string = __commonJS({
  "node_modules/split-string/index.js"(exports, module2) {
    "use strict";
    var extend = require_extend_shallow5();
    module2.exports = function(str, options, fn) {
      if (typeof str !== "string") {
        throw new TypeError("expected a string");
      }
      if (typeof options === "function") {
        fn = options;
        options = null;
      }
      if (typeof options === "string") {
        options = { sep: options };
      }
      var opts = extend({ sep: "." }, options);
      var quotes = opts.quotes || ['"', "'", "`"];
      var brackets;
      if (opts.brackets === true) {
        brackets = {
          "<": ">",
          "(": ")",
          "[": "]",
          "{": "}"
        };
      } else if (opts.brackets) {
        brackets = opts.brackets;
      }
      var tokens = [];
      var stack = [];
      var arr = [""];
      var sep = opts.sep;
      var len = str.length;
      var idx = -1;
      var closeIdx;
      function expected() {
        if (brackets && stack.length) {
          return brackets[stack[stack.length - 1]];
        }
      }
      while (++idx < len) {
        var ch = str[idx];
        var next = str[idx + 1];
        var tok = { val: ch, idx, arr, str };
        tokens.push(tok);
        if (ch === "\\") {
          tok.val = keepEscaping(opts, str, idx) === true ? ch + next : next;
          tok.escaped = true;
          if (typeof fn === "function") {
            fn(tok);
          }
          arr[arr.length - 1] += tok.val;
          idx++;
          continue;
        }
        if (brackets && brackets[ch]) {
          stack.push(ch);
          var e = expected();
          var i = idx + 1;
          if (str.indexOf(e, i + 1) !== -1) {
            while (stack.length && i < len) {
              var s = str[++i];
              if (s === "\\") {
                s++;
                continue;
              }
              if (quotes.indexOf(s) !== -1) {
                i = getClosingQuote(str, s, i + 1);
                continue;
              }
              e = expected();
              if (stack.length && str.indexOf(e, i + 1) === -1) {
                break;
              }
              if (brackets[s]) {
                stack.push(s);
                continue;
              }
              if (e === s) {
                stack.pop();
              }
            }
          }
          closeIdx = i;
          if (closeIdx === -1) {
            arr[arr.length - 1] += ch;
            continue;
          }
          ch = str.slice(idx, closeIdx + 1);
          tok.val = ch;
          tok.idx = idx = closeIdx;
        }
        if (quotes.indexOf(ch) !== -1) {
          closeIdx = getClosingQuote(str, ch, idx + 1);
          if (closeIdx === -1) {
            arr[arr.length - 1] += ch;
            continue;
          }
          if (keepQuotes(ch, opts) === true) {
            ch = str.slice(idx, closeIdx + 1);
          } else {
            ch = str.slice(idx + 1, closeIdx);
          }
          tok.val = ch;
          tok.idx = idx = closeIdx;
        }
        if (typeof fn === "function") {
          fn(tok, tokens);
          ch = tok.val;
          idx = tok.idx;
        }
        if (tok.val === sep && tok.split !== false) {
          arr.push("");
          continue;
        }
        arr[arr.length - 1] += tok.val;
      }
      return arr;
    };
    function getClosingQuote(str, ch, i, brackets) {
      var idx = str.indexOf(ch, i);
      if (str.charAt(idx - 1) === "\\") {
        return getClosingQuote(str, ch, idx + 1);
      }
      return idx;
    }
    function keepQuotes(ch, opts) {
      if (opts.keepDoubleQuotes === true && ch === '"')
        return true;
      if (opts.keepSingleQuotes === true && ch === "'")
        return true;
      return opts.keepQuotes;
    }
    function keepEscaping(opts, str, idx) {
      if (typeof opts.keepEscaping === "function") {
        return opts.keepEscaping(str, idx);
      }
      return opts.keepEscaping === true || str[idx + 1] === "\\";
    }
  }
});

// node_modules/arr-flatten/index.js
var require_arr_flatten = __commonJS({
  "node_modules/arr-flatten/index.js"(exports, module2) {
    "use strict";
    module2.exports = function(arr) {
      return flat(arr, []);
    };
    function flat(arr, res) {
      var i = 0, cur;
      var len = arr.length;
      for (; i < len; i++) {
        cur = arr[i];
        Array.isArray(cur) ? flat(cur, res) : res.push(cur);
      }
      return res;
    }
  }
});

// node_modules/is-number/node_modules/kind-of/index.js
var require_kind_of6 = __commonJS({
  "node_modules/is-number/node_modules/kind-of/index.js"(exports, module2) {
    var isBuffer = require_is_buffer();
    var toString = Object.prototype.toString;
    module2.exports = function kindOf(val) {
      if (typeof val === "undefined") {
        return "undefined";
      }
      if (val === null) {
        return "null";
      }
      if (val === true || val === false || val instanceof Boolean) {
        return "boolean";
      }
      if (typeof val === "string" || val instanceof String) {
        return "string";
      }
      if (typeof val === "number" || val instanceof Number) {
        return "number";
      }
      if (typeof val === "function" || val instanceof Function) {
        return "function";
      }
      if (typeof Array.isArray !== "undefined" && Array.isArray(val)) {
        return "array";
      }
      if (val instanceof RegExp) {
        return "regexp";
      }
      if (val instanceof Date) {
        return "date";
      }
      var type = toString.call(val);
      if (type === "[object RegExp]") {
        return "regexp";
      }
      if (type === "[object Date]") {
        return "date";
      }
      if (type === "[object Arguments]") {
        return "arguments";
      }
      if (type === "[object Error]") {
        return "error";
      }
      if (isBuffer(val)) {
        return "buffer";
      }
      if (type === "[object Set]") {
        return "set";
      }
      if (type === "[object WeakSet]") {
        return "weakset";
      }
      if (type === "[object Map]") {
        return "map";
      }
      if (type === "[object WeakMap]") {
        return "weakmap";
      }
      if (type === "[object Symbol]") {
        return "symbol";
      }
      if (type === "[object Int8Array]") {
        return "int8array";
      }
      if (type === "[object Uint8Array]") {
        return "uint8array";
      }
      if (type === "[object Uint8ClampedArray]") {
        return "uint8clampedarray";
      }
      if (type === "[object Int16Array]") {
        return "int16array";
      }
      if (type === "[object Uint16Array]") {
        return "uint16array";
      }
      if (type === "[object Int32Array]") {
        return "int32array";
      }
      if (type === "[object Uint32Array]") {
        return "uint32array";
      }
      if (type === "[object Float32Array]") {
        return "float32array";
      }
      if (type === "[object Float64Array]") {
        return "float64array";
      }
      return "object";
    };
  }
});

// node_modules/is-number/index.js
var require_is_number2 = __commonJS({
  "node_modules/is-number/index.js"(exports, module2) {
    "use strict";
    var typeOf = require_kind_of6();
    module2.exports = function isNumber(num) {
      var type = typeOf(num);
      if (type === "string") {
        if (!num.trim())
          return false;
      } else if (type !== "number") {
        return false;
      }
      return num - num + 1 >= 0;
    };
  }
});

// node_modules/repeat-string/index.js
var require_repeat_string = __commonJS({
  "node_modules/repeat-string/index.js"(exports, module2) {
    "use strict";
    var res = "";
    var cache;
    module2.exports = repeat;
    function repeat(str, num) {
      if (typeof str !== "string") {
        throw new TypeError("expected a string");
      }
      if (num === 1)
        return str;
      if (num === 2)
        return str + str;
      var max = str.length * num;
      if (cache !== str || typeof cache === "undefined") {
        cache = str;
        res = "";
      } else if (res.length >= max) {
        return res.substr(0, max);
      }
      while (max > res.length && num > 1) {
        if (num & 1) {
          res += str;
        }
        num >>= 1;
        str += str;
      }
      res += str;
      res = res.substr(0, max);
      return res;
    }
  }
});

// node_modules/to-regex-range/index.js
var require_to_regex_range = __commonJS({
  "node_modules/to-regex-range/index.js"(exports, module2) {
    "use strict";
    var repeat = require_repeat_string();
    var isNumber = require_is_number2();
    var cache = {};
    function toRegexRange(min, max, options) {
      if (isNumber(min) === false) {
        throw new RangeError("toRegexRange: first argument is invalid.");
      }
      if (typeof max === "undefined" || min === max) {
        return String(min);
      }
      if (isNumber(max) === false) {
        throw new RangeError("toRegexRange: second argument is invalid.");
      }
      options = options || {};
      var relax = String(options.relaxZeros);
      var shorthand = String(options.shorthand);
      var capture = String(options.capture);
      var key = min + ":" + max + "=" + relax + shorthand + capture;
      if (cache.hasOwnProperty(key)) {
        return cache[key].result;
      }
      var a = Math.min(min, max);
      var b = Math.max(min, max);
      if (Math.abs(a - b) === 1) {
        var result = min + "|" + max;
        if (options.capture) {
          return "(" + result + ")";
        }
        return result;
      }
      var isPadded = padding(min) || padding(max);
      var positives = [];
      var negatives = [];
      var tok = { min, max, a, b };
      if (isPadded) {
        tok.isPadded = isPadded;
        tok.maxLen = String(tok.max).length;
      }
      if (a < 0) {
        var newMin = b < 0 ? Math.abs(b) : 1;
        var newMax = Math.abs(a);
        negatives = splitToPatterns(newMin, newMax, tok, options);
        a = tok.a = 0;
      }
      if (b >= 0) {
        positives = splitToPatterns(a, b, tok, options);
      }
      tok.negatives = negatives;
      tok.positives = positives;
      tok.result = siftPatterns(negatives, positives, options);
      if (options.capture && positives.length + negatives.length > 1) {
        tok.result = "(" + tok.result + ")";
      }
      cache[key] = tok;
      return tok.result;
    }
    function siftPatterns(neg, pos, options) {
      var onlyNegative = filterPatterns(neg, pos, "-", false, options) || [];
      var onlyPositive = filterPatterns(pos, neg, "", false, options) || [];
      var intersected = filterPatterns(neg, pos, "-?", true, options) || [];
      var subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);
      return subpatterns.join("|");
    }
    function splitToRanges(min, max) {
      min = Number(min);
      max = Number(max);
      var nines = 1;
      var stops = [max];
      var stop = +countNines(min, nines);
      while (min <= stop && stop <= max) {
        stops = push(stops, stop);
        nines += 1;
        stop = +countNines(min, nines);
      }
      var zeros = 1;
      stop = countZeros(max + 1, zeros) - 1;
      while (min < stop && stop <= max) {
        stops = push(stops, stop);
        zeros += 1;
        stop = countZeros(max + 1, zeros) - 1;
      }
      stops.sort(compare);
      return stops;
    }
    function rangeToPattern(start, stop, options) {
      if (start === stop) {
        return { pattern: String(start), digits: [] };
      }
      var zipped = zip(String(start), String(stop));
      var len = zipped.length, i = -1;
      var pattern = "";
      var digits = 0;
      while (++i < len) {
        var numbers = zipped[i];
        var startDigit = numbers[0];
        var stopDigit = numbers[1];
        if (startDigit === stopDigit) {
          pattern += startDigit;
        } else if (startDigit !== "0" || stopDigit !== "9") {
          pattern += toCharacterClass(startDigit, stopDigit);
        } else {
          digits += 1;
        }
      }
      if (digits) {
        pattern += options.shorthand ? "\\d" : "[0-9]";
      }
      return { pattern, digits: [digits] };
    }
    function splitToPatterns(min, max, tok, options) {
      var ranges = splitToRanges(min, max);
      var len = ranges.length;
      var idx = -1;
      var tokens = [];
      var start = min;
      var prev;
      while (++idx < len) {
        var range = ranges[idx];
        var obj = rangeToPattern(start, range, options);
        var zeros = "";
        if (!tok.isPadded && prev && prev.pattern === obj.pattern) {
          if (prev.digits.length > 1) {
            prev.digits.pop();
          }
          prev.digits.push(obj.digits[0]);
          prev.string = prev.pattern + toQuantifier(prev.digits);
          start = range + 1;
          continue;
        }
        if (tok.isPadded) {
          zeros = padZeros(range, tok);
        }
        obj.string = zeros + obj.pattern + toQuantifier(obj.digits);
        tokens.push(obj);
        start = range + 1;
        prev = obj;
      }
      return tokens;
    }
    function filterPatterns(arr, comparison, prefix, intersection, options) {
      var res = [];
      for (var i = 0; i < arr.length; i++) {
        var tok = arr[i];
        var ele = tok.string;
        if (options.relaxZeros !== false) {
          if (prefix === "-" && ele.charAt(0) === "0") {
            if (ele.charAt(1) === "{") {
              ele = "0*" + ele.replace(/^0\{\d+\}/, "");
            } else {
              ele = "0*" + ele.slice(1);
            }
          }
        }
        if (!intersection && !contains(comparison, "string", ele)) {
          res.push(prefix + ele);
        }
        if (intersection && contains(comparison, "string", ele)) {
          res.push(prefix + ele);
        }
      }
      return res;
    }
    function zip(a, b) {
      var arr = [];
      for (var ch in a)
        arr.push([a[ch], b[ch]]);
      return arr;
    }
    function compare(a, b) {
      return a > b ? 1 : b > a ? -1 : 0;
    }
    function push(arr, ele) {
      if (arr.indexOf(ele) === -1)
        arr.push(ele);
      return arr;
    }
    function contains(arr, key, val) {
      for (var i = 0; i < arr.length; i++) {
        if (arr[i][key] === val) {
          return true;
        }
      }
      return false;
    }
    function countNines(min, len) {
      return String(min).slice(0, -len) + repeat("9", len);
    }
    function countZeros(integer, zeros) {
      return integer - integer % Math.pow(10, zeros);
    }
    function toQuantifier(digits) {
      var start = digits[0];
      var stop = digits[1] ? "," + digits[1] : "";
      if (!stop && (!start || start === 1)) {
        return "";
      }
      return "{" + start + stop + "}";
    }
    function toCharacterClass(a, b) {
      return "[" + a + (b - a === 1 ? "" : "-") + b + "]";
    }
    function padding(str) {
      return /^-?(0+)\d/.exec(str);
    }
    function padZeros(val, tok) {
      if (tok.isPadded) {
        var diff = Math.abs(tok.maxLen - String(val).length);
        switch (diff) {
          case 0:
            return "";
          case 1:
            return "0";
          default: {
            return "0{" + diff + "}";
          }
        }
      }
      return val;
    }
    module2.exports = toRegexRange;
  }
});

// node_modules/fill-range/index.js
var require_fill_range = __commonJS({
  "node_modules/fill-range/index.js"(exports, module2) {
    "use strict";
    var util = require("util");
    var isNumber = require_is_number2();
    var extend = require_extend_shallow4();
    var repeat = require_repeat_string();
    var toRegex = require_to_regex_range();
    function fillRange(start, stop, step, options) {
      if (typeof start === "undefined") {
        return [];
      }
      if (typeof stop === "undefined" || start === stop) {
        var isString = typeof start === "string";
        if (isNumber(start) && !toNumber(start)) {
          return [isString ? "0" : 0];
        }
        return [start];
      }
      if (typeof step !== "number" && typeof step !== "string") {
        options = step;
        step = void 0;
      }
      if (typeof options === "function") {
        options = { transform: options };
      }
      var opts = extend({ step }, options);
      if (opts.step && !isValidNumber(opts.step)) {
        if (opts.strictRanges === true) {
          throw new TypeError("expected options.step to be a number");
        }
        return [];
      }
      opts.isNumber = isValidNumber(start) && isValidNumber(stop);
      if (!opts.isNumber && !isValid(start, stop)) {
        if (opts.strictRanges === true) {
          throw new RangeError("invalid range arguments: " + util.inspect([start, stop]));
        }
        return [];
      }
      opts.isPadded = isPadded(start) || isPadded(stop);
      opts.toString = opts.stringify || typeof opts.step === "string" || typeof start === "string" || typeof stop === "string" || !opts.isNumber;
      if (opts.isPadded) {
        opts.maxLength = Math.max(String(start).length, String(stop).length);
      }
      if (typeof opts.optimize === "boolean")
        opts.toRegex = opts.optimize;
      if (typeof opts.makeRe === "boolean")
        opts.toRegex = opts.makeRe;
      return expand(start, stop, opts);
    }
    function expand(start, stop, options) {
      var a = options.isNumber ? toNumber(start) : start.charCodeAt(0);
      var b = options.isNumber ? toNumber(stop) : stop.charCodeAt(0);
      var step = Math.abs(toNumber(options.step)) || 1;
      if (options.toRegex && step === 1) {
        return toRange(a, b, start, stop, options);
      }
      var zero = { greater: [], lesser: [] };
      var asc = a < b;
      var arr = new Array(Math.round((asc ? b - a : a - b) / step));
      var idx = 0;
      while (asc ? a <= b : a >= b) {
        var val = options.isNumber ? a : String.fromCharCode(a);
        if (options.toRegex && (val >= 0 || !options.isNumber)) {
          zero.greater.push(val);
        } else {
          zero.lesser.push(Math.abs(val));
        }
        if (options.isPadded) {
          val = zeros(val, options);
        }
        if (options.toString) {
          val = String(val);
        }
        if (typeof options.transform === "function") {
          arr[idx++] = options.transform(val, a, b, step, idx, arr, options);
        } else {
          arr[idx++] = val;
        }
        if (asc) {
          a += step;
        } else {
          a -= step;
        }
      }
      if (options.toRegex === true) {
        return toSequence(arr, zero, options);
      }
      return arr;
    }
    function toRange(a, b, start, stop, options) {
      if (options.isPadded) {
        return toRegex(start, stop, options);
      }
      if (options.isNumber) {
        return toRegex(Math.min(a, b), Math.max(a, b), options);
      }
      var start = String.fromCharCode(Math.min(a, b));
      var stop = String.fromCharCode(Math.max(a, b));
      return "[" + start + "-" + stop + "]";
    }
    function toSequence(arr, zeros2, options) {
      var greater = "", lesser = "";
      if (zeros2.greater.length) {
        greater = zeros2.greater.join("|");
      }
      if (zeros2.lesser.length) {
        lesser = "-(" + zeros2.lesser.join("|") + ")";
      }
      var res = greater && lesser ? greater + "|" + lesser : greater || lesser;
      if (options.capture) {
        return "(" + res + ")";
      }
      return res;
    }
    function zeros(val, options) {
      if (options.isPadded) {
        var str = String(val);
        var len = str.length;
        var dash = "";
        if (str.charAt(0) === "-") {
          dash = "-";
          str = str.slice(1);
        }
        var diff = options.maxLength - len;
        var pad = repeat("0", diff);
        val = dash + pad + str;
      }
      if (options.stringify) {
        return String(val);
      }
      return val;
    }
    function toNumber(val) {
      return Number(val) || 0;
    }
    function isPadded(str) {
      return /^-?0\d/.test(str);
    }
    function isValid(min, max) {
      return (isValidNumber(min) || isValidLetter(min)) && (isValidNumber(max) || isValidLetter(max));
    }
    function isValidLetter(ch) {
      return typeof ch === "string" && ch.length === 1 && /^\w+$/.test(ch);
    }
    function isValidNumber(n) {
      return isNumber(n) && !/\./.test(n);
    }
    module2.exports = fillRange;
  }
});

// node_modules/repeat-element/index.js
var require_repeat_element = __commonJS({
  "node_modules/repeat-element/index.js"(exports, module2) {
    "use strict";
    module2.exports = function repeat(ele, num) {
      if (Array.prototype.fill) {
        return new Array(num).fill(ele);
      }
      var arr = new Array(num);
      for (var i = 0; i < num; i++) {
        arr[i] = ele;
      }
      return arr;
    };
  }
});

// node_modules/braces/lib/utils.js
var require_utils3 = __commonJS({
  "node_modules/braces/lib/utils.js"(exports, module2) {
    "use strict";
    var splitString = require_split_string();
    var utils = module2.exports;
    utils.extend = require_extend_shallow4();
    utils.flatten = require_arr_flatten();
    utils.isObject = require_isobject();
    utils.fillRange = require_fill_range();
    utils.repeat = require_repeat_element();
    utils.unique = require_array_unique();
    utils.define = function(obj, key, val) {
      Object.defineProperty(obj, key, {
        writable: true,
        configurable: true,
        enumerable: false,
        value: val
      });
    };
    utils.isEmptySets = function(str) {
      return /^(?:\{,\})+$/.test(str);
    };
    utils.isQuotedString = function(str) {
      var open = str.charAt(0);
      if (open === "'" || open === '"' || open === "`") {
        return str.slice(-1) === open;
      }
      return false;
    };
    utils.createKey = function(pattern, options) {
      var id = pattern;
      if (typeof options === "undefined") {
        return id;
      }
      var keys = Object.keys(options);
      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        id += ";" + key + "=" + String(options[key]);
      }
      return id;
    };
    utils.createOptions = function(options) {
      var opts = utils.extend.apply(null, arguments);
      if (typeof opts.expand === "boolean") {
        opts.optimize = !opts.expand;
      }
      if (typeof opts.optimize === "boolean") {
        opts.expand = !opts.optimize;
      }
      if (opts.optimize === true) {
        opts.makeRe = true;
      }
      return opts;
    };
    utils.join = function(a, b, options) {
      options = options || {};
      a = utils.arrayify(a);
      b = utils.arrayify(b);
      if (!a.length)
        return b;
      if (!b.length)
        return a;
      var len = a.length;
      var idx = -1;
      var arr = [];
      while (++idx < len) {
        var val = a[idx];
        if (Array.isArray(val)) {
          for (var i = 0; i < val.length; i++) {
            val[i] = utils.join(val[i], b, options);
          }
          arr.push(val);
          continue;
        }
        for (var j = 0; j < b.length; j++) {
          var bval = b[j];
          if (Array.isArray(bval)) {
            arr.push(utils.join(val, bval, options));
          } else {
            arr.push(val + bval);
          }
        }
      }
      return arr;
    };
    utils.split = function(str, options) {
      var opts = utils.extend({ sep: "," }, options);
      if (typeof opts.keepQuotes !== "boolean") {
        opts.keepQuotes = true;
      }
      if (opts.unescape === false) {
        opts.keepEscaping = true;
      }
      return splitString(str, opts, utils.escapeBrackets(opts));
    };
    utils.expand = function(str, options) {
      var opts = utils.extend({ rangeLimit: 1e4 }, options);
      var segs = utils.split(str, opts);
      var tok = { segs };
      if (utils.isQuotedString(str)) {
        return tok;
      }
      if (opts.rangeLimit === true) {
        opts.rangeLimit = 1e4;
      }
      if (segs.length > 1) {
        if (opts.optimize === false) {
          tok.val = segs[0];
          return tok;
        }
        tok.segs = utils.stringifyArray(tok.segs);
      } else if (segs.length === 1) {
        var arr = str.split("..");
        if (arr.length === 1) {
          tok.val = tok.segs[tok.segs.length - 1] || tok.val || str;
          tok.segs = [];
          return tok;
        }
        if (arr.length === 2 && arr[0] === arr[1]) {
          tok.escaped = true;
          tok.val = arr[0];
          tok.segs = [];
          return tok;
        }
        if (arr.length > 1) {
          if (opts.optimize !== false) {
            opts.optimize = true;
            delete opts.expand;
          }
          if (opts.optimize !== true) {
            var min = Math.min(arr[0], arr[1]);
            var max = Math.max(arr[0], arr[1]);
            var step = arr[2] || 1;
            if (opts.rangeLimit !== false && (max - min) / step >= opts.rangeLimit) {
              throw new RangeError("expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.");
            }
          }
          arr.push(opts);
          tok.segs = utils.fillRange.apply(null, arr);
          if (!tok.segs.length) {
            tok.escaped = true;
            tok.val = str;
            return tok;
          }
          if (opts.optimize === true) {
            tok.segs = utils.stringifyArray(tok.segs);
          }
          if (tok.segs === "") {
            tok.val = str;
          } else {
            tok.val = tok.segs[0];
          }
          return tok;
        }
      } else {
        tok.val = str;
      }
      return tok;
    };
    utils.escapeBrackets = function(options) {
      return function(tok) {
        if (tok.escaped && tok.val === "b") {
          tok.val = "\\b";
          return;
        }
        if (tok.val !== "(" && tok.val !== "[")
          return;
        var opts = utils.extend({}, options);
        var brackets = [];
        var parens = [];
        var stack = [];
        var val = tok.val;
        var str = tok.str;
        var i = tok.idx - 1;
        while (++i < str.length) {
          var ch = str[i];
          if (ch === "\\") {
            val += (opts.keepEscaping === false ? "" : ch) + str[++i];
            continue;
          }
          if (ch === "(") {
            parens.push(ch);
            stack.push(ch);
          }
          if (ch === "[") {
            brackets.push(ch);
            stack.push(ch);
          }
          if (ch === ")") {
            parens.pop();
            stack.pop();
            if (!stack.length) {
              val += ch;
              break;
            }
          }
          if (ch === "]") {
            brackets.pop();
            stack.pop();
            if (!stack.length) {
              val += ch;
              break;
            }
          }
          val += ch;
        }
        tok.split = false;
        tok.val = val.slice(1);
        tok.idx = i;
      };
    };
    utils.isQuantifier = function(str) {
      return /^(?:[0-9]?,[0-9]|[0-9],)$/.test(str);
    };
    utils.stringifyArray = function(arr) {
      return [utils.arrayify(arr).join("|")];
    };
    utils.arrayify = function(arr) {
      if (typeof arr === "undefined") {
        return [];
      }
      if (typeof arr === "string") {
        return [arr];
      }
      return arr;
    };
    utils.isString = function(str) {
      return str != null && typeof str === "string";
    };
    utils.last = function(arr, n) {
      return arr[arr.length - (n || 1)];
    };
    utils.escapeRegex = function(str) {
      return str.replace(/\\?([!^*?()[\]{}+?/])/g, "\\$1");
    };
  }
});

// node_modules/braces/lib/compilers.js
var require_compilers = __commonJS({
  "node_modules/braces/lib/compilers.js"(exports, module2) {
    "use strict";
    var utils = require_utils3();
    module2.exports = function(braces, options) {
      braces.compiler.set("bos", function() {
        if (this.output)
          return;
        this.ast.queue = isEscaped(this.ast) ? [this.ast.val] : [];
        this.ast.count = 1;
      }).set("bracket", function(node) {
        var close = node.close;
        var open = !node.escaped ? "[" : "\\[";
        var negated = node.negated;
        var inner = node.inner;
        inner = inner.replace(/\\(?=[\\\w]|$)/g, "\\\\");
        if (inner === "]-") {
          inner = "\\]\\-";
        }
        if (negated && inner.indexOf(".") === -1) {
          inner += ".";
        }
        if (negated && inner.indexOf("/") === -1) {
          inner += "/";
        }
        var val = open + negated + inner + close;
        var queue = node.parent.queue;
        var last = utils.arrayify(queue.pop());
        queue.push(utils.join(last, val));
        queue.push.apply(queue, []);
      }).set("brace", function(node) {
        node.queue = isEscaped(node) ? [node.val] : [];
        node.count = 1;
        return this.mapVisit(node.nodes);
      }).set("brace.open", function(node) {
        node.parent.open = node.val;
      }).set("text", function(node) {
        var queue = node.parent.queue;
        var escaped = node.escaped;
        var segs = [node.val];
        if (node.optimize === false) {
          options = utils.extend({}, options, { optimize: false });
        }
        if (node.multiplier > 1) {
          node.parent.count *= node.multiplier;
        }
        if (options.quantifiers === true && utils.isQuantifier(node.val)) {
          escaped = true;
        } else if (node.val.length > 1) {
          if (isType(node.parent, "brace") && !isEscaped(node)) {
            var expanded = utils.expand(node.val, options);
            segs = expanded.segs;
            if (expanded.isOptimized) {
              node.parent.isOptimized = true;
            }
            if (!segs.length) {
              var val = expanded.val || node.val;
              if (options.unescape !== false) {
                val = val.replace(/\\([,.])/g, "$1");
                val = val.replace(/["'`]/g, "");
              }
              segs = [val];
              escaped = true;
            }
          }
        } else if (node.val === ",") {
          if (options.expand) {
            node.parent.queue.push([""]);
            segs = [""];
          } else {
            segs = ["|"];
          }
        } else {
          escaped = true;
        }
        if (escaped && isType(node.parent, "brace")) {
          if (node.parent.nodes.length <= 4 && node.parent.count === 1) {
            node.parent.escaped = true;
          } else if (node.parent.length <= 3) {
            node.parent.escaped = true;
          }
        }
        if (!hasQueue(node.parent)) {
          node.parent.queue = segs;
          return;
        }
        var last = utils.arrayify(queue.pop());
        if (node.parent.count > 1 && options.expand) {
          last = multiply(last, node.parent.count);
          node.parent.count = 1;
        }
        queue.push(utils.join(utils.flatten(last), segs.shift()));
        queue.push.apply(queue, segs);
      }).set("brace.close", function(node) {
        var queue = node.parent.queue;
        var prev = node.parent.parent;
        var last = prev.queue.pop();
        var open = node.parent.open;
        var close = node.val;
        if (open && close && isOptimized(node, options)) {
          open = "(";
          close = ")";
        }
        var ele = utils.last(queue);
        if (node.parent.count > 1 && options.expand) {
          ele = multiply(queue.pop(), node.parent.count);
          node.parent.count = 1;
          queue.push(ele);
        }
        if (close && typeof ele === "string" && ele.length === 1) {
          open = "";
          close = "";
        }
        if ((isLiteralBrace(node, options) || noInner(node)) && !node.parent.hasEmpty) {
          queue.push(utils.join(open, queue.pop() || ""));
          queue = utils.flatten(utils.join(queue, close));
        }
        if (typeof last === "undefined") {
          prev.queue = [queue];
        } else {
          prev.queue.push(utils.flatten(utils.join(last, queue)));
        }
      }).set("eos", function(node) {
        if (this.input)
          return;
        if (options.optimize !== false) {
          this.output = utils.last(utils.flatten(this.ast.queue));
        } else if (Array.isArray(utils.last(this.ast.queue))) {
          this.output = utils.flatten(this.ast.queue.pop());
        } else {
          this.output = utils.flatten(this.ast.queue);
        }
        if (node.parent.count > 1 && options.expand) {
          this.output = multiply(this.output, node.parent.count);
        }
        this.output = utils.arrayify(this.output);
        this.ast.queue = [];
      });
    };
    function multiply(queue, n, options) {
      return utils.flatten(utils.repeat(utils.arrayify(queue), n));
    }
    function isEscaped(node) {
      return node.escaped === true;
    }
    function isOptimized(node, options) {
      if (node.parent.isOptimized)
        return true;
      return isType(node.parent, "brace") && !isEscaped(node.parent) && options.expand !== true;
    }
    function isLiteralBrace(node, options) {
      return isEscaped(node.parent) || options.optimize !== false;
    }
    function noInner(node, type) {
      if (node.parent.queue.length === 1) {
        return true;
      }
      var nodes = node.parent.nodes;
      return nodes.length === 3 && isType(nodes[0], "brace.open") && !isType(nodes[1], "text") && isType(nodes[2], "brace.close");
    }
    function isType(node, type) {
      return typeof node !== "undefined" && node.type === type;
    }
    function hasQueue(node) {
      return Array.isArray(node.queue) && node.queue.length;
    }
  }
});

// node_modules/snapdragon-node/node_modules/define-property/index.js
var require_define_property3 = __commonJS({
  "node_modules/snapdragon-node/node_modules/define-property/index.js"(exports, module2) {
    "use strict";
    var isDescriptor = require_is_descriptor();
    module2.exports = function defineProperty(obj, prop, val) {
      if (typeof obj !== "object" && typeof obj !== "function") {
        throw new TypeError("expected an object or function.");
      }
      if (typeof prop !== "string") {
        throw new TypeError("expected `prop` to be a string.");
      }
      if (isDescriptor(val) && ("set" in val || "get" in val)) {
        return Object.defineProperty(obj, prop, val);
      }
      return Object.defineProperty(obj, prop, {
        configurable: true,
        enumerable: false,
        writable: true,
        value: val
      });
    };
  }
});

// node_modules/snapdragon-util/node_modules/kind-of/index.js
var require_kind_of7 = __commonJS({
  "node_modules/snapdragon-util/node_modules/kind-of/index.js"(exports, module2) {
    var isBuffer = require_is_buffer();
    var toString = Object.prototype.toString;
    module2.exports = function kindOf(val) {
      if (typeof val === "undefined") {
        return "undefined";
      }
      if (val === null) {
        return "null";
      }
      if (val === true || val === false || val instanceof Boolean) {
        return "boolean";
      }
      if (typeof val === "string" || val instanceof String) {
        return "string";
      }
      if (typeof val === "number" || val instanceof Number) {
        return "number";
      }
      if (typeof val === "function" || val instanceof Function) {
        return "function";
      }
      if (typeof Array.isArray !== "undefined" && Array.isArray(val)) {
        return "array";
      }
      if (val instanceof RegExp) {
        return "regexp";
      }
      if (val instanceof Date) {
        return "date";
      }
      var type = toString.call(val);
      if (type === "[object RegExp]") {
        return "regexp";
      }
      if (type === "[object Date]") {
        return "date";
      }
      if (type === "[object Arguments]") {
        return "arguments";
      }
      if (type === "[object Error]") {
        return "error";
      }
      if (isBuffer(val)) {
        return "buffer";
      }
      if (type === "[object Set]") {
        return "set";
      }
      if (type === "[object WeakSet]") {
        return "weakset";
      }
      if (type === "[object Map]") {
        return "map";
      }
      if (type === "[object WeakMap]") {
        return "weakmap";
      }
      if (type === "[object Symbol]") {
        return "symbol";
      }
      if (type === "[object Int8Array]") {
        return "int8array";
      }
      if (type === "[object Uint8Array]") {
        return "uint8array";
      }
      if (type === "[object Uint8ClampedArray]") {
        return "uint8clampedarray";
      }
      if (type === "[object Int16Array]") {
        return "int16array";
      }
      if (type === "[object Uint16Array]") {
        return "uint16array";
      }
      if (type === "[object Int32Array]") {
        return "int32array";
      }
      if (type === "[object Uint32Array]") {
        return "uint32array";
      }
      if (type === "[object Float32Array]") {
        return "float32array";
      }
      if (type === "[object Float64Array]") {
        return "float64array";
      }
      return "object";
    };
  }
});

// node_modules/snapdragon-util/index.js
var require_snapdragon_util = __commonJS({
  "node_modules/snapdragon-util/index.js"(exports, module2) {
    "use strict";
    var typeOf = require_kind_of7();
    var utils = module2.exports;
    utils.isNode = function(node) {
      return typeOf(node) === "object" && node.isNode === true;
    };
    utils.noop = function(node) {
      append(this, "", node);
    };
    utils.identity = function(node) {
      append(this, node.val, node);
    };
    utils.append = function(val) {
      return function(node) {
        append(this, val, node);
      };
    };
    utils.toNoop = function(node, nodes) {
      if (nodes) {
        node.nodes = nodes;
      } else {
        delete node.nodes;
        node.type = "text";
        node.val = "";
      }
    };
    utils.visit = function(node, fn) {
      assert(utils.isNode(node), "expected node to be an instance of Node");
      assert(isFunction(fn), "expected a visitor function");
      fn(node);
      return node.nodes ? utils.mapVisit(node, fn) : node;
    };
    utils.mapVisit = function(node, fn) {
      assert(utils.isNode(node), "expected node to be an instance of Node");
      assert(isArray(node.nodes), "expected node.nodes to be an array");
      assert(isFunction(fn), "expected a visitor function");
      for (var i = 0; i < node.nodes.length; i++) {
        utils.visit(node.nodes[i], fn);
      }
      return node;
    };
    utils.addOpen = function(node, Node, val, filter) {
      assert(utils.isNode(node), "expected node to be an instance of Node");
      assert(isFunction(Node), "expected Node to be a constructor function");
      if (typeof val === "function") {
        filter = val;
        val = "";
      }
      if (typeof filter === "function" && !filter(node))
        return;
      var open = new Node({ type: node.type + ".open", val });
      var unshift = node.unshift || node.unshiftNode;
      if (typeof unshift === "function") {
        unshift.call(node, open);
      } else {
        utils.unshiftNode(node, open);
      }
      return open;
    };
    utils.addClose = function(node, Node, val, filter) {
      assert(utils.isNode(node), "expected node to be an instance of Node");
      assert(isFunction(Node), "expected Node to be a constructor function");
      if (typeof val === "function") {
        filter = val;
        val = "";
      }
      if (typeof filter === "function" && !filter(node))
        return;
      var close = new Node({ type: node.type + ".close", val });
      var push = node.push || node.pushNode;
      if (typeof push === "function") {
        push.call(node, close);
      } else {
        utils.pushNode(node, close);
      }
      return close;
    };
    utils.wrapNodes = function(node, Node, filter) {
      assert(utils.isNode(node), "expected node to be an instance of Node");
      assert(isFunction(Node), "expected Node to be a constructor function");
      utils.addOpen(node, Node, filter);
      utils.addClose(node, Node, filter);
      return node;
    };
    utils.pushNode = function(parent, node) {
      assert(utils.isNode(parent), "expected parent node to be an instance of Node");
      assert(utils.isNode(node), "expected node to be an instance of Node");
      node.define("parent", parent);
      parent.nodes = parent.nodes || [];
      parent.nodes.push(node);
      return node;
    };
    utils.unshiftNode = function(parent, node) {
      assert(utils.isNode(parent), "expected parent node to be an instance of Node");
      assert(utils.isNode(node), "expected node to be an instance of Node");
      node.define("parent", parent);
      parent.nodes = parent.nodes || [];
      parent.nodes.unshift(node);
    };
    utils.popNode = function(node) {
      assert(utils.isNode(node), "expected node to be an instance of Node");
      if (typeof node.pop === "function") {
        return node.pop();
      }
      return node.nodes && node.nodes.pop();
    };
    utils.shiftNode = function(node) {
      assert(utils.isNode(node), "expected node to be an instance of Node");
      if (typeof node.shift === "function") {
        return node.shift();
      }
      return node.nodes && node.nodes.shift();
    };
    utils.removeNode = function(parent, node) {
      assert(utils.isNode(parent), "expected parent.node to be an instance of Node");
      assert(utils.isNode(node), "expected node to be an instance of Node");
      if (!parent.nodes) {
        return null;
      }
      if (typeof parent.remove === "function") {
        return parent.remove(node);
      }
      var idx = parent.nodes.indexOf(node);
      if (idx !== -1) {
        return parent.nodes.splice(idx, 1);
      }
    };
    utils.isType = function(node, type) {
      assert(utils.isNode(node), "expected node to be an instance of Node");
      switch (typeOf(type)) {
        case "array":
          var types = type.slice();
          for (var i = 0; i < types.length; i++) {
            if (utils.isType(node, types[i])) {
              return true;
            }
          }
          return false;
        case "string":
          return node.type === type;
        case "regexp":
          return type.test(node.type);
        default: {
          throw new TypeError('expected "type" to be an array, string or regexp');
        }
      }
    };
    utils.hasType = function(node, type) {
      assert(utils.isNode(node), "expected node to be an instance of Node");
      if (!Array.isArray(node.nodes))
        return false;
      for (var i = 0; i < node.nodes.length; i++) {
        if (utils.isType(node.nodes[i], type)) {
          return true;
        }
      }
      return false;
    };
    utils.firstOfType = function(nodes, type) {
      for (var i = 0; i < nodes.length; i++) {
        var node = nodes[i];
        if (utils.isType(node, type)) {
          return node;
        }
      }
    };
    utils.findNode = function(nodes, type) {
      if (!Array.isArray(nodes)) {
        return null;
      }
      if (typeof type === "number") {
        return nodes[type];
      }
      return utils.firstOfType(nodes, type);
    };
    utils.isOpen = function(node) {
      assert(utils.isNode(node), "expected node to be an instance of Node");
      return node.type.slice(-5) === ".open";
    };
    utils.isClose = function(node) {
      assert(utils.isNode(node), "expected node to be an instance of Node");
      return node.type.slice(-6) === ".close";
    };
    utils.hasOpen = function(node) {
      assert(utils.isNode(node), "expected node to be an instance of Node");
      var first = node.first || node.nodes ? node.nodes[0] : null;
      if (utils.isNode(first)) {
        return first.type === node.type + ".open";
      }
      return false;
    };
    utils.hasClose = function(node) {
      assert(utils.isNode(node), "expected node to be an instance of Node");
      var last = node.last || node.nodes ? node.nodes[node.nodes.length - 1] : null;
      if (utils.isNode(last)) {
        return last.type === node.type + ".close";
      }
      return false;
    };
    utils.hasOpenAndClose = function(node) {
      return utils.hasOpen(node) && utils.hasClose(node);
    };
    utils.addType = function(state, node) {
      assert(utils.isNode(node), "expected node to be an instance of Node");
      assert(isObject(state), "expected state to be an object");
      var type = node.parent ? node.parent.type : node.type.replace(/\.open$/, "");
      if (!state.hasOwnProperty("inside")) {
        state.inside = {};
      }
      if (!state.inside.hasOwnProperty(type)) {
        state.inside[type] = [];
      }
      var arr = state.inside[type];
      arr.push(node);
      return arr;
    };
    utils.removeType = function(state, node) {
      assert(utils.isNode(node), "expected node to be an instance of Node");
      assert(isObject(state), "expected state to be an object");
      var type = node.parent ? node.parent.type : node.type.replace(/\.close$/, "");
      if (state.inside.hasOwnProperty(type)) {
        return state.inside[type].pop();
      }
    };
    utils.isEmpty = function(node, fn) {
      assert(utils.isNode(node), "expected node to be an instance of Node");
      if (!Array.isArray(node.nodes)) {
        if (node.type !== "text") {
          return true;
        }
        if (typeof fn === "function") {
          return fn(node, node.parent);
        }
        return !utils.trim(node.val);
      }
      for (var i = 0; i < node.nodes.length; i++) {
        var child = node.nodes[i];
        if (utils.isOpen(child) || utils.isClose(child)) {
          continue;
        }
        if (!utils.isEmpty(child, fn)) {
          return false;
        }
      }
      return true;
    };
    utils.isInsideType = function(state, type) {
      assert(isObject(state), "expected state to be an object");
      assert(isString(type), "expected type to be a string");
      if (!state.hasOwnProperty("inside")) {
        return false;
      }
      if (!state.inside.hasOwnProperty(type)) {
        return false;
      }
      return state.inside[type].length > 0;
    };
    utils.isInside = function(state, node, type) {
      assert(utils.isNode(node), "expected node to be an instance of Node");
      assert(isObject(state), "expected state to be an object");
      if (Array.isArray(type)) {
        for (var i = 0; i < type.length; i++) {
          if (utils.isInside(state, node, type[i])) {
            return true;
          }
        }
        return false;
      }
      var parent = node.parent;
      if (typeof type === "string") {
        return parent && parent.type === type || utils.isInsideType(state, type);
      }
      if (typeOf(type) === "regexp") {
        if (parent && parent.type && type.test(parent.type)) {
          return true;
        }
        var keys = Object.keys(state.inside);
        var len = keys.length;
        var idx = -1;
        while (++idx < len) {
          var key = keys[idx];
          var val = state.inside[key];
          if (Array.isArray(val) && val.length !== 0 && type.test(key)) {
            return true;
          }
        }
      }
      return false;
    };
    utils.last = function(arr, n) {
      return arr[arr.length - (n || 1)];
    };
    utils.arrayify = function(val) {
      if (typeof val === "string" && val !== "") {
        return [val];
      }
      if (!Array.isArray(val)) {
        return [];
      }
      return val;
    };
    utils.stringify = function(val) {
      return utils.arrayify(val).join(",");
    };
    utils.trim = function(str) {
      return typeof str === "string" ? str.trim() : "";
    };
    function isObject(val) {
      return typeOf(val) === "object";
    }
    function isString(val) {
      return typeof val === "string";
    }
    function isFunction(val) {
      return typeof val === "function";
    }
    function isArray(val) {
      return Array.isArray(val);
    }
    function append(compiler, val, node) {
      if (typeof compiler.append !== "function") {
        return compiler.emit(val, node);
      }
      return compiler.append(val, node);
    }
    function assert(val, message) {
      if (!val)
        throw new Error(message);
    }
  }
});

// node_modules/snapdragon-node/index.js
var require_snapdragon_node = __commonJS({
  "node_modules/snapdragon-node/index.js"(exports, module2) {
    "use strict";
    var isObject = require_isobject();
    var define2 = require_define_property3();
    var utils = require_snapdragon_util();
    var ownNames;
    function Node(val, type, parent) {
      if (typeof type !== "string") {
        parent = type;
        type = null;
      }
      define2(this, "parent", parent);
      define2(this, "isNode", true);
      define2(this, "expect", null);
      if (typeof type !== "string" && isObject(val)) {
        lazyKeys();
        var keys = Object.keys(val);
        for (var i = 0; i < keys.length; i++) {
          var key = keys[i];
          if (ownNames.indexOf(key) === -1) {
            this[key] = val[key];
          }
        }
      } else {
        this.type = type;
        this.val = val;
      }
    }
    Node.isNode = function(node) {
      return utils.isNode(node);
    };
    Node.prototype.define = function(name, val) {
      define2(this, name, val);
      return this;
    };
    Node.prototype.isEmpty = function(fn) {
      return utils.isEmpty(this, fn);
    };
    Node.prototype.push = function(node) {
      assert(Node.isNode(node), "expected node to be an instance of Node");
      define2(node, "parent", this);
      this.nodes = this.nodes || [];
      return this.nodes.push(node);
    };
    Node.prototype.unshift = function(node) {
      assert(Node.isNode(node), "expected node to be an instance of Node");
      define2(node, "parent", this);
      this.nodes = this.nodes || [];
      return this.nodes.unshift(node);
    };
    Node.prototype.pop = function() {
      return this.nodes && this.nodes.pop();
    };
    Node.prototype.shift = function() {
      return this.nodes && this.nodes.shift();
    };
    Node.prototype.remove = function(node) {
      assert(Node.isNode(node), "expected node to be an instance of Node");
      this.nodes = this.nodes || [];
      var idx = node.index;
      if (idx !== -1) {
        node.index = -1;
        return this.nodes.splice(idx, 1);
      }
      return null;
    };
    Node.prototype.find = function(type) {
      return utils.findNode(this.nodes, type);
    };
    Node.prototype.isType = function(type) {
      return utils.isType(this, type);
    };
    Node.prototype.hasType = function(type) {
      return utils.hasType(this, type);
    };
    Object.defineProperty(Node.prototype, "siblings", {
      set: function() {
        throw new Error("node.siblings is a getter and cannot be defined");
      },
      get: function() {
        return this.parent ? this.parent.nodes : null;
      }
    });
    Object.defineProperty(Node.prototype, "index", {
      set: function(index) {
        define2(this, "idx", index);
      },
      get: function() {
        if (!Array.isArray(this.siblings)) {
          return -1;
        }
        var tok = this.idx !== -1 ? this.siblings[this.idx] : null;
        if (tok !== this) {
          this.idx = this.siblings.indexOf(this);
        }
        return this.idx;
      }
    });
    Object.defineProperty(Node.prototype, "prev", {
      set: function() {
        throw new Error("node.prev is a getter and cannot be defined");
      },
      get: function() {
        if (Array.isArray(this.siblings)) {
          return this.siblings[this.index - 1] || this.parent.prev;
        }
        return null;
      }
    });
    Object.defineProperty(Node.prototype, "next", {
      set: function() {
        throw new Error("node.next is a getter and cannot be defined");
      },
      get: function() {
        if (Array.isArray(this.siblings)) {
          return this.siblings[this.index + 1] || this.parent.next;
        }
        return null;
      }
    });
    Object.defineProperty(Node.prototype, "first", {
      get: function() {
        return this.nodes ? this.nodes[0] : null;
      }
    });
    Object.defineProperty(Node.prototype, "last", {
      get: function() {
        return this.nodes ? utils.last(this.nodes) : null;
      }
    });
    Object.defineProperty(Node.prototype, "scope", {
      get: function() {
        if (this.isScope !== true) {
          return this.parent ? this.parent.scope : this;
        }
        return this;
      }
    });
    function lazyKeys() {
      if (!ownNames) {
        ownNames = Object.getOwnPropertyNames(Node.prototype);
      }
    }
    function assert(val, message) {
      if (!val)
        throw new Error(message);
    }
    exports = module2.exports = Node;
  }
});

// node_modules/braces/lib/parsers.js
var require_parsers = __commonJS({
  "node_modules/braces/lib/parsers.js"(exports, module2) {
    "use strict";
    var Node = require_snapdragon_node();
    var utils = require_utils3();
    module2.exports = function(braces, options) {
      braces.parser.set("bos", function() {
        if (!this.parsed) {
          this.ast = this.nodes[0] = new Node(this.ast);
        }
      }).set("escape", function() {
        var pos = this.position();
        var m = this.match(/^(?:\\(.)|\$\{)/);
        if (!m)
          return;
        var prev = this.prev();
        var last = utils.last(prev.nodes);
        var node = pos(new Node({
          type: "text",
          multiplier: 1,
          val: m[0]
        }));
        if (node.val === "\\\\") {
          return node;
        }
        if (node.val === "${") {
          var str = this.input;
          var idx = -1;
          var ch;
          while (ch = str[++idx]) {
            this.consume(1);
            node.val += ch;
            if (ch === "\\") {
              node.val += str[++idx];
              continue;
            }
            if (ch === "}") {
              break;
            }
          }
        }
        if (this.options.unescape !== false) {
          node.val = node.val.replace(/\\([{}])/g, "$1");
        }
        if (last.val === '"' && this.input.charAt(0) === '"') {
          last.val = node.val;
          this.consume(1);
          return;
        }
        return concatNodes.call(this, pos, node, prev, options);
      }).set("bracket", function() {
        var isInside = this.isInside("brace");
        var pos = this.position();
        var m = this.match(/^(?:\[([!^]?)([^\]]{2,}|\]-)(\]|[^*+?]+)|\[)/);
        if (!m)
          return;
        var prev = this.prev();
        var val = m[0];
        var negated = m[1] ? "^" : "";
        var inner = m[2] || "";
        var close = m[3] || "";
        if (isInside && prev.type === "brace") {
          prev.text = prev.text || "";
          prev.text += val;
        }
        var esc = this.input.slice(0, 2);
        if (inner === "" && esc === "\\]") {
          inner += esc;
          this.consume(2);
          var str = this.input;
          var idx = -1;
          var ch;
          while (ch = str[++idx]) {
            this.consume(1);
            if (ch === "]") {
              close = ch;
              break;
            }
            inner += ch;
          }
        }
        return pos(new Node({
          type: "bracket",
          val,
          escaped: close !== "]",
          negated,
          inner,
          close
        }));
      }).set("multiplier", function() {
        var isInside = this.isInside("brace");
        var pos = this.position();
        var m = this.match(/^\{((?:,|\{,+\})+)\}/);
        if (!m)
          return;
        this.multiplier = true;
        var prev = this.prev();
        var val = m[0];
        if (isInside && prev.type === "brace") {
          prev.text = prev.text || "";
          prev.text += val;
        }
        var node = pos(new Node({
          type: "text",
          multiplier: 1,
          match: m,
          val
        }));
        return concatNodes.call(this, pos, node, prev, options);
      }).set("brace.open", function() {
        var pos = this.position();
        var m = this.match(/^\{(?!(?:[^\\}]?|,+)\})/);
        if (!m)
          return;
        var prev = this.prev();
        var last = utils.last(prev.nodes);
        if (last && last.val && isExtglobChar(last.val.slice(-1))) {
          last.optimize = false;
        }
        var open = pos(new Node({
          type: "brace.open",
          val: m[0]
        }));
        var node = pos(new Node({
          type: "brace",
          nodes: []
        }));
        node.push(open);
        prev.push(node);
        this.push("brace", node);
      }).set("brace.close", function() {
        var pos = this.position();
        var m = this.match(/^\}/);
        if (!m || !m[0])
          return;
        var brace = this.pop("brace");
        var node = pos(new Node({
          type: "brace.close",
          val: m[0]
        }));
        if (!this.isType(brace, "brace")) {
          if (this.options.strict) {
            throw new Error('missing opening "{"');
          }
          node.type = "text";
          node.multiplier = 0;
          node.escaped = true;
          return node;
        }
        var prev = this.prev();
        var last = utils.last(prev.nodes);
        if (last.text) {
          var lastNode = utils.last(last.nodes);
          if (lastNode.val === ")" && /[!@*?+]\(/.test(last.text)) {
            var open = last.nodes[0];
            var text = last.nodes[1];
            if (open.type === "brace.open" && text && text.type === "text") {
              text.optimize = false;
            }
          }
        }
        if (brace.nodes.length > 2) {
          var first = brace.nodes[1];
          if (first.type === "text" && first.val === ",") {
            brace.nodes.splice(1, 1);
            brace.nodes.push(first);
          }
        }
        brace.push(node);
      }).set("boundary", function() {
        var pos = this.position();
        var m = this.match(/^[$^](?!\{)/);
        if (!m)
          return;
        return pos(new Node({
          type: "text",
          val: m[0]
        }));
      }).set("nobrace", function() {
        var isInside = this.isInside("brace");
        var pos = this.position();
        var m = this.match(/^\{[^,]?\}/);
        if (!m)
          return;
        var prev = this.prev();
        var val = m[0];
        if (isInside && prev.type === "brace") {
          prev.text = prev.text || "";
          prev.text += val;
        }
        return pos(new Node({
          type: "text",
          multiplier: 0,
          val
        }));
      }).set("text", function() {
        var isInside = this.isInside("brace");
        var pos = this.position();
        var m = this.match(/^((?!\\)[^${}[\]])+/);
        if (!m)
          return;
        var prev = this.prev();
        var val = m[0];
        if (isInside && prev.type === "brace") {
          prev.text = prev.text || "";
          prev.text += val;
        }
        var node = pos(new Node({
          type: "text",
          multiplier: 1,
          val
        }));
        return concatNodes.call(this, pos, node, prev, options);
      });
    };
    function isExtglobChar(ch) {
      return ch === "!" || ch === "@" || ch === "*" || ch === "?" || ch === "+";
    }
    function concatNodes(pos, node, parent, options) {
      node.orig = node.val;
      var prev = this.prev();
      var last = utils.last(prev.nodes);
      var isEscaped = false;
      if (node.val.length > 1) {
        var a = node.val.charAt(0);
        var b = node.val.slice(-1);
        isEscaped = a === '"' && b === '"' || a === "'" && b === "'" || a === "`" && b === "`";
      }
      if (isEscaped && options.unescape !== false) {
        node.val = node.val.slice(1, node.val.length - 1);
        node.escaped = true;
      }
      if (node.match) {
        var match = node.match[1];
        if (!match || match.indexOf("}") === -1) {
          match = node.match[0];
        }
        var val = match.replace(/\{/g, ",").replace(/\}/g, "");
        node.multiplier *= val.length;
        node.val = "";
      }
      var simpleText = last.type === "text" && last.multiplier === 1 && node.multiplier === 1 && node.val;
      if (simpleText) {
        last.val += node.val;
        return;
      }
      prev.push(node);
    }
  }
});

// node_modules/base/node_modules/define-property/index.js
var require_define_property4 = __commonJS({
  "node_modules/base/node_modules/define-property/index.js"(exports, module2) {
    "use strict";
    var isDescriptor = require_is_descriptor();
    module2.exports = function defineProperty(obj, prop, val) {
      if (typeof obj !== "object" && typeof obj !== "function") {
        throw new TypeError("expected an object or function.");
      }
      if (typeof prop !== "string") {
        throw new TypeError("expected `prop` to be a string.");
      }
      if (isDescriptor(val) && ("set" in val || "get" in val)) {
        return Object.defineProperty(obj, prop, val);
      }
      return Object.defineProperty(obj, prop, {
        configurable: true,
        enumerable: false,
        writable: true,
        value: val
      });
    };
  }
});

// node_modules/component-emitter/index.js
var require_component_emitter = __commonJS({
  "node_modules/component-emitter/index.js"(exports, module2) {
    if (typeof module2 !== "undefined") {
      module2.exports = Emitter;
    }
    function Emitter(obj) {
      if (obj)
        return mixin(obj);
    }
    function mixin(obj) {
      for (var key in Emitter.prototype) {
        obj[key] = Emitter.prototype[key];
      }
      return obj;
    }
    Emitter.prototype.on = Emitter.prototype.addEventListener = function(event, fn) {
      this._callbacks = this._callbacks || {};
      (this._callbacks["$" + event] = this._callbacks["$" + event] || []).push(fn);
      return this;
    };
    Emitter.prototype.once = function(event, fn) {
      function on() {
        this.off(event, on);
        fn.apply(this, arguments);
      }
      on.fn = fn;
      this.on(event, on);
      return this;
    };
    Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function(event, fn) {
      this._callbacks = this._callbacks || {};
      if (arguments.length == 0) {
        this._callbacks = {};
        return this;
      }
      var callbacks = this._callbacks["$" + event];
      if (!callbacks)
        return this;
      if (arguments.length == 1) {
        delete this._callbacks["$" + event];
        return this;
      }
      var cb;
      for (var i = 0; i < callbacks.length; i++) {
        cb = callbacks[i];
        if (cb === fn || cb.fn === fn) {
          callbacks.splice(i, 1);
          break;
        }
      }
      if (callbacks.length === 0) {
        delete this._callbacks["$" + event];
      }
      return this;
    };
    Emitter.prototype.emit = function(event) {
      this._callbacks = this._callbacks || {};
      var args = new Array(arguments.length - 1), callbacks = this._callbacks["$" + event];
      for (var i = 1; i < arguments.length; i++) {
        args[i - 1] = arguments[i];
      }
      if (callbacks) {
        callbacks = callbacks.slice(0);
        for (var i = 0, len = callbacks.length; i < len; ++i) {
          callbacks[i].apply(this, args);
        }
      }
      return this;
    };
    Emitter.prototype.listeners = function(event) {
      this._callbacks = this._callbacks || {};
      return this._callbacks["$" + event] || [];
    };
    Emitter.prototype.hasListeners = function(event) {
      return !!this.listeners(event).length;
    };
  }
});

// node_modules/object-visit/index.js
var require_object_visit = __commonJS({
  "node_modules/object-visit/index.js"(exports, module2) {
    "use strict";
    var isObject = require_isobject();
    module2.exports = function visit(thisArg, method, target, val) {
      if (!isObject(thisArg) && typeof thisArg !== "function") {
        throw new Error("object-visit expects `thisArg` to be an object.");
      }
      if (typeof method !== "string") {
        throw new Error("object-visit expects `method` name to be a string");
      }
      if (typeof thisArg[method] !== "function") {
        return thisArg;
      }
      var args = [].slice.call(arguments, 3);
      target = target || {};
      for (var key in target) {
        var arr = [key, target[key]].concat(args);
        thisArg[method].apply(thisArg, arr);
      }
      return thisArg;
    };
  }
});

// node_modules/map-visit/index.js
var require_map_visit = __commonJS({
  "node_modules/map-visit/index.js"(exports, module2) {
    "use strict";
    var util = require("util");
    var visit = require_object_visit();
    module2.exports = function mapVisit(collection, method, val) {
      if (isObject(val)) {
        return visit.apply(null, arguments);
      }
      if (!Array.isArray(val)) {
        throw new TypeError("expected an array: " + util.inspect(val));
      }
      var args = [].slice.call(arguments, 3);
      for (var i = 0; i < val.length; i++) {
        var ele = val[i];
        if (isObject(ele)) {
          visit.apply(null, [collection, method, ele].concat(args));
        } else {
          collection[method].apply(collection, [ele].concat(args));
        }
      }
    };
    function isObject(val) {
      return val && (typeof val === "function" || !Array.isArray(val) && typeof val === "object");
    }
  }
});

// node_modules/collection-visit/index.js
var require_collection_visit = __commonJS({
  "node_modules/collection-visit/index.js"(exports, module2) {
    "use strict";
    var visit = require_object_visit();
    var mapVisit = require_map_visit();
    module2.exports = function(collection, method, val) {
      var result;
      if (typeof val === "string" && method in collection) {
        var args = [].slice.call(arguments, 2);
        result = collection[method].apply(collection, args);
      } else if (Array.isArray(val)) {
        result = mapVisit.apply(null, arguments);
      } else {
        result = visit.apply(null, arguments);
      }
      if (typeof result !== "undefined") {
        return result;
      }
      return collection;
    };
  }
});

// node_modules/to-object-path/node_modules/kind-of/index.js
var require_kind_of8 = __commonJS({
  "node_modules/to-object-path/node_modules/kind-of/index.js"(exports, module2) {
    var isBuffer = require_is_buffer();
    var toString = Object.prototype.toString;
    module2.exports = function kindOf(val) {
      if (typeof val === "undefined") {
        return "undefined";
      }
      if (val === null) {
        return "null";
      }
      if (val === true || val === false || val instanceof Boolean) {
        return "boolean";
      }
      if (typeof val === "string" || val instanceof String) {
        return "string";
      }
      if (typeof val === "number" || val instanceof Number) {
        return "number";
      }
      if (typeof val === "function" || val instanceof Function) {
        return "function";
      }
      if (typeof Array.isArray !== "undefined" && Array.isArray(val)) {
        return "array";
      }
      if (val instanceof RegExp) {
        return "regexp";
      }
      if (val instanceof Date) {
        return "date";
      }
      var type = toString.call(val);
      if (type === "[object RegExp]") {
        return "regexp";
      }
      if (type === "[object Date]") {
        return "date";
      }
      if (type === "[object Arguments]") {
        return "arguments";
      }
      if (type === "[object Error]") {
        return "error";
      }
      if (isBuffer(val)) {
        return "buffer";
      }
      if (type === "[object Set]") {
        return "set";
      }
      if (type === "[object WeakSet]") {
        return "weakset";
      }
      if (type === "[object Map]") {
        return "map";
      }
      if (type === "[object WeakMap]") {
        return "weakmap";
      }
      if (type === "[object Symbol]") {
        return "symbol";
      }
      if (type === "[object Int8Array]") {
        return "int8array";
      }
      if (type === "[object Uint8Array]") {
        return "uint8array";
      }
      if (type === "[object Uint8ClampedArray]") {
        return "uint8clampedarray";
      }
      if (type === "[object Int16Array]") {
        return "int16array";
      }
      if (type === "[object Uint16Array]") {
        return "uint16array";
      }
      if (type === "[object Int32Array]") {
        return "int32array";
      }
      if (type === "[object Uint32Array]") {
        return "uint32array";
      }
      if (type === "[object Float32Array]") {
        return "float32array";
      }
      if (type === "[object Float64Array]") {
        return "float64array";
      }
      return "object";
    };
  }
});

// node_modules/to-object-path/index.js
var require_to_object_path = __commonJS({
  "node_modules/to-object-path/index.js"(exports, module2) {
    "use strict";
    var typeOf = require_kind_of8();
    module2.exports = function toPath(args) {
      if (typeOf(args) !== "arguments") {
        args = arguments;
      }
      return filter(args).join(".");
    };
    function filter(arr) {
      var len = arr.length;
      var idx = -1;
      var res = [];
      while (++idx < len) {
        var ele = arr[idx];
        if (typeOf(ele) === "arguments" || Array.isArray(ele)) {
          res.push.apply(res, filter(ele));
        } else if (typeof ele === "string") {
          res.push(ele);
        }
      }
      return res;
    }
  }
});

// node_modules/arr-union/index.js
var require_arr_union = __commonJS({
  "node_modules/arr-union/index.js"(exports, module2) {
    "use strict";
    module2.exports = function union(init) {
      if (!Array.isArray(init)) {
        throw new TypeError("arr-union expects the first argument to be an array.");
      }
      var len = arguments.length;
      var i = 0;
      while (++i < len) {
        var arg = arguments[i];
        if (!arg)
          continue;
        if (!Array.isArray(arg)) {
          arg = [arg];
        }
        for (var j = 0; j < arg.length; j++) {
          var ele = arg[j];
          if (init.indexOf(ele) >= 0) {
            continue;
          }
          init.push(ele);
        }
      }
      return init;
    };
  }
});

// node_modules/set-value/index.js
var require_set_value = __commonJS({
  "node_modules/set-value/index.js"(exports, module2) {
    "use strict";
    var split = require_split_string();
    var extend = require_extend_shallow4();
    var isPlainObject = require_is_plain_object();
    var isObject = require_is_extendable4();
    module2.exports = function(obj, prop, val) {
      if (!isObject(obj)) {
        return obj;
      }
      if (Array.isArray(prop)) {
        prop = [].concat.apply([], prop).join(".");
      }
      if (typeof prop !== "string") {
        return obj;
      }
      var keys = split(prop, { sep: ".", brackets: true }).filter(isValidKey);
      var len = keys.length;
      var idx = -1;
      var current = obj;
      while (++idx < len) {
        var key = keys[idx];
        if (idx !== len - 1) {
          if (!isObject(current[key])) {
            current[key] = {};
          }
          current = current[key];
          continue;
        }
        if (isPlainObject(current[key]) && isPlainObject(val)) {
          current[key] = extend({}, current[key], val);
        } else {
          current[key] = val;
        }
      }
      return obj;
    };
    function isValidKey(key) {
      return key !== "__proto__" && key !== "constructor" && key !== "prototype";
    }
  }
});

// node_modules/union-value/index.js
var require_union_value = __commonJS({
  "node_modules/union-value/index.js"(exports, module2) {
    "use strict";
    var isObject = require_is_extendable4();
    var union = require_arr_union();
    var get = require_get_value();
    var set = require_set_value();
    module2.exports = function unionValue(obj, prop, value2) {
      if (!isObject(obj)) {
        throw new TypeError("union-value expects the first argument to be an object.");
      }
      if (typeof prop !== "string") {
        throw new TypeError("union-value expects `prop` to be a string.");
      }
      var arr = arrayify(get(obj, prop));
      set(obj, prop, union(arr, arrayify(value2)));
      return obj;
    };
    function arrayify(val) {
      if (val === null || typeof val === "undefined") {
        return [];
      }
      if (Array.isArray(val)) {
        return val;
      }
      return [val];
    }
  }
});

// node_modules/isarray/index.js
var require_isarray = __commonJS({
  "node_modules/isarray/index.js"(exports, module2) {
    var toString = {}.toString;
    module2.exports = Array.isArray || function(arr) {
      return toString.call(arr) == "[object Array]";
    };
  }
});

// node_modules/unset-value/node_modules/has-value/node_modules/isobject/index.js
var require_isobject2 = __commonJS({
  "node_modules/unset-value/node_modules/has-value/node_modules/isobject/index.js"(exports, module2) {
    "use strict";
    var isArray = require_isarray();
    module2.exports = function isObject(val) {
      return val != null && typeof val === "object" && isArray(val) === false;
    };
  }
});

// node_modules/unset-value/node_modules/has-values/index.js
var require_has_values2 = __commonJS({
  "node_modules/unset-value/node_modules/has-values/index.js"(exports, module2) {
    "use strict";
    module2.exports = function hasValue(o, noZero) {
      if (o === null || o === void 0) {
        return false;
      }
      if (typeof o === "boolean") {
        return true;
      }
      if (typeof o === "number") {
        if (o === 0 && noZero === true) {
          return false;
        }
        return true;
      }
      if (o.length !== void 0) {
        return o.length !== 0;
      }
      for (var key in o) {
        if (o.hasOwnProperty(key)) {
          return true;
        }
      }
      return false;
    };
  }
});

// node_modules/unset-value/node_modules/has-value/index.js
var require_has_value2 = __commonJS({
  "node_modules/unset-value/node_modules/has-value/index.js"(exports, module2) {
    "use strict";
    var isObject = require_isobject2();
    var hasValues = require_has_values2();
    var get = require_get_value();
    module2.exports = function(obj, prop, noZero) {
      if (isObject(obj)) {
        return hasValues(get(obj, prop), noZero);
      }
      return hasValues(obj, prop);
    };
  }
});

// node_modules/unset-value/index.js
var require_unset_value = __commonJS({
  "node_modules/unset-value/index.js"(exports, module2) {
    "use strict";
    var isObject = require_isobject();
    var has = require_has_value2();
    module2.exports = function unset(obj, prop) {
      if (!isObject(obj)) {
        throw new TypeError("expected an object.");
      }
      if (obj.hasOwnProperty(prop)) {
        delete obj[prop];
        return true;
      }
      if (has(obj, prop)) {
        var segs = prop.split(".");
        var last = segs.pop();
        while (segs.length && segs[segs.length - 1].slice(-1) === "\\") {
          last = segs.pop().slice(0, -1) + "." + last;
        }
        while (segs.length)
          obj = obj[prop = segs.shift()];
        return delete obj[last];
      }
      return true;
    };
  }
});

// node_modules/cache-base/node_modules/kind-of/index.js
var require_kind_of9 = __commonJS({
  "node_modules/cache-base/node_modules/kind-of/index.js"(exports, module2) {
    var isBuffer = require_is_buffer();
    var toString = Object.prototype.toString;
    module2.exports = function kindOf(val) {
      if (typeof val === "undefined") {
        return "undefined";
      }
      if (val === null) {
        return "null";
      }
      if (val === true || val === false || val instanceof Boolean) {
        return "boolean";
      }
      if (typeof val === "string" || val instanceof String) {
        return "string";
      }
      if (typeof val === "number" || val instanceof Number) {
        return "number";
      }
      if (typeof val === "function" || val instanceof Function) {
        return "function";
      }
      if (typeof Array.isArray !== "undefined" && Array.isArray(val)) {
        return "array";
      }
      if (val instanceof RegExp) {
        return "regexp";
      }
      if (val instanceof Date) {
        return "date";
      }
      var type = toString.call(val);
      if (type === "[object RegExp]") {
        return "regexp";
      }
      if (type === "[object Date]") {
        return "date";
      }
      if (type === "[object Arguments]") {
        return "arguments";
      }
      if (type === "[object Error]") {
        return "error";
      }
      if (type === "[object Promise]") {
        return "promise";
      }
      if (isBuffer(val)) {
        return "buffer";
      }
      if (type === "[object Set]") {
        return "set";
      }
      if (type === "[object WeakSet]") {
        return "weakset";
      }
      if (type === "[object Map]") {
        return "map";
      }
      if (type === "[object WeakMap]") {
        return "weakmap";
      }
      if (type === "[object Symbol]") {
        return "symbol";
      }
      if (type === "[object Int8Array]") {
        return "int8array";
      }
      if (type === "[object Uint8Array]") {
        return "uint8array";
      }
      if (type === "[object Uint8ClampedArray]") {
        return "uint8clampedarray";
      }
      if (type === "[object Int16Array]") {
        return "int16array";
      }
      if (type === "[object Uint16Array]") {
        return "uint16array";
      }
      if (type === "[object Int32Array]") {
        return "int32array";
      }
      if (type === "[object Uint32Array]") {
        return "uint32array";
      }
      if (type === "[object Float32Array]") {
        return "float32array";
      }
      if (type === "[object Float64Array]") {
        return "float64array";
      }
      return "object";
    };
  }
});

// node_modules/cache-base/node_modules/has-values/index.js
var require_has_values3 = __commonJS({
  "node_modules/cache-base/node_modules/has-values/index.js"(exports, module2) {
    "use strict";
    var typeOf = require_kind_of9();
    var isNumber = require_is_number2();
    module2.exports = function hasValue(val) {
      if (isNumber(val)) {
        return true;
      }
      switch (typeOf(val)) {
        case "null":
        case "boolean":
        case "function":
          return true;
        case "string":
        case "arguments":
          return val.length !== 0;
        case "error":
          return val.message !== "";
        case "array":
          var len = val.length;
          if (len === 0) {
            return false;
          }
          for (var i = 0; i < len; i++) {
            if (hasValue(val[i])) {
              return true;
            }
          }
          return false;
        case "file":
        case "map":
        case "set":
          return val.size !== 0;
        case "object":
          var keys = Object.keys(val);
          if (keys.length === 0) {
            return false;
          }
          for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            if (hasValue(val[key])) {
              return true;
            }
          }
          return false;
        default: {
          return false;
        }
      }
    };
  }
});

// node_modules/cache-base/node_modules/has-value/index.js
var require_has_value3 = __commonJS({
  "node_modules/cache-base/node_modules/has-value/index.js"(exports, module2) {
    "use strict";
    var isObject = require_isobject();
    var hasValues = require_has_values3();
    var get = require_get_value();
    module2.exports = function(val, prop) {
      return hasValues(isObject(val) && prop ? get(val, prop) : val);
    };
  }
});

// node_modules/cache-base/index.js
var require_cache_base = __commonJS({
  "node_modules/cache-base/index.js"(exports, module2) {
    "use strict";
    var isObject = require_isobject();
    var Emitter = require_component_emitter();
    var visit = require_collection_visit();
    var toPath = require_to_object_path();
    var union = require_union_value();
    var del = require_unset_value();
    var get = require_get_value();
    var has = require_has_value3();
    var set = require_set_value();
    function namespace(prop) {
      function Cache(cache) {
        if (prop) {
          this[prop] = {};
        }
        if (cache) {
          this.set(cache);
        }
      }
      Emitter(Cache.prototype);
      Cache.prototype.set = function(key, val) {
        if (Array.isArray(key) && arguments.length === 2) {
          key = toPath(key);
        }
        if (isObject(key) || Array.isArray(key)) {
          this.visit("set", key);
        } else {
          set(prop ? this[prop] : this, key, val);
          this.emit("set", key, val);
        }
        return this;
      };
      Cache.prototype.union = function(key, val) {
        if (Array.isArray(key) && arguments.length === 2) {
          key = toPath(key);
        }
        var ctx = prop ? this[prop] : this;
        union(ctx, key, arrayify(val));
        this.emit("union", val);
        return this;
      };
      Cache.prototype.get = function(key) {
        key = toPath(arguments);
        var ctx = prop ? this[prop] : this;
        var val = get(ctx, key);
        this.emit("get", key, val);
        return val;
      };
      Cache.prototype.has = function(key) {
        key = toPath(arguments);
        var ctx = prop ? this[prop] : this;
        var val = get(ctx, key);
        var has2 = typeof val !== "undefined";
        this.emit("has", key, has2);
        return has2;
      };
      Cache.prototype.del = function(key) {
        if (Array.isArray(key)) {
          this.visit("del", key);
        } else {
          del(prop ? this[prop] : this, key);
          this.emit("del", key);
        }
        return this;
      };
      Cache.prototype.clear = function() {
        if (prop) {
          this[prop] = {};
        }
      };
      Cache.prototype.visit = function(method, val) {
        visit(this, method, val);
        return this;
      };
      return Cache;
    }
    function arrayify(val) {
      return val ? Array.isArray(val) ? val : [val] : [];
    }
    module2.exports = namespace();
    module2.exports.namespace = namespace;
  }
});

// node_modules/mixin-deep/node_modules/is-extendable/index.js
var require_is_extendable6 = __commonJS({
  "node_modules/mixin-deep/node_modules/is-extendable/index.js"(exports, module2) {
    "use strict";
    var isPlainObject = require_is_plain_object();
    module2.exports = function isExtendable(val) {
      return isPlainObject(val) || typeof val === "function" || Array.isArray(val);
    };
  }
});

// node_modules/mixin-deep/index.js
var require_mixin_deep = __commonJS({
  "node_modules/mixin-deep/index.js"(exports, module2) {
    "use strict";
    var isExtendable = require_is_extendable6();
    var forIn = require_for_in();
    function mixinDeep(target, objects) {
      var len = arguments.length, i = 0;
      while (++i < len) {
        var obj = arguments[i];
        if (isObject(obj)) {
          forIn(obj, copy, target);
        }
      }
      return target;
    }
    function copy(val, key) {
      if (!isValidKey(key)) {
        return;
      }
      var obj = this[key];
      if (isObject(val) && isObject(obj)) {
        mixinDeep(obj, val);
      } else {
        this[key] = val;
      }
    }
    function isObject(val) {
      return isExtendable(val) && !Array.isArray(val);
    }
    function isValidKey(key) {
      return key !== "__proto__" && key !== "constructor" && key !== "prototype";
    }
    module2.exports = mixinDeep;
  }
});

// node_modules/pascalcase/index.js
var require_pascalcase = __commonJS({
  "node_modules/pascalcase/index.js"(exports, module2) {
    function pascalcase(str) {
      if (typeof str !== "string") {
        throw new TypeError("expected a string.");
      }
      str = str.replace(/([A-Z])/g, " $1");
      if (str.length === 1) {
        return str.toUpperCase();
      }
      str = str.replace(/^[\W_]+|[\W_]+$/g, "").toLowerCase();
      str = str.charAt(0).toUpperCase() + str.slice(1);
      return str.replace(/[\W_]+(\w|$)/g, function(_, ch) {
        return ch.toUpperCase();
      });
    }
    module2.exports = pascalcase;
  }
});

// node_modules/define-property/node_modules/kind-of/index.js
var require_kind_of10 = __commonJS({
  "node_modules/define-property/node_modules/kind-of/index.js"(exports, module2) {
    var toString = Object.prototype.toString;
    module2.exports = function kindOf(val) {
      var type = typeof val;
      if (type === "undefined") {
        return "undefined";
      }
      if (val === null) {
        return "null";
      }
      if (val === true || val === false || val instanceof Boolean) {
        return "boolean";
      }
      if (type === "string" || val instanceof String) {
        return "string";
      }
      if (type === "number" || val instanceof Number) {
        return "number";
      }
      if (type === "function" || val instanceof Function) {
        if (typeof val.constructor.name !== "undefined" && val.constructor.name.slice(0, 9) === "Generator") {
          return "generatorfunction";
        }
        return "function";
      }
      if (typeof Array.isArray !== "undefined" && Array.isArray(val)) {
        return "array";
      }
      if (val instanceof RegExp) {
        return "regexp";
      }
      if (val instanceof Date) {
        return "date";
      }
      type = toString.call(val);
      if (type === "[object RegExp]") {
        return "regexp";
      }
      if (type === "[object Date]") {
        return "date";
      }
      if (type === "[object Arguments]") {
        return "arguments";
      }
      if (type === "[object Error]") {
        return "error";
      }
      if (type === "[object Promise]") {
        return "promise";
      }
      if (isBuffer(val)) {
        return "buffer";
      }
      if (type === "[object Set]") {
        return "set";
      }
      if (type === "[object WeakSet]") {
        return "weakset";
      }
      if (type === "[object Map]") {
        return "map";
      }
      if (type === "[object WeakMap]") {
        return "weakmap";
      }
      if (type === "[object Symbol]") {
        return "symbol";
      }
      if (type === "[object Map Iterator]") {
        return "mapiterator";
      }
      if (type === "[object Set Iterator]") {
        return "setiterator";
      }
      if (type === "[object String Iterator]") {
        return "stringiterator";
      }
      if (type === "[object Array Iterator]") {
        return "arrayiterator";
      }
      if (type === "[object Int8Array]") {
        return "int8array";
      }
      if (type === "[object Uint8Array]") {
        return "uint8array";
      }
      if (type === "[object Uint8ClampedArray]") {
        return "uint8clampedarray";
      }
      if (type === "[object Int16Array]") {
        return "int16array";
      }
      if (type === "[object Uint16Array]") {
        return "uint16array";
      }
      if (type === "[object Int32Array]") {
        return "int32array";
      }
      if (type === "[object Uint32Array]") {
        return "uint32array";
      }
      if (type === "[object Float32Array]") {
        return "float32array";
      }
      if (type === "[object Float64Array]") {
        return "float64array";
      }
      return "object";
    };
    function isBuffer(val) {
      return val.constructor && typeof val.constructor.isBuffer === "function" && val.constructor.isBuffer(val);
    }
  }
});

// node_modules/define-property/node_modules/is-accessor-descriptor/node_modules/kind-of/index.js
var require_kind_of11 = __commonJS({
  "node_modules/define-property/node_modules/is-accessor-descriptor/node_modules/kind-of/index.js"(exports, module2) {
    var isBuffer = require_is_buffer();
    var toString = Object.prototype.toString;
    module2.exports = function kindOf(val) {
      if (typeof val === "undefined") {
        return "undefined";
      }
      if (val === null) {
        return "null";
      }
      if (val === true || val === false || val instanceof Boolean) {
        return "boolean";
      }
      if (typeof val === "string" || val instanceof String) {
        return "string";
      }
      if (typeof val === "number" || val instanceof Number) {
        return "number";
      }
      if (typeof val === "function" || val instanceof Function) {
        return "function";
      }
      if (typeof Array.isArray !== "undefined" && Array.isArray(val)) {
        return "array";
      }
      if (val instanceof RegExp) {
        return "regexp";
      }
      if (val instanceof Date) {
        return "date";
      }
      var type = toString.call(val);
      if (type === "[object RegExp]") {
        return "regexp";
      }
      if (type === "[object Date]") {
        return "date";
      }
      if (type === "[object Arguments]") {
        return "arguments";
      }
      if (type === "[object Error]") {
        return "error";
      }
      if (isBuffer(val)) {
        return "buffer";
      }
      if (type === "[object Set]") {
        return "set";
      }
      if (type === "[object WeakSet]") {
        return "weakset";
      }
      if (type === "[object Map]") {
        return "map";
      }
      if (type === "[object WeakMap]") {
        return "weakmap";
      }
      if (type === "[object Symbol]") {
        return "symbol";
      }
      if (type === "[object Int8Array]") {
        return "int8array";
      }
      if (type === "[object Uint8Array]") {
        return "uint8array";
      }
      if (type === "[object Uint8ClampedArray]") {
        return "uint8clampedarray";
      }
      if (type === "[object Int16Array]") {
        return "int16array";
      }
      if (type === "[object Uint16Array]") {
        return "uint16array";
      }
      if (type === "[object Int32Array]") {
        return "int32array";
      }
      if (type === "[object Uint32Array]") {
        return "uint32array";
      }
      if (type === "[object Float32Array]") {
        return "float32array";
      }
      if (type === "[object Float64Array]") {
        return "float64array";
      }
      return "object";
    };
  }
});

// node_modules/define-property/node_modules/is-accessor-descriptor/index.js
var require_is_accessor_descriptor2 = __commonJS({
  "node_modules/define-property/node_modules/is-accessor-descriptor/index.js"(exports, module2) {
    "use strict";
    var typeOf = require_kind_of11();
    var accessor = {
      get: "function",
      set: "function",
      configurable: "boolean",
      enumerable: "boolean"
    };
    function isAccessorDescriptor(obj, prop) {
      if (typeof prop === "string") {
        var val = Object.getOwnPropertyDescriptor(obj, prop);
        return typeof val !== "undefined";
      }
      if (typeOf(obj) !== "object") {
        return false;
      }
      if (has(obj, "value") || has(obj, "writable")) {
        return false;
      }
      if (!has(obj, "get") || typeof obj.get !== "function") {
        return false;
      }
      if (has(obj, "set") && typeof obj[key] !== "function" && typeof obj[key] !== "undefined") {
        return false;
      }
      for (var key in obj) {
        if (!accessor.hasOwnProperty(key)) {
          continue;
        }
        if (typeOf(obj[key]) === accessor[key]) {
          continue;
        }
        if (typeof obj[key] !== "undefined") {
          return false;
        }
      }
      return true;
    }
    function has(obj, key) {
      return {}.hasOwnProperty.call(obj, key);
    }
    module2.exports = isAccessorDescriptor;
  }
});

// node_modules/define-property/node_modules/is-data-descriptor/node_modules/kind-of/index.js
var require_kind_of12 = __commonJS({
  "node_modules/define-property/node_modules/is-data-descriptor/node_modules/kind-of/index.js"(exports, module2) {
    var isBuffer = require_is_buffer();
    var toString = Object.prototype.toString;
    module2.exports = function kindOf(val) {
      if (typeof val === "undefined") {
        return "undefined";
      }
      if (val === null) {
        return "null";
      }
      if (val === true || val === false || val instanceof Boolean) {
        return "boolean";
      }
      if (typeof val === "string" || val instanceof String) {
        return "string";
      }
      if (typeof val === "number" || val instanceof Number) {
        return "number";
      }
      if (typeof val === "function" || val instanceof Function) {
        return "function";
      }
      if (typeof Array.isArray !== "undefined" && Array.isArray(val)) {
        return "array";
      }
      if (val instanceof RegExp) {
        return "regexp";
      }
      if (val instanceof Date) {
        return "date";
      }
      var type = toString.call(val);
      if (type === "[object RegExp]") {
        return "regexp";
      }
      if (type === "[object Date]") {
        return "date";
      }
      if (type === "[object Arguments]") {
        return "arguments";
      }
      if (type === "[object Error]") {
        return "error";
      }
      if (isBuffer(val)) {
        return "buffer";
      }
      if (type === "[object Set]") {
        return "set";
      }
      if (type === "[object WeakSet]") {
        return "weakset";
      }
      if (type === "[object Map]") {
        return "map";
      }
      if (type === "[object WeakMap]") {
        return "weakmap";
      }
      if (type === "[object Symbol]") {
        return "symbol";
      }
      if (type === "[object Int8Array]") {
        return "int8array";
      }
      if (type === "[object Uint8Array]") {
        return "uint8array";
      }
      if (type === "[object Uint8ClampedArray]") {
        return "uint8clampedarray";
      }
      if (type === "[object Int16Array]") {
        return "int16array";
      }
      if (type === "[object Uint16Array]") {
        return "uint16array";
      }
      if (type === "[object Int32Array]") {
        return "int32array";
      }
      if (type === "[object Uint32Array]") {
        return "uint32array";
      }
      if (type === "[object Float32Array]") {
        return "float32array";
      }
      if (type === "[object Float64Array]") {
        return "float64array";
      }
      return "object";
    };
  }
});

// node_modules/define-property/node_modules/is-data-descriptor/index.js
var require_is_data_descriptor2 = __commonJS({
  "node_modules/define-property/node_modules/is-data-descriptor/index.js"(exports, module2) {
    "use strict";
    var typeOf = require_kind_of12();
    var data = {
      configurable: "boolean",
      enumerable: "boolean",
      writable: "boolean"
    };
    function isDataDescriptor(obj, prop) {
      if (typeOf(obj) !== "object") {
        return false;
      }
      if (typeof prop === "string") {
        var val = Object.getOwnPropertyDescriptor(obj, prop);
        return typeof val !== "undefined";
      }
      if (!("value" in obj) && !("writable" in obj)) {
        return false;
      }
      for (var key in obj) {
        if (key === "value")
          continue;
        if (!data.hasOwnProperty(key)) {
          continue;
        }
        if (typeOf(obj[key]) === data[key]) {
          continue;
        }
        if (typeof obj[key] !== "undefined") {
          return false;
        }
      }
      return true;
    }
    module2.exports = isDataDescriptor;
  }
});

// node_modules/define-property/node_modules/is-descriptor/index.js
var require_is_descriptor2 = __commonJS({
  "node_modules/define-property/node_modules/is-descriptor/index.js"(exports, module2) {
    "use strict";
    var typeOf = require_kind_of10();
    var isAccessor = require_is_accessor_descriptor2();
    var isData = require_is_data_descriptor2();
    module2.exports = function isDescriptor(obj, key) {
      if (typeOf(obj) !== "object") {
        return false;
      }
      if ("get" in obj) {
        return isAccessor(obj, key);
      }
      return isData(obj, key);
    };
  }
});

// node_modules/define-property/index.js
var require_define_property5 = __commonJS({
  "node_modules/define-property/index.js"(exports, module2) {
    "use strict";
    var isDescriptor = require_is_descriptor2();
    module2.exports = function defineProperty(obj, prop, val) {
      if (typeof obj !== "object" && typeof obj !== "function") {
        throw new TypeError("expected an object or function.");
      }
      if (typeof prop !== "string") {
        throw new TypeError("expected `prop` to be a string.");
      }
      if (isDescriptor(val) && ("set" in val || "get" in val)) {
        return Object.defineProperty(obj, prop, val);
      }
      return Object.defineProperty(obj, prop, {
        configurable: true,
        enumerable: false,
        writable: true,
        value: val
      });
    };
  }
});

// node_modules/object-copy/node_modules/kind-of/index.js
var require_kind_of13 = __commonJS({
  "node_modules/object-copy/node_modules/kind-of/index.js"(exports, module2) {
    var isBuffer = require_is_buffer();
    var toString = Object.prototype.toString;
    module2.exports = function kindOf(val) {
      if (typeof val === "undefined") {
        return "undefined";
      }
      if (val === null) {
        return "null";
      }
      if (val === true || val === false || val instanceof Boolean) {
        return "boolean";
      }
      if (typeof val === "string" || val instanceof String) {
        return "string";
      }
      if (typeof val === "number" || val instanceof Number) {
        return "number";
      }
      if (typeof val === "function" || val instanceof Function) {
        return "function";
      }
      if (typeof Array.isArray !== "undefined" && Array.isArray(val)) {
        return "array";
      }
      if (val instanceof RegExp) {
        return "regexp";
      }
      if (val instanceof Date) {
        return "date";
      }
      var type = toString.call(val);
      if (type === "[object RegExp]") {
        return "regexp";
      }
      if (type === "[object Date]") {
        return "date";
      }
      if (type === "[object Arguments]") {
        return "arguments";
      }
      if (type === "[object Error]") {
        return "error";
      }
      if (isBuffer(val)) {
        return "buffer";
      }
      if (type === "[object Set]") {
        return "set";
      }
      if (type === "[object WeakSet]") {
        return "weakset";
      }
      if (type === "[object Map]") {
        return "map";
      }
      if (type === "[object WeakMap]") {
        return "weakmap";
      }
      if (type === "[object Symbol]") {
        return "symbol";
      }
      if (type === "[object Int8Array]") {
        return "int8array";
      }
      if (type === "[object Uint8Array]") {
        return "uint8array";
      }
      if (type === "[object Uint8ClampedArray]") {
        return "uint8clampedarray";
      }
      if (type === "[object Int16Array]") {
        return "int16array";
      }
      if (type === "[object Uint16Array]") {
        return "uint16array";
      }
      if (type === "[object Int32Array]") {
        return "int32array";
      }
      if (type === "[object Uint32Array]") {
        return "uint32array";
      }
      if (type === "[object Float32Array]") {
        return "float32array";
      }
      if (type === "[object Float64Array]") {
        return "float64array";
      }
      return "object";
    };
  }
});

// node_modules/copy-descriptor/index.js
var require_copy_descriptor = __commonJS({
  "node_modules/copy-descriptor/index.js"(exports, module2) {
    "use strict";
    module2.exports = function copyDescriptor(receiver, provider, from, to) {
      if (!isObject(provider) && typeof provider !== "function") {
        to = from;
        from = provider;
        provider = receiver;
      }
      if (!isObject(receiver) && typeof receiver !== "function") {
        throw new TypeError("expected the first argument to be an object");
      }
      if (!isObject(provider) && typeof provider !== "function") {
        throw new TypeError("expected provider to be an object");
      }
      if (typeof to !== "string") {
        to = from;
      }
      if (typeof from !== "string") {
        throw new TypeError("expected key to be a string");
      }
      if (!(from in provider)) {
        throw new Error('property "' + from + '" does not exist');
      }
      var val = Object.getOwnPropertyDescriptor(provider, from);
      if (val)
        Object.defineProperty(receiver, to, val);
    };
    function isObject(val) {
      return {}.toString.call(val) === "[object Object]";
    }
  }
});

// node_modules/object-copy/index.js
var require_object_copy = __commonJS({
  "node_modules/object-copy/index.js"(exports, module2) {
    "use strict";
    var typeOf = require_kind_of13();
    var copyDescriptor = require_copy_descriptor();
    var define2 = require_define_property5();
    function copy(receiver, provider, omit) {
      if (!isObject(receiver)) {
        throw new TypeError("expected receiving object to be an object.");
      }
      if (!isObject(provider)) {
        throw new TypeError("expected providing object to be an object.");
      }
      var props = nativeKeys(provider);
      var keys = Object.keys(provider);
      var len = props.length;
      omit = arrayify(omit);
      while (len--) {
        var key = props[len];
        if (has(keys, key)) {
          define2(receiver, key, provider[key]);
        } else if (!(key in receiver) && !has(omit, key)) {
          copyDescriptor(receiver, provider, key);
        }
      }
    }
    function isObject(val) {
      return typeOf(val) === "object" || typeof val === "function";
    }
    function has(obj, val) {
      val = arrayify(val);
      var len = val.length;
      if (isObject(obj)) {
        for (var key in obj) {
          if (val.indexOf(key) > -1) {
            return true;
          }
        }
        var keys = nativeKeys(obj);
        return has(keys, val);
      }
      if (Array.isArray(obj)) {
        var arr = obj;
        while (len--) {
          if (arr.indexOf(val[len]) > -1) {
            return true;
          }
        }
        return false;
      }
      throw new TypeError("expected an array or object.");
    }
    function arrayify(val) {
      return val ? Array.isArray(val) ? val : [val] : [];
    }
    function hasConstructor(val) {
      return isObject(val) && typeof val.constructor !== "undefined";
    }
    function nativeKeys(val) {
      if (!hasConstructor(val))
        return [];
      return Object.getOwnPropertyNames(val);
    }
    module2.exports = copy;
    module2.exports.has = has;
  }
});

// node_modules/static-extend/index.js
var require_static_extend = __commonJS({
  "node_modules/static-extend/index.js"(exports, module2) {
    "use strict";
    var copy = require_object_copy();
    var define2 = require_define_property5();
    var util = require("util");
    function extend(Parent, extendFn) {
      if (typeof Parent !== "function") {
        throw new TypeError("expected Parent to be a function.");
      }
      return function(Ctor, proto) {
        if (typeof Ctor !== "function") {
          throw new TypeError("expected Ctor to be a function.");
        }
        util.inherits(Ctor, Parent);
        copy(Ctor, Parent);
        if (typeof proto === "object") {
          var obj = Object.create(proto);
          for (var k in obj) {
            Ctor.prototype[k] = obj[k];
          }
        }
        define2(Ctor.prototype, "_parent_", {
          configurable: true,
          set: function() {
          },
          get: function() {
            return Parent.prototype;
          }
        });
        if (typeof extendFn === "function") {
          extendFn(Ctor, Parent);
        }
        Ctor.extend = extend(Ctor, extendFn);
      };
    }
    module2.exports = extend;
  }
});

// node_modules/class-utils/index.js
var require_class_utils = __commonJS({
  "node_modules/class-utils/index.js"(exports, module2) {
    "use strict";
    var util = require("util");
    var union = require_arr_union();
    var define2 = require_define_property5();
    var staticExtend = require_static_extend();
    var isObj = require_isobject();
    var cu = module2.exports;
    cu.isObject = function isObject(val) {
      return isObj(val) || typeof val === "function";
    };
    cu.has = function has(obj, val) {
      val = cu.arrayify(val);
      var len = val.length;
      if (cu.isObject(obj)) {
        for (var key in obj) {
          if (val.indexOf(key) > -1) {
            return true;
          }
        }
        var keys = cu.nativeKeys(obj);
        return cu.has(keys, val);
      }
      if (Array.isArray(obj)) {
        var arr = obj;
        while (len--) {
          if (arr.indexOf(val[len]) > -1) {
            return true;
          }
        }
        return false;
      }
      throw new TypeError("expected an array or object.");
    };
    cu.hasAll = function hasAll(val, values) {
      values = cu.arrayify(values);
      var len = values.length;
      while (len--) {
        if (!cu.has(val, values[len])) {
          return false;
        }
      }
      return true;
    };
    cu.arrayify = function arrayify(val) {
      return val ? Array.isArray(val) ? val : [val] : [];
    };
    cu.noop = function noop() {
      return;
    };
    cu.identity = function identity(val) {
      return val;
    };
    cu.hasConstructor = function hasConstructor(val) {
      return cu.isObject(val) && typeof val.constructor !== "undefined";
    };
    cu.nativeKeys = function nativeKeys(val) {
      if (!cu.hasConstructor(val))
        return [];
      var keys = Object.getOwnPropertyNames(val);
      if ("caller" in val)
        keys.push("caller");
      return keys;
    };
    cu.getDescriptor = function getDescriptor(obj, key) {
      if (!cu.isObject(obj)) {
        throw new TypeError("expected an object.");
      }
      if (typeof key !== "string") {
        throw new TypeError("expected key to be a string.");
      }
      return Object.getOwnPropertyDescriptor(obj, key);
    };
    cu.copyDescriptor = function copyDescriptor(receiver, provider, name) {
      if (!cu.isObject(receiver)) {
        throw new TypeError("expected receiving object to be an object.");
      }
      if (!cu.isObject(provider)) {
        throw new TypeError("expected providing object to be an object.");
      }
      if (typeof name !== "string") {
        throw new TypeError("expected name to be a string.");
      }
      var val = cu.getDescriptor(provider, name);
      if (val)
        Object.defineProperty(receiver, name, val);
    };
    cu.copy = function copy(receiver, provider, omit) {
      if (!cu.isObject(receiver)) {
        throw new TypeError("expected receiving object to be an object.");
      }
      if (!cu.isObject(provider)) {
        throw new TypeError("expected providing object to be an object.");
      }
      var props = Object.getOwnPropertyNames(provider);
      var keys = Object.keys(provider);
      var len = props.length, key;
      omit = cu.arrayify(omit);
      while (len--) {
        key = props[len];
        if (cu.has(keys, key)) {
          define2(receiver, key, provider[key]);
        } else if (!(key in receiver) && !cu.has(omit, key)) {
          cu.copyDescriptor(receiver, provider, key);
        }
      }
    };
    cu.inherit = function inherit(receiver, provider, omit) {
      if (!cu.isObject(receiver)) {
        throw new TypeError("expected receiving object to be an object.");
      }
      if (!cu.isObject(provider)) {
        throw new TypeError("expected providing object to be an object.");
      }
      var keys = [];
      for (var key in provider) {
        keys.push(key);
        receiver[key] = provider[key];
      }
      keys = keys.concat(cu.arrayify(omit));
      var a = provider.prototype || provider;
      var b = receiver.prototype || receiver;
      cu.copy(b, a, keys);
    };
    cu.extend = function() {
      return staticExtend.apply(null, arguments);
    };
    cu.bubble = function(Parent, events) {
      events = events || [];
      Parent.bubble = function(Child, arr) {
        if (Array.isArray(arr)) {
          events = union([], events, arr);
        }
        var len = events.length;
        var idx = -1;
        while (++idx < len) {
          var name = events[idx];
          Parent.on(name, Child.emit.bind(Child, name));
        }
        cu.bubble(Child, events);
      };
    };
  }
});

// node_modules/base/index.js
var require_base3 = __commonJS({
  "node_modules/base/index.js"(exports, module2) {
    "use strict";
    var util = require("util");
    var define2 = require_define_property4();
    var CacheBase = require_cache_base();
    var Emitter = require_component_emitter();
    var isObject = require_isobject();
    var merge = require_mixin_deep();
    var pascal = require_pascalcase();
    var cu = require_class_utils();
    function namespace(name) {
      var Cache = name ? CacheBase.namespace(name) : CacheBase;
      var fns = [];
      function Base(config, options) {
        if (!(this instanceof Base)) {
          return new Base(config, options);
        }
        Cache.call(this, config);
        this.is("base");
        this.initBase(config, options);
      }
      util.inherits(Base, Cache);
      Emitter(Base);
      Base.prototype.initBase = function(config, options) {
        this.options = merge({}, this.options, options);
        this.cache = this.cache || {};
        this.define("registered", {});
        if (name)
          this[name] = {};
        this.define("_callbacks", this._callbacks);
        if (isObject(config)) {
          this.visit("set", config);
        }
        Base.run(this, "use", fns);
      };
      Base.prototype.is = function(name2) {
        if (typeof name2 !== "string") {
          throw new TypeError("expected name to be a string");
        }
        this.define("is" + pascal(name2), true);
        this.define("_name", name2);
        this.define("_appname", name2);
        return this;
      };
      Base.prototype.isRegistered = function(name2, register) {
        if (this.registered.hasOwnProperty(name2)) {
          return true;
        }
        if (register !== false) {
          this.registered[name2] = true;
          this.emit("plugin", name2);
        }
        return false;
      };
      Base.prototype.use = function(fn) {
        fn.call(this, this);
        return this;
      };
      Base.prototype.define = function(key, val) {
        if (isObject(key)) {
          return this.visit("define", key);
        }
        define2(this, key, val);
        return this;
      };
      Base.prototype.mixin = function(key, val) {
        Base.prototype[key] = val;
        return this;
      };
      Base.prototype.mixins = Base.prototype.mixins || [];
      Object.defineProperty(Base.prototype, "base", {
        configurable: true,
        get: function() {
          return this.parent ? this.parent.base : this;
        }
      });
      define2(Base, "use", function(fn) {
        fns.push(fn);
        return Base;
      });
      define2(Base, "run", function(obj, prop, arr) {
        var len = arr.length, i = 0;
        while (len--) {
          obj[prop](arr[i++]);
        }
        return Base;
      });
      define2(Base, "extend", cu.extend(Base, function(Ctor, Parent) {
        Ctor.prototype.mixins = Ctor.prototype.mixins || [];
        define2(Ctor, "mixin", function(fn) {
          var mixin = fn(Ctor.prototype, Ctor);
          if (typeof mixin === "function") {
            Ctor.prototype.mixins.push(mixin);
          }
          return Ctor;
        });
        define2(Ctor, "mixins", function(Child) {
          Base.run(Child, "mixin", Ctor.prototype.mixins);
          return Ctor;
        });
        Ctor.prototype.mixin = function(key, value2) {
          Ctor.prototype[key] = value2;
          return this;
        };
        return Base;
      }));
      define2(Base, "mixin", function(fn) {
        var mixin = fn(Base.prototype, Base);
        if (typeof mixin === "function") {
          Base.prototype.mixins.push(mixin);
        }
        return Base;
      });
      define2(Base, "mixins", function(Child) {
        Base.run(Child, "mixin", Base.prototype.mixins);
        return Base;
      });
      define2(Base, "inherit", cu.inherit);
      define2(Base, "bubble", cu.bubble);
      return Base;
    }
    module2.exports = namespace();
    module2.exports.namespace = namespace;
  }
});

// node_modules/use/index.js
var require_use = __commonJS({
  "node_modules/use/index.js"(exports, module2) {
    "use strict";
    module2.exports = function base(app, options) {
      if (!isObject(app) && typeof app !== "function") {
        throw new TypeError("expected an object or function");
      }
      var opts = isObject(options) ? options : {};
      var prop = typeof opts.prop === "string" ? opts.prop : "fns";
      if (!Array.isArray(app[prop])) {
        define2(app, prop, []);
      }
      define2(app, "use", use);
      define2(app, "run", function(val) {
        if (!isObject(val))
          return;
        if (!val.use || !val.run) {
          define2(val, prop, val[prop] || []);
          define2(val, "use", use);
        }
        if (!val[prop] || val[prop].indexOf(base) === -1) {
          val.use(base);
        }
        var self2 = this || app;
        var fns = self2[prop];
        var len = fns.length;
        var idx = -1;
        while (++idx < len) {
          val.use(fns[idx]);
        }
        return val;
      });
      function use(type, fn, options2) {
        var offset = 1;
        if (typeof type === "string" || Array.isArray(type)) {
          fn = wrap(type, fn);
          offset++;
        } else {
          options2 = fn;
          fn = type;
        }
        if (typeof fn !== "function") {
          throw new TypeError("expected a function");
        }
        var self2 = this || app;
        var fns = self2[prop];
        var args = [].slice.call(arguments, offset);
        args.unshift(self2);
        if (typeof opts.hook === "function") {
          opts.hook.apply(self2, args);
        }
        var val = fn.apply(self2, args);
        if (typeof val === "function" && fns.indexOf(val) === -1) {
          fns.push(val);
        }
        return self2;
      }
      function wrap(type, fn) {
        return function plugin() {
          return this.type === type ? fn.apply(this, arguments) : plugin;
        };
      }
      return app;
    };
    function isObject(val) {
      return val && typeof val === "object" && !Array.isArray(val);
    }
    function define2(obj, key, val) {
      Object.defineProperty(obj, key, {
        configurable: true,
        writable: true,
        value: val
      });
    }
  }
});

// node_modules/snapdragon/node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/snapdragon/node_modules/ms/index.js"(exports, module2) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isNaN(val) === false) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      if (ms >= d) {
        return Math.round(ms / d) + "d";
      }
      if (ms >= h) {
        return Math.round(ms / h) + "h";
      }
      if (ms >= m) {
        return Math.round(ms / m) + "m";
      }
      if (ms >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      return plural(ms, d, "day") || plural(ms, h, "hour") || plural(ms, m, "minute") || plural(ms, s, "second") || ms + " ms";
    }
    function plural(ms, n, name) {
      if (ms < n) {
        return;
      }
      if (ms < n * 1.5) {
        return Math.floor(ms / n) + " " + name;
      }
      return Math.ceil(ms / n) + " " + name + "s";
    }
  }
});

// node_modules/snapdragon/node_modules/debug/src/debug.js
var require_debug = __commonJS({
  "node_modules/snapdragon/node_modules/debug/src/debug.js"(exports, module2) {
    exports = module2.exports = createDebug.debug = createDebug["default"] = createDebug;
    exports.coerce = coerce;
    exports.disable = disable;
    exports.enable = enable;
    exports.enabled = enabled;
    exports.humanize = require_ms();
    exports.names = [];
    exports.skips = [];
    exports.formatters = {};
    var prevTime;
    function selectColor(namespace) {
      var hash = 0, i;
      for (i in namespace) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return exports.colors[Math.abs(hash) % exports.colors.length];
    }
    function createDebug(namespace) {
      function debug() {
        if (!debug.enabled)
          return;
        var self2 = debug;
        var curr = +new Date();
        var ms = curr - (prevTime || curr);
        self2.diff = ms;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        args[0] = exports.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        var index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
          if (match === "%%")
            return match;
          index++;
          var formatter = exports.formatters[format];
          if (typeof formatter === "function") {
            var val = args[index];
            match = formatter.call(self2, val);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        exports.formatArgs.call(self2, args);
        var logFn = debug.log || exports.log || console.log.bind(console);
        logFn.apply(self2, args);
      }
      debug.namespace = namespace;
      debug.enabled = exports.enabled(namespace);
      debug.useColors = exports.useColors();
      debug.color = selectColor(namespace);
      if (typeof exports.init === "function") {
        exports.init(debug);
      }
      return debug;
    }
    function enable(namespaces) {
      exports.save(namespaces);
      exports.names = [];
      exports.skips = [];
      var split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      var len = split.length;
      for (var i = 0; i < len; i++) {
        if (!split[i])
          continue;
        namespaces = split[i].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          exports.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
        } else {
          exports.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
    }
    function disable() {
      exports.enable("");
    }
    function enabled(name) {
      var i, len;
      for (i = 0, len = exports.skips.length; i < len; i++) {
        if (exports.skips[i].test(name)) {
          return false;
        }
      }
      for (i = 0, len = exports.names.length; i < len; i++) {
        if (exports.names[i].test(name)) {
          return true;
        }
      }
      return false;
    }
    function coerce(val) {
      if (val instanceof Error)
        return val.stack || val.message;
      return val;
    }
  }
});

// node_modules/snapdragon/node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/snapdragon/node_modules/debug/src/browser.js"(exports, module2) {
    exports = module2.exports = require_debug();
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = typeof chrome != "undefined" && typeof chrome.storage != "undefined" ? chrome.storage.local : localstorage();
    exports.colors = [
      "lightseagreen",
      "forestgreen",
      "goldenrod",
      "dodgerblue",
      "darkorchid",
      "crimson"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && window.process.type === "renderer") {
        return true;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    exports.formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (err) {
        return "[UnexpectedJSONParseError]: " + err.message;
      }
    };
    function formatArgs(args) {
      var useColors2 = this.useColors;
      args[0] = (useColors2 ? "%c" : "") + this.namespace + (useColors2 ? " %c" : " ") + args[0] + (useColors2 ? "%c " : " ") + "+" + exports.humanize(this.diff);
      if (!useColors2)
        return;
      var c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      var index = 0;
      var lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, function(match) {
        if (match === "%%")
          return;
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    function log() {
      return typeof console === "object" && console.log && Function.prototype.apply.call(console.log, console, arguments);
    }
    function save(namespaces) {
      try {
        if (namespaces == null) {
          exports.storage.removeItem("debug");
        } else {
          exports.storage.debug = namespaces;
        }
      } catch (e) {
      }
    }
    function load() {
      var r;
      try {
        r = exports.storage.debug;
      } catch (e) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    exports.enable(load());
    function localstorage() {
      try {
        return window.localStorage;
      } catch (e) {
      }
    }
  }
});

// node_modules/snapdragon/node_modules/source-map/lib/base64.js
var require_base642 = __commonJS({
  "node_modules/snapdragon/node_modules/source-map/lib/base64.js"(exports) {
    var intToCharMap = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
    exports.encode = function(number) {
      if (0 <= number && number < intToCharMap.length) {
        return intToCharMap[number];
      }
      throw new TypeError("Must be between 0 and 63: " + number);
    };
    exports.decode = function(charCode) {
      var bigA = 65;
      var bigZ = 90;
      var littleA = 97;
      var littleZ = 122;
      var zero = 48;
      var nine = 57;
      var plus = 43;
      var slash = 47;
      var littleOffset = 26;
      var numberOffset = 52;
      if (bigA <= charCode && charCode <= bigZ) {
        return charCode - bigA;
      }
      if (littleA <= charCode && charCode <= littleZ) {
        return charCode - littleA + littleOffset;
      }
      if (zero <= charCode && charCode <= nine) {
        return charCode - zero + numberOffset;
      }
      if (charCode == plus) {
        return 62;
      }
      if (charCode == slash) {
        return 63;
      }
      return -1;
    };
  }
});

// node_modules/snapdragon/node_modules/source-map/lib/base64-vlq.js
var require_base64_vlq2 = __commonJS({
  "node_modules/snapdragon/node_modules/source-map/lib/base64-vlq.js"(exports) {
    var base64 = require_base642();
    var VLQ_BASE_SHIFT = 5;
    var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
    var VLQ_BASE_MASK = VLQ_BASE - 1;
    var VLQ_CONTINUATION_BIT = VLQ_BASE;
    function toVLQSigned(aValue) {
      return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
    }
    function fromVLQSigned(aValue) {
      var isNegative = (aValue & 1) === 1;
      var shifted = aValue >> 1;
      return isNegative ? -shifted : shifted;
    }
    exports.encode = function base64VLQ_encode(aValue) {
      var encoded = "";
      var digit;
      var vlq = toVLQSigned(aValue);
      do {
        digit = vlq & VLQ_BASE_MASK;
        vlq >>>= VLQ_BASE_SHIFT;
        if (vlq > 0) {
          digit |= VLQ_CONTINUATION_BIT;
        }
        encoded += base64.encode(digit);
      } while (vlq > 0);
      return encoded;
    };
    exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
      var strLen = aStr.length;
      var result = 0;
      var shift = 0;
      var continuation, digit;
      do {
        if (aIndex >= strLen) {
          throw new Error("Expected more digits in base 64 VLQ value.");
        }
        digit = base64.decode(aStr.charCodeAt(aIndex++));
        if (digit === -1) {
          throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
        }
        continuation = !!(digit & VLQ_CONTINUATION_BIT);
        digit &= VLQ_BASE_MASK;
        result = result + (digit << shift);
        shift += VLQ_BASE_SHIFT;
      } while (continuation);
      aOutParam.value = fromVLQSigned(result);
      aOutParam.rest = aIndex;
    };
  }
});

// node_modules/snapdragon/node_modules/source-map/lib/util.js
var require_util3 = __commonJS({
  "node_modules/snapdragon/node_modules/source-map/lib/util.js"(exports) {
    function getArg(aArgs, aName, aDefaultValue) {
      if (aName in aArgs) {
        return aArgs[aName];
      } else if (arguments.length === 3) {
        return aDefaultValue;
      } else {
        throw new Error('"' + aName + '" is a required argument.');
      }
    }
    exports.getArg = getArg;
    var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.]*)(?::(\d+))?(\S*)$/;
    var dataUrlRegexp = /^data:.+\,.+$/;
    function urlParse(aUrl) {
      var match = aUrl.match(urlRegexp);
      if (!match) {
        return null;
      }
      return {
        scheme: match[1],
        auth: match[2],
        host: match[3],
        port: match[4],
        path: match[5]
      };
    }
    exports.urlParse = urlParse;
    function urlGenerate(aParsedUrl) {
      var url = "";
      if (aParsedUrl.scheme) {
        url += aParsedUrl.scheme + ":";
      }
      url += "//";
      if (aParsedUrl.auth) {
        url += aParsedUrl.auth + "@";
      }
      if (aParsedUrl.host) {
        url += aParsedUrl.host;
      }
      if (aParsedUrl.port) {
        url += ":" + aParsedUrl.port;
      }
      if (aParsedUrl.path) {
        url += aParsedUrl.path;
      }
      return url;
    }
    exports.urlGenerate = urlGenerate;
    function normalize(aPath) {
      var path = aPath;
      var url = urlParse(aPath);
      if (url) {
        if (!url.path) {
          return aPath;
        }
        path = url.path;
      }
      var isAbsolute = exports.isAbsolute(path);
      var parts = path.split(/\/+/);
      for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
        part = parts[i];
        if (part === ".") {
          parts.splice(i, 1);
        } else if (part === "..") {
          up++;
        } else if (up > 0) {
          if (part === "") {
            parts.splice(i + 1, up);
            up = 0;
          } else {
            parts.splice(i, 2);
            up--;
          }
        }
      }
      path = parts.join("/");
      if (path === "") {
        path = isAbsolute ? "/" : ".";
      }
      if (url) {
        url.path = path;
        return urlGenerate(url);
      }
      return path;
    }
    exports.normalize = normalize;
    function join(aRoot, aPath) {
      if (aRoot === "") {
        aRoot = ".";
      }
      if (aPath === "") {
        aPath = ".";
      }
      var aPathUrl = urlParse(aPath);
      var aRootUrl = urlParse(aRoot);
      if (aRootUrl) {
        aRoot = aRootUrl.path || "/";
      }
      if (aPathUrl && !aPathUrl.scheme) {
        if (aRootUrl) {
          aPathUrl.scheme = aRootUrl.scheme;
        }
        return urlGenerate(aPathUrl);
      }
      if (aPathUrl || aPath.match(dataUrlRegexp)) {
        return aPath;
      }
      if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
        aRootUrl.host = aPath;
        return urlGenerate(aRootUrl);
      }
      var joined = aPath.charAt(0) === "/" ? aPath : normalize(aRoot.replace(/\/+$/, "") + "/" + aPath);
      if (aRootUrl) {
        aRootUrl.path = joined;
        return urlGenerate(aRootUrl);
      }
      return joined;
    }
    exports.join = join;
    exports.isAbsolute = function(aPath) {
      return aPath.charAt(0) === "/" || !!aPath.match(urlRegexp);
    };
    function relative(aRoot, aPath) {
      if (aRoot === "") {
        aRoot = ".";
      }
      aRoot = aRoot.replace(/\/$/, "");
      var level = 0;
      while (aPath.indexOf(aRoot + "/") !== 0) {
        var index = aRoot.lastIndexOf("/");
        if (index < 0) {
          return aPath;
        }
        aRoot = aRoot.slice(0, index);
        if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
          return aPath;
        }
        ++level;
      }
      return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
    }
    exports.relative = relative;
    var supportsNullProto = function() {
      var obj = Object.create(null);
      return !("__proto__" in obj);
    }();
    function identity(s) {
      return s;
    }
    function toSetString(aStr) {
      if (isProtoString(aStr)) {
        return "$" + aStr;
      }
      return aStr;
    }
    exports.toSetString = supportsNullProto ? identity : toSetString;
    function fromSetString(aStr) {
      if (isProtoString(aStr)) {
        return aStr.slice(1);
      }
      return aStr;
    }
    exports.fromSetString = supportsNullProto ? identity : fromSetString;
    function isProtoString(s) {
      if (!s) {
        return false;
      }
      var length = s.length;
      if (length < 9) {
        return false;
      }
      if (s.charCodeAt(length - 1) !== 95 || s.charCodeAt(length - 2) !== 95 || s.charCodeAt(length - 3) !== 111 || s.charCodeAt(length - 4) !== 116 || s.charCodeAt(length - 5) !== 111 || s.charCodeAt(length - 6) !== 114 || s.charCodeAt(length - 7) !== 112 || s.charCodeAt(length - 8) !== 95 || s.charCodeAt(length - 9) !== 95) {
        return false;
      }
      for (var i = length - 10; i >= 0; i--) {
        if (s.charCodeAt(i) !== 36) {
          return false;
        }
      }
      return true;
    }
    function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
      var cmp = mappingA.source - mappingB.source;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0 || onlyCompareOriginal) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      return mappingA.name - mappingB.name;
    }
    exports.compareByOriginalPositions = compareByOriginalPositions;
    function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
      var cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0 || onlyCompareGenerated) {
        return cmp;
      }
      cmp = mappingA.source - mappingB.source;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0) {
        return cmp;
      }
      return mappingA.name - mappingB.name;
    }
    exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
    function strcmp(aStr1, aStr2) {
      if (aStr1 === aStr2) {
        return 0;
      }
      if (aStr1 > aStr2) {
        return 1;
      }
      return -1;
    }
    function compareByGeneratedPositionsInflated(mappingA, mappingB) {
      var cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
  }
});

// node_modules/snapdragon/node_modules/source-map/lib/array-set.js
var require_array_set2 = __commonJS({
  "node_modules/snapdragon/node_modules/source-map/lib/array-set.js"(exports) {
    var util = require_util3();
    var has = Object.prototype.hasOwnProperty;
    var hasNativeMap = typeof Map !== "undefined";
    function ArraySet() {
      this._array = [];
      this._set = hasNativeMap ? new Map() : Object.create(null);
    }
    ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
      var set = new ArraySet();
      for (var i = 0, len = aArray.length; i < len; i++) {
        set.add(aArray[i], aAllowDuplicates);
      }
      return set;
    };
    ArraySet.prototype.size = function ArraySet_size() {
      return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
    };
    ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
      var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
      var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
      var idx = this._array.length;
      if (!isDuplicate || aAllowDuplicates) {
        this._array.push(aStr);
      }
      if (!isDuplicate) {
        if (hasNativeMap) {
          this._set.set(aStr, idx);
        } else {
          this._set[sStr] = idx;
        }
      }
    };
    ArraySet.prototype.has = function ArraySet_has(aStr) {
      if (hasNativeMap) {
        return this._set.has(aStr);
      } else {
        var sStr = util.toSetString(aStr);
        return has.call(this._set, sStr);
      }
    };
    ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
      if (hasNativeMap) {
        var idx = this._set.get(aStr);
        if (idx >= 0) {
          return idx;
        }
      } else {
        var sStr = util.toSetString(aStr);
        if (has.call(this._set, sStr)) {
          return this._set[sStr];
        }
      }
      throw new Error('"' + aStr + '" is not in the set.');
    };
    ArraySet.prototype.at = function ArraySet_at(aIdx) {
      if (aIdx >= 0 && aIdx < this._array.length) {
        return this._array[aIdx];
      }
      throw new Error("No element indexed by " + aIdx);
    };
    ArraySet.prototype.toArray = function ArraySet_toArray() {
      return this._array.slice();
    };
    exports.ArraySet = ArraySet;
  }
});

// node_modules/snapdragon/node_modules/source-map/lib/mapping-list.js
var require_mapping_list2 = __commonJS({
  "node_modules/snapdragon/node_modules/source-map/lib/mapping-list.js"(exports) {
    var util = require_util3();
    function generatedPositionAfter(mappingA, mappingB) {
      var lineA = mappingA.generatedLine;
      var lineB = mappingB.generatedLine;
      var columnA = mappingA.generatedColumn;
      var columnB = mappingB.generatedColumn;
      return lineB > lineA || lineB == lineA && columnB >= columnA || util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
    }
    function MappingList() {
      this._array = [];
      this._sorted = true;
      this._last = { generatedLine: -1, generatedColumn: 0 };
    }
    MappingList.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {
      this._array.forEach(aCallback, aThisArg);
    };
    MappingList.prototype.add = function MappingList_add(aMapping) {
      if (generatedPositionAfter(this._last, aMapping)) {
        this._last = aMapping;
        this._array.push(aMapping);
      } else {
        this._sorted = false;
        this._array.push(aMapping);
      }
    };
    MappingList.prototype.toArray = function MappingList_toArray() {
      if (!this._sorted) {
        this._array.sort(util.compareByGeneratedPositionsInflated);
        this._sorted = true;
      }
      return this._array;
    };
    exports.MappingList = MappingList;
  }
});

// node_modules/snapdragon/node_modules/source-map/lib/source-map-generator.js
var require_source_map_generator2 = __commonJS({
  "node_modules/snapdragon/node_modules/source-map/lib/source-map-generator.js"(exports) {
    var base64VLQ = require_base64_vlq2();
    var util = require_util3();
    var ArraySet = require_array_set2().ArraySet;
    var MappingList = require_mapping_list2().MappingList;
    function SourceMapGenerator(aArgs) {
      if (!aArgs) {
        aArgs = {};
      }
      this._file = util.getArg(aArgs, "file", null);
      this._sourceRoot = util.getArg(aArgs, "sourceRoot", null);
      this._skipValidation = util.getArg(aArgs, "skipValidation", false);
      this._sources = new ArraySet();
      this._names = new ArraySet();
      this._mappings = new MappingList();
      this._sourcesContents = null;
    }
    SourceMapGenerator.prototype._version = 3;
    SourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
      var sourceRoot = aSourceMapConsumer.sourceRoot;
      var generator = new SourceMapGenerator({
        file: aSourceMapConsumer.file,
        sourceRoot
      });
      aSourceMapConsumer.eachMapping(function(mapping) {
        var newMapping = {
          generated: {
            line: mapping.generatedLine,
            column: mapping.generatedColumn
          }
        };
        if (mapping.source != null) {
          newMapping.source = mapping.source;
          if (sourceRoot != null) {
            newMapping.source = util.relative(sourceRoot, newMapping.source);
          }
          newMapping.original = {
            line: mapping.originalLine,
            column: mapping.originalColumn
          };
          if (mapping.name != null) {
            newMapping.name = mapping.name;
          }
        }
        generator.addMapping(newMapping);
      });
      aSourceMapConsumer.sources.forEach(function(sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
          generator.setSourceContent(sourceFile, content);
        }
      });
      return generator;
    };
    SourceMapGenerator.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {
      var generated = util.getArg(aArgs, "generated");
      var original = util.getArg(aArgs, "original", null);
      var source = util.getArg(aArgs, "source", null);
      var name = util.getArg(aArgs, "name", null);
      if (!this._skipValidation) {
        this._validateMapping(generated, original, source, name);
      }
      if (source != null) {
        source = String(source);
        if (!this._sources.has(source)) {
          this._sources.add(source);
        }
      }
      if (name != null) {
        name = String(name);
        if (!this._names.has(name)) {
          this._names.add(name);
        }
      }
      this._mappings.add({
        generatedLine: generated.line,
        generatedColumn: generated.column,
        originalLine: original != null && original.line,
        originalColumn: original != null && original.column,
        source,
        name
      });
    };
    SourceMapGenerator.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
      var source = aSourceFile;
      if (this._sourceRoot != null) {
        source = util.relative(this._sourceRoot, source);
      }
      if (aSourceContent != null) {
        if (!this._sourcesContents) {
          this._sourcesContents = Object.create(null);
        }
        this._sourcesContents[util.toSetString(source)] = aSourceContent;
      } else if (this._sourcesContents) {
        delete this._sourcesContents[util.toSetString(source)];
        if (Object.keys(this._sourcesContents).length === 0) {
          this._sourcesContents = null;
        }
      }
    };
    SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
      var sourceFile = aSourceFile;
      if (aSourceFile == null) {
        if (aSourceMapConsumer.file == null) {
          throw new Error(`SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's "file" property. Both were omitted.`);
        }
        sourceFile = aSourceMapConsumer.file;
      }
      var sourceRoot = this._sourceRoot;
      if (sourceRoot != null) {
        sourceFile = util.relative(sourceRoot, sourceFile);
      }
      var newSources = new ArraySet();
      var newNames = new ArraySet();
      this._mappings.unsortedForEach(function(mapping) {
        if (mapping.source === sourceFile && mapping.originalLine != null) {
          var original = aSourceMapConsumer.originalPositionFor({
            line: mapping.originalLine,
            column: mapping.originalColumn
          });
          if (original.source != null) {
            mapping.source = original.source;
            if (aSourceMapPath != null) {
              mapping.source = util.join(aSourceMapPath, mapping.source);
            }
            if (sourceRoot != null) {
              mapping.source = util.relative(sourceRoot, mapping.source);
            }
            mapping.originalLine = original.line;
            mapping.originalColumn = original.column;
            if (original.name != null) {
              mapping.name = original.name;
            }
          }
        }
        var source = mapping.source;
        if (source != null && !newSources.has(source)) {
          newSources.add(source);
        }
        var name = mapping.name;
        if (name != null && !newNames.has(name)) {
          newNames.add(name);
        }
      }, this);
      this._sources = newSources;
      this._names = newNames;
      aSourceMapConsumer.sources.forEach(function(sourceFile2) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile2);
        if (content != null) {
          if (aSourceMapPath != null) {
            sourceFile2 = util.join(aSourceMapPath, sourceFile2);
          }
          if (sourceRoot != null) {
            sourceFile2 = util.relative(sourceRoot, sourceFile2);
          }
          this.setSourceContent(sourceFile2, content);
        }
      }, this);
    };
    SourceMapGenerator.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {
      if (aOriginal && typeof aOriginal.line !== "number" && typeof aOriginal.column !== "number") {
        throw new Error("original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values.");
      }
      if (aGenerated && "line" in aGenerated && "column" in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {
        return;
      } else if (aGenerated && "line" in aGenerated && "column" in aGenerated && aOriginal && "line" in aOriginal && "column" in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {
        return;
      } else {
        throw new Error("Invalid mapping: " + JSON.stringify({
          generated: aGenerated,
          source: aSource,
          original: aOriginal,
          name: aName
        }));
      }
    };
    SourceMapGenerator.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
      var previousGeneratedColumn = 0;
      var previousGeneratedLine = 1;
      var previousOriginalColumn = 0;
      var previousOriginalLine = 0;
      var previousName = 0;
      var previousSource = 0;
      var result = "";
      var next;
      var mapping;
      var nameIdx;
      var sourceIdx;
      var mappings = this._mappings.toArray();
      for (var i = 0, len = mappings.length; i < len; i++) {
        mapping = mappings[i];
        next = "";
        if (mapping.generatedLine !== previousGeneratedLine) {
          previousGeneratedColumn = 0;
          while (mapping.generatedLine !== previousGeneratedLine) {
            next += ";";
            previousGeneratedLine++;
          }
        } else {
          if (i > 0) {
            if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
              continue;
            }
            next += ",";
          }
        }
        next += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);
        previousGeneratedColumn = mapping.generatedColumn;
        if (mapping.source != null) {
          sourceIdx = this._sources.indexOf(mapping.source);
          next += base64VLQ.encode(sourceIdx - previousSource);
          previousSource = sourceIdx;
          next += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine);
          previousOriginalLine = mapping.originalLine - 1;
          next += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);
          previousOriginalColumn = mapping.originalColumn;
          if (mapping.name != null) {
            nameIdx = this._names.indexOf(mapping.name);
            next += base64VLQ.encode(nameIdx - previousName);
            previousName = nameIdx;
          }
        }
        result += next;
      }
      return result;
    };
    SourceMapGenerator.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
      return aSources.map(function(source) {
        if (!this._sourcesContents) {
          return null;
        }
        if (aSourceRoot != null) {
          source = util.relative(aSourceRoot, source);
        }
        var key = util.toSetString(source);
        return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
      }, this);
    };
    SourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {
      var map = {
        version: this._version,
        sources: this._sources.toArray(),
        names: this._names.toArray(),
        mappings: this._serializeMappings()
      };
      if (this._file != null) {
        map.file = this._file;
      }
      if (this._sourceRoot != null) {
        map.sourceRoot = this._sourceRoot;
      }
      if (this._sourcesContents) {
        map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
      }
      return map;
    };
    SourceMapGenerator.prototype.toString = function SourceMapGenerator_toString() {
      return JSON.stringify(this.toJSON());
    };
    exports.SourceMapGenerator = SourceMapGenerator;
  }
});

// node_modules/snapdragon/node_modules/source-map/lib/binary-search.js
var require_binary_search2 = __commonJS({
  "node_modules/snapdragon/node_modules/source-map/lib/binary-search.js"(exports) {
    exports.GREATEST_LOWER_BOUND = 1;
    exports.LEAST_UPPER_BOUND = 2;
    function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
      var mid = Math.floor((aHigh - aLow) / 2) + aLow;
      var cmp = aCompare(aNeedle, aHaystack[mid], true);
      if (cmp === 0) {
        return mid;
      } else if (cmp > 0) {
        if (aHigh - mid > 1) {
          return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
        }
        if (aBias == exports.LEAST_UPPER_BOUND) {
          return aHigh < aHaystack.length ? aHigh : -1;
        } else {
          return mid;
        }
      } else {
        if (mid - aLow > 1) {
          return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
        }
        if (aBias == exports.LEAST_UPPER_BOUND) {
          return mid;
        } else {
          return aLow < 0 ? -1 : aLow;
        }
      }
    }
    exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
      if (aHaystack.length === 0) {
        return -1;
      }
      var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare, aBias || exports.GREATEST_LOWER_BOUND);
      if (index < 0) {
        return -1;
      }
      while (index - 1 >= 0) {
        if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
          break;
        }
        --index;
      }
      return index;
    };
  }
});

// node_modules/snapdragon/node_modules/source-map/lib/quick-sort.js
var require_quick_sort2 = __commonJS({
  "node_modules/snapdragon/node_modules/source-map/lib/quick-sort.js"(exports) {
    function swap(ary, x, y) {
      var temp = ary[x];
      ary[x] = ary[y];
      ary[y] = temp;
    }
    function randomIntInRange(low, high) {
      return Math.round(low + Math.random() * (high - low));
    }
    function doQuickSort(ary, comparator, p, r) {
      if (p < r) {
        var pivotIndex = randomIntInRange(p, r);
        var i = p - 1;
        swap(ary, pivotIndex, r);
        var pivot = ary[r];
        for (var j = p; j < r; j++) {
          if (comparator(ary[j], pivot) <= 0) {
            i += 1;
            swap(ary, i, j);
          }
        }
        swap(ary, i + 1, j);
        var q = i + 1;
        doQuickSort(ary, comparator, p, q - 1);
        doQuickSort(ary, comparator, q + 1, r);
      }
    }
    exports.quickSort = function(ary, comparator) {
      doQuickSort(ary, comparator, 0, ary.length - 1);
    };
  }
});

// node_modules/snapdragon/node_modules/source-map/lib/source-map-consumer.js
var require_source_map_consumer2 = __commonJS({
  "node_modules/snapdragon/node_modules/source-map/lib/source-map-consumer.js"(exports) {
    var util = require_util3();
    var binarySearch = require_binary_search2();
    var ArraySet = require_array_set2().ArraySet;
    var base64VLQ = require_base64_vlq2();
    var quickSort = require_quick_sort2().quickSort;
    function SourceMapConsumer(aSourceMap) {
      var sourceMap = aSourceMap;
      if (typeof aSourceMap === "string") {
        sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ""));
      }
      return sourceMap.sections != null ? new IndexedSourceMapConsumer(sourceMap) : new BasicSourceMapConsumer(sourceMap);
    }
    SourceMapConsumer.fromSourceMap = function(aSourceMap) {
      return BasicSourceMapConsumer.fromSourceMap(aSourceMap);
    };
    SourceMapConsumer.prototype._version = 3;
    SourceMapConsumer.prototype.__generatedMappings = null;
    Object.defineProperty(SourceMapConsumer.prototype, "_generatedMappings", {
      get: function() {
        if (!this.__generatedMappings) {
          this._parseMappings(this._mappings, this.sourceRoot);
        }
        return this.__generatedMappings;
      }
    });
    SourceMapConsumer.prototype.__originalMappings = null;
    Object.defineProperty(SourceMapConsumer.prototype, "_originalMappings", {
      get: function() {
        if (!this.__originalMappings) {
          this._parseMappings(this._mappings, this.sourceRoot);
        }
        return this.__originalMappings;
      }
    });
    SourceMapConsumer.prototype._charIsMappingSeparator = function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
      var c = aStr.charAt(index);
      return c === ";" || c === ",";
    };
    SourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      throw new Error("Subclasses must implement _parseMappings");
    };
    SourceMapConsumer.GENERATED_ORDER = 1;
    SourceMapConsumer.ORIGINAL_ORDER = 2;
    SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
    SourceMapConsumer.LEAST_UPPER_BOUND = 2;
    SourceMapConsumer.prototype.eachMapping = function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
      var context = aContext || null;
      var order = aOrder || SourceMapConsumer.GENERATED_ORDER;
      var mappings;
      switch (order) {
        case SourceMapConsumer.GENERATED_ORDER:
          mappings = this._generatedMappings;
          break;
        case SourceMapConsumer.ORIGINAL_ORDER:
          mappings = this._originalMappings;
          break;
        default:
          throw new Error("Unknown order of iteration.");
      }
      var sourceRoot = this.sourceRoot;
      mappings.map(function(mapping) {
        var source = mapping.source === null ? null : this._sources.at(mapping.source);
        if (source != null && sourceRoot != null) {
          source = util.join(sourceRoot, source);
        }
        return {
          source,
          generatedLine: mapping.generatedLine,
          generatedColumn: mapping.generatedColumn,
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name: mapping.name === null ? null : this._names.at(mapping.name)
        };
      }, this).forEach(aCallback, context);
    };
    SourceMapConsumer.prototype.allGeneratedPositionsFor = function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
      var line = util.getArg(aArgs, "line");
      var needle = {
        source: util.getArg(aArgs, "source"),
        originalLine: line,
        originalColumn: util.getArg(aArgs, "column", 0)
      };
      if (this.sourceRoot != null) {
        needle.source = util.relative(this.sourceRoot, needle.source);
      }
      if (!this._sources.has(needle.source)) {
        return [];
      }
      needle.source = this._sources.indexOf(needle.source);
      var mappings = [];
      var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util.compareByOriginalPositions, binarySearch.LEAST_UPPER_BOUND);
      if (index >= 0) {
        var mapping = this._originalMappings[index];
        if (aArgs.column === void 0) {
          var originalLine = mapping.originalLine;
          while (mapping && mapping.originalLine === originalLine) {
            mappings.push({
              line: util.getArg(mapping, "generatedLine", null),
              column: util.getArg(mapping, "generatedColumn", null),
              lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
            });
            mapping = this._originalMappings[++index];
          }
        } else {
          var originalColumn = mapping.originalColumn;
          while (mapping && mapping.originalLine === line && mapping.originalColumn == originalColumn) {
            mappings.push({
              line: util.getArg(mapping, "generatedLine", null),
              column: util.getArg(mapping, "generatedColumn", null),
              lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
            });
            mapping = this._originalMappings[++index];
          }
        }
      }
      return mappings;
    };
    exports.SourceMapConsumer = SourceMapConsumer;
    function BasicSourceMapConsumer(aSourceMap) {
      var sourceMap = aSourceMap;
      if (typeof aSourceMap === "string") {
        sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ""));
      }
      var version = util.getArg(sourceMap, "version");
      var sources = util.getArg(sourceMap, "sources");
      var names = util.getArg(sourceMap, "names", []);
      var sourceRoot = util.getArg(sourceMap, "sourceRoot", null);
      var sourcesContent = util.getArg(sourceMap, "sourcesContent", null);
      var mappings = util.getArg(sourceMap, "mappings");
      var file = util.getArg(sourceMap, "file", null);
      if (version != this._version) {
        throw new Error("Unsupported version: " + version);
      }
      sources = sources.map(String).map(util.normalize).map(function(source) {
        return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source) ? util.relative(sourceRoot, source) : source;
      });
      this._names = ArraySet.fromArray(names.map(String), true);
      this._sources = ArraySet.fromArray(sources, true);
      this.sourceRoot = sourceRoot;
      this.sourcesContent = sourcesContent;
      this._mappings = mappings;
      this.file = file;
    }
    BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
    BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;
    BasicSourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(aSourceMap) {
      var smc = Object.create(BasicSourceMapConsumer.prototype);
      var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
      var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
      smc.sourceRoot = aSourceMap._sourceRoot;
      smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(), smc.sourceRoot);
      smc.file = aSourceMap._file;
      var generatedMappings = aSourceMap._mappings.toArray().slice();
      var destGeneratedMappings = smc.__generatedMappings = [];
      var destOriginalMappings = smc.__originalMappings = [];
      for (var i = 0, length = generatedMappings.length; i < length; i++) {
        var srcMapping = generatedMappings[i];
        var destMapping = new Mapping();
        destMapping.generatedLine = srcMapping.generatedLine;
        destMapping.generatedColumn = srcMapping.generatedColumn;
        if (srcMapping.source) {
          destMapping.source = sources.indexOf(srcMapping.source);
          destMapping.originalLine = srcMapping.originalLine;
          destMapping.originalColumn = srcMapping.originalColumn;
          if (srcMapping.name) {
            destMapping.name = names.indexOf(srcMapping.name);
          }
          destOriginalMappings.push(destMapping);
        }
        destGeneratedMappings.push(destMapping);
      }
      quickSort(smc.__originalMappings, util.compareByOriginalPositions);
      return smc;
    };
    BasicSourceMapConsumer.prototype._version = 3;
    Object.defineProperty(BasicSourceMapConsumer.prototype, "sources", {
      get: function() {
        return this._sources.toArray().map(function(s) {
          return this.sourceRoot != null ? util.join(this.sourceRoot, s) : s;
        }, this);
      }
    });
    function Mapping() {
      this.generatedLine = 0;
      this.generatedColumn = 0;
      this.source = null;
      this.originalLine = null;
      this.originalColumn = null;
      this.name = null;
    }
    BasicSourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      var generatedLine = 1;
      var previousGeneratedColumn = 0;
      var previousOriginalLine = 0;
      var previousOriginalColumn = 0;
      var previousSource = 0;
      var previousName = 0;
      var length = aStr.length;
      var index = 0;
      var cachedSegments = {};
      var temp = {};
      var originalMappings = [];
      var generatedMappings = [];
      var mapping, str, segment, end, value2;
      while (index < length) {
        if (aStr.charAt(index) === ";") {
          generatedLine++;
          index++;
          previousGeneratedColumn = 0;
        } else if (aStr.charAt(index) === ",") {
          index++;
        } else {
          mapping = new Mapping();
          mapping.generatedLine = generatedLine;
          for (end = index; end < length; end++) {
            if (this._charIsMappingSeparator(aStr, end)) {
              break;
            }
          }
          str = aStr.slice(index, end);
          segment = cachedSegments[str];
          if (segment) {
            index += str.length;
          } else {
            segment = [];
            while (index < end) {
              base64VLQ.decode(aStr, index, temp);
              value2 = temp.value;
              index = temp.rest;
              segment.push(value2);
            }
            if (segment.length === 2) {
              throw new Error("Found a source, but no line and column");
            }
            if (segment.length === 3) {
              throw new Error("Found a source and line, but no column");
            }
            cachedSegments[str] = segment;
          }
          mapping.generatedColumn = previousGeneratedColumn + segment[0];
          previousGeneratedColumn = mapping.generatedColumn;
          if (segment.length > 1) {
            mapping.source = previousSource + segment[1];
            previousSource += segment[1];
            mapping.originalLine = previousOriginalLine + segment[2];
            previousOriginalLine = mapping.originalLine;
            mapping.originalLine += 1;
            mapping.originalColumn = previousOriginalColumn + segment[3];
            previousOriginalColumn = mapping.originalColumn;
            if (segment.length > 4) {
              mapping.name = previousName + segment[4];
              previousName += segment[4];
            }
          }
          generatedMappings.push(mapping);
          if (typeof mapping.originalLine === "number") {
            originalMappings.push(mapping);
          }
        }
      }
      quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);
      this.__generatedMappings = generatedMappings;
      quickSort(originalMappings, util.compareByOriginalPositions);
      this.__originalMappings = originalMappings;
    };
    BasicSourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {
      if (aNeedle[aLineName] <= 0) {
        throw new TypeError("Line must be greater than or equal to 1, got " + aNeedle[aLineName]);
      }
      if (aNeedle[aColumnName] < 0) {
        throw new TypeError("Column must be greater than or equal to 0, got " + aNeedle[aColumnName]);
      }
      return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
    };
    BasicSourceMapConsumer.prototype.computeColumnSpans = function SourceMapConsumer_computeColumnSpans() {
      for (var index = 0; index < this._generatedMappings.length; ++index) {
        var mapping = this._generatedMappings[index];
        if (index + 1 < this._generatedMappings.length) {
          var nextMapping = this._generatedMappings[index + 1];
          if (mapping.generatedLine === nextMapping.generatedLine) {
            mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
            continue;
          }
        }
        mapping.lastGeneratedColumn = Infinity;
      }
    };
    BasicSourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(aArgs) {
      var needle = {
        generatedLine: util.getArg(aArgs, "line"),
        generatedColumn: util.getArg(aArgs, "column")
      };
      var index = this._findMapping(needle, this._generatedMappings, "generatedLine", "generatedColumn", util.compareByGeneratedPositionsDeflated, util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND));
      if (index >= 0) {
        var mapping = this._generatedMappings[index];
        if (mapping.generatedLine === needle.generatedLine) {
          var source = util.getArg(mapping, "source", null);
          if (source !== null) {
            source = this._sources.at(source);
            if (this.sourceRoot != null) {
              source = util.join(this.sourceRoot, source);
            }
          }
          var name = util.getArg(mapping, "name", null);
          if (name !== null) {
            name = this._names.at(name);
          }
          return {
            source,
            line: util.getArg(mapping, "originalLine", null),
            column: util.getArg(mapping, "originalColumn", null),
            name
          };
        }
      }
      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    };
    BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function BasicSourceMapConsumer_hasContentsOfAllSources() {
      if (!this.sourcesContent) {
        return false;
      }
      return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function(sc) {
        return sc == null;
      });
    };
    BasicSourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
      if (!this.sourcesContent) {
        return null;
      }
      if (this.sourceRoot != null) {
        aSource = util.relative(this.sourceRoot, aSource);
      }
      if (this._sources.has(aSource)) {
        return this.sourcesContent[this._sources.indexOf(aSource)];
      }
      var url;
      if (this.sourceRoot != null && (url = util.urlParse(this.sourceRoot))) {
        var fileUriAbsPath = aSource.replace(/^file:\/\//, "");
        if (url.scheme == "file" && this._sources.has(fileUriAbsPath)) {
          return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
        }
        if ((!url.path || url.path == "/") && this._sources.has("/" + aSource)) {
          return this.sourcesContent[this._sources.indexOf("/" + aSource)];
        }
      }
      if (nullOnMissing) {
        return null;
      } else {
        throw new Error('"' + aSource + '" is not in the SourceMap.');
      }
    };
    BasicSourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(aArgs) {
      var source = util.getArg(aArgs, "source");
      if (this.sourceRoot != null) {
        source = util.relative(this.sourceRoot, source);
      }
      if (!this._sources.has(source)) {
        return {
          line: null,
          column: null,
          lastColumn: null
        };
      }
      source = this._sources.indexOf(source);
      var needle = {
        source,
        originalLine: util.getArg(aArgs, "line"),
        originalColumn: util.getArg(aArgs, "column")
      };
      var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util.compareByOriginalPositions, util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND));
      if (index >= 0) {
        var mapping = this._originalMappings[index];
        if (mapping.source === needle.source) {
          return {
            line: util.getArg(mapping, "generatedLine", null),
            column: util.getArg(mapping, "generatedColumn", null),
            lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
          };
        }
      }
      return {
        line: null,
        column: null,
        lastColumn: null
      };
    };
    exports.BasicSourceMapConsumer = BasicSourceMapConsumer;
    function IndexedSourceMapConsumer(aSourceMap) {
      var sourceMap = aSourceMap;
      if (typeof aSourceMap === "string") {
        sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ""));
      }
      var version = util.getArg(sourceMap, "version");
      var sections = util.getArg(sourceMap, "sections");
      if (version != this._version) {
        throw new Error("Unsupported version: " + version);
      }
      this._sources = new ArraySet();
      this._names = new ArraySet();
      var lastOffset = {
        line: -1,
        column: 0
      };
      this._sections = sections.map(function(s) {
        if (s.url) {
          throw new Error("Support for url field in sections not implemented.");
        }
        var offset = util.getArg(s, "offset");
        var offsetLine = util.getArg(offset, "line");
        var offsetColumn = util.getArg(offset, "column");
        if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) {
          throw new Error("Section offsets must be ordered and non-overlapping.");
        }
        lastOffset = offset;
        return {
          generatedOffset: {
            generatedLine: offsetLine + 1,
            generatedColumn: offsetColumn + 1
          },
          consumer: new SourceMapConsumer(util.getArg(s, "map"))
        };
      });
    }
    IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
    IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;
    IndexedSourceMapConsumer.prototype._version = 3;
    Object.defineProperty(IndexedSourceMapConsumer.prototype, "sources", {
      get: function() {
        var sources = [];
        for (var i = 0; i < this._sections.length; i++) {
          for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
            sources.push(this._sections[i].consumer.sources[j]);
          }
        }
        return sources;
      }
    });
    IndexedSourceMapConsumer.prototype.originalPositionFor = function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
      var needle = {
        generatedLine: util.getArg(aArgs, "line"),
        generatedColumn: util.getArg(aArgs, "column")
      };
      var sectionIndex = binarySearch.search(needle, this._sections, function(needle2, section2) {
        var cmp = needle2.generatedLine - section2.generatedOffset.generatedLine;
        if (cmp) {
          return cmp;
        }
        return needle2.generatedColumn - section2.generatedOffset.generatedColumn;
      });
      var section = this._sections[sectionIndex];
      if (!section) {
        return {
          source: null,
          line: null,
          column: null,
          name: null
        };
      }
      return section.consumer.originalPositionFor({
        line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),
        column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
        bias: aArgs.bias
      });
    };
    IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function IndexedSourceMapConsumer_hasContentsOfAllSources() {
      return this._sections.every(function(s) {
        return s.consumer.hasContentsOfAllSources();
      });
    };
    IndexedSourceMapConsumer.prototype.sourceContentFor = function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
      for (var i = 0; i < this._sections.length; i++) {
        var section = this._sections[i];
        var content = section.consumer.sourceContentFor(aSource, true);
        if (content) {
          return content;
        }
      }
      if (nullOnMissing) {
        return null;
      } else {
        throw new Error('"' + aSource + '" is not in the SourceMap.');
      }
    };
    IndexedSourceMapConsumer.prototype.generatedPositionFor = function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
      for (var i = 0; i < this._sections.length; i++) {
        var section = this._sections[i];
        if (section.consumer.sources.indexOf(util.getArg(aArgs, "source")) === -1) {
          continue;
        }
        var generatedPosition = section.consumer.generatedPositionFor(aArgs);
        if (generatedPosition) {
          var ret = {
            line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),
            column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)
          };
          return ret;
        }
      }
      return {
        line: null,
        column: null
      };
    };
    IndexedSourceMapConsumer.prototype._parseMappings = function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      this.__generatedMappings = [];
      this.__originalMappings = [];
      for (var i = 0; i < this._sections.length; i++) {
        var section = this._sections[i];
        var sectionMappings = section.consumer._generatedMappings;
        for (var j = 0; j < sectionMappings.length; j++) {
          var mapping = sectionMappings[j];
          var source = section.consumer._sources.at(mapping.source);
          if (section.consumer.sourceRoot !== null) {
            source = util.join(section.consumer.sourceRoot, source);
          }
          this._sources.add(source);
          source = this._sources.indexOf(source);
          var name = section.consumer._names.at(mapping.name);
          this._names.add(name);
          name = this._names.indexOf(name);
          var adjustedMapping = {
            source,
            generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1),
            generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
            originalLine: mapping.originalLine,
            originalColumn: mapping.originalColumn,
            name
          };
          this.__generatedMappings.push(adjustedMapping);
          if (typeof adjustedMapping.originalLine === "number") {
            this.__originalMappings.push(adjustedMapping);
          }
        }
      }
      quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
      quickSort(this.__originalMappings, util.compareByOriginalPositions);
    };
    exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
  }
});

// node_modules/snapdragon/node_modules/source-map/lib/source-node.js
var require_source_node2 = __commonJS({
  "node_modules/snapdragon/node_modules/source-map/lib/source-node.js"(exports) {
    var SourceMapGenerator = require_source_map_generator2().SourceMapGenerator;
    var util = require_util3();
    var REGEX_NEWLINE = /(\r?\n)/;
    var NEWLINE_CODE = 10;
    var isSourceNode = "$$$isSourceNode$$$";
    function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
      this.children = [];
      this.sourceContents = {};
      this.line = aLine == null ? null : aLine;
      this.column = aColumn == null ? null : aColumn;
      this.source = aSource == null ? null : aSource;
      this.name = aName == null ? null : aName;
      this[isSourceNode] = true;
      if (aChunks != null)
        this.add(aChunks);
    }
    SourceNode.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
      var node = new SourceNode();
      var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
      var remainingLinesIndex = 0;
      var shiftNextLine = function() {
        var lineContents = getNextLine();
        var newLine = getNextLine() || "";
        return lineContents + newLine;
        function getNextLine() {
          return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : void 0;
        }
      };
      var lastGeneratedLine = 1, lastGeneratedColumn = 0;
      var lastMapping = null;
      aSourceMapConsumer.eachMapping(function(mapping) {
        if (lastMapping !== null) {
          if (lastGeneratedLine < mapping.generatedLine) {
            addMappingWithCode(lastMapping, shiftNextLine());
            lastGeneratedLine++;
            lastGeneratedColumn = 0;
          } else {
            var nextLine = remainingLines[remainingLinesIndex];
            var code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);
            remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);
            lastGeneratedColumn = mapping.generatedColumn;
            addMappingWithCode(lastMapping, code);
            lastMapping = mapping;
            return;
          }
        }
        while (lastGeneratedLine < mapping.generatedLine) {
          node.add(shiftNextLine());
          lastGeneratedLine++;
        }
        if (lastGeneratedColumn < mapping.generatedColumn) {
          var nextLine = remainingLines[remainingLinesIndex];
          node.add(nextLine.substr(0, mapping.generatedColumn));
          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
          lastGeneratedColumn = mapping.generatedColumn;
        }
        lastMapping = mapping;
      }, this);
      if (remainingLinesIndex < remainingLines.length) {
        if (lastMapping) {
          addMappingWithCode(lastMapping, shiftNextLine());
        }
        node.add(remainingLines.splice(remainingLinesIndex).join(""));
      }
      aSourceMapConsumer.sources.forEach(function(sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
          if (aRelativePath != null) {
            sourceFile = util.join(aRelativePath, sourceFile);
          }
          node.setSourceContent(sourceFile, content);
        }
      });
      return node;
      function addMappingWithCode(mapping, code) {
        if (mapping === null || mapping.source === void 0) {
          node.add(code);
        } else {
          var source = aRelativePath ? util.join(aRelativePath, mapping.source) : mapping.source;
          node.add(new SourceNode(mapping.originalLine, mapping.originalColumn, source, code, mapping.name));
        }
      }
    };
    SourceNode.prototype.add = function SourceNode_add(aChunk) {
      if (Array.isArray(aChunk)) {
        aChunk.forEach(function(chunk) {
          this.add(chunk);
        }, this);
      } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
        if (aChunk) {
          this.children.push(aChunk);
        }
      } else {
        throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
      }
      return this;
    };
    SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
      if (Array.isArray(aChunk)) {
        for (var i = aChunk.length - 1; i >= 0; i--) {
          this.prepend(aChunk[i]);
        }
      } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
        this.children.unshift(aChunk);
      } else {
        throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
      }
      return this;
    };
    SourceNode.prototype.walk = function SourceNode_walk(aFn) {
      var chunk;
      for (var i = 0, len = this.children.length; i < len; i++) {
        chunk = this.children[i];
        if (chunk[isSourceNode]) {
          chunk.walk(aFn);
        } else {
          if (chunk !== "") {
            aFn(chunk, {
              source: this.source,
              line: this.line,
              column: this.column,
              name: this.name
            });
          }
        }
      }
    };
    SourceNode.prototype.join = function SourceNode_join(aSep) {
      var newChildren;
      var i;
      var len = this.children.length;
      if (len > 0) {
        newChildren = [];
        for (i = 0; i < len - 1; i++) {
          newChildren.push(this.children[i]);
          newChildren.push(aSep);
        }
        newChildren.push(this.children[i]);
        this.children = newChildren;
      }
      return this;
    };
    SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
      var lastChild = this.children[this.children.length - 1];
      if (lastChild[isSourceNode]) {
        lastChild.replaceRight(aPattern, aReplacement);
      } else if (typeof lastChild === "string") {
        this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
      } else {
        this.children.push("".replace(aPattern, aReplacement));
      }
      return this;
    };
    SourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
      this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
    };
    SourceNode.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {
      for (var i = 0, len = this.children.length; i < len; i++) {
        if (this.children[i][isSourceNode]) {
          this.children[i].walkSourceContents(aFn);
        }
      }
      var sources = Object.keys(this.sourceContents);
      for (var i = 0, len = sources.length; i < len; i++) {
        aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
      }
    };
    SourceNode.prototype.toString = function SourceNode_toString() {
      var str = "";
      this.walk(function(chunk) {
        str += chunk;
      });
      return str;
    };
    SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
      var generated = {
        code: "",
        line: 1,
        column: 0
      };
      var map = new SourceMapGenerator(aArgs);
      var sourceMappingActive = false;
      var lastOriginalSource = null;
      var lastOriginalLine = null;
      var lastOriginalColumn = null;
      var lastOriginalName = null;
      this.walk(function(chunk, original) {
        generated.code += chunk;
        if (original.source !== null && original.line !== null && original.column !== null) {
          if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {
            map.addMapping({
              source: original.source,
              original: {
                line: original.line,
                column: original.column
              },
              generated: {
                line: generated.line,
                column: generated.column
              },
              name: original.name
            });
          }
          lastOriginalSource = original.source;
          lastOriginalLine = original.line;
          lastOriginalColumn = original.column;
          lastOriginalName = original.name;
          sourceMappingActive = true;
        } else if (sourceMappingActive) {
          map.addMapping({
            generated: {
              line: generated.line,
              column: generated.column
            }
          });
          lastOriginalSource = null;
          sourceMappingActive = false;
        }
        for (var idx = 0, length = chunk.length; idx < length; idx++) {
          if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
            generated.line++;
            generated.column = 0;
            if (idx + 1 === length) {
              lastOriginalSource = null;
              sourceMappingActive = false;
            } else if (sourceMappingActive) {
              map.addMapping({
                source: original.source,
                original: {
                  line: original.line,
                  column: original.column
                },
                generated: {
                  line: generated.line,
                  column: generated.column
                },
                name: original.name
              });
            }
          } else {
            generated.column++;
          }
        }
      });
      this.walkSourceContents(function(sourceFile, sourceContent) {
        map.setSourceContent(sourceFile, sourceContent);
      });
      return { code: generated.code, map };
    };
    exports.SourceNode = SourceNode;
  }
});

// node_modules/snapdragon/node_modules/source-map/source-map.js
var require_source_map2 = __commonJS({
  "node_modules/snapdragon/node_modules/source-map/source-map.js"(exports) {
    exports.SourceMapGenerator = require_source_map_generator2().SourceMapGenerator;
    exports.SourceMapConsumer = require_source_map_consumer2().SourceMapConsumer;
    exports.SourceNode = require_source_node2().SourceNode;
  }
});

// node_modules/source-map-url/source-map-url.js
var require_source_map_url = __commonJS({
  "node_modules/source-map-url/source-map-url.js"(exports, module2) {
    void function(root, factory) {
      if (typeof define === "function" && define.amd) {
        define(factory);
      } else if (typeof exports === "object") {
        module2.exports = factory();
      } else {
        root.sourceMappingURL = factory();
      }
    }(exports, function() {
      var innerRegex = /[#@] sourceMappingURL=([^\s'"]*)/;
      var regex = RegExp("(?:/\\*(?:\\s*\r?\n(?://)?)?(?:" + innerRegex.source + ")\\s*\\*/|//(?:" + innerRegex.source + "))\\s*");
      return {
        regex,
        _innerRegex: innerRegex,
        getFrom: function(code) {
          var match = code.match(regex);
          return match ? match[1] || match[2] || "" : null;
        },
        existsIn: function(code) {
          return regex.test(code);
        },
        removeFrom: function(code) {
          return code.replace(regex, "");
        },
        insertBefore: function(code, string) {
          var match = code.match(regex);
          if (match) {
            return code.slice(0, match.index) + string + code.slice(match.index);
          } else {
            return code + string;
          }
        }
      };
    });
  }
});

// node_modules/resolve-url/resolve-url.js
var require_resolve_url = __commonJS({
  "node_modules/resolve-url/resolve-url.js"(exports, module2) {
    void function(root, factory) {
      if (typeof define === "function" && define.amd) {
        define(factory);
      } else if (typeof exports === "object") {
        module2.exports = factory();
      } else {
        root.resolveUrl = factory();
      }
    }(exports, function() {
      function resolveUrl() {
        var numUrls = arguments.length;
        if (numUrls === 0) {
          throw new Error("resolveUrl requires at least one argument; got none.");
        }
        var base = document.createElement("base");
        base.href = arguments[0];
        if (numUrls === 1) {
          return base.href;
        }
        var head = document.getElementsByTagName("head")[0];
        head.insertBefore(base, head.firstChild);
        var a = document.createElement("a");
        var resolved;
        for (var index = 1; index < numUrls; index++) {
          a.href = arguments[index];
          resolved = a.href;
          base.href = resolved;
        }
        head.removeChild(base);
        return resolved;
      }
      return resolveUrl;
    });
  }
});

// node_modules/source-map-resolve/source-map-resolve.js
var require_source_map_resolve = __commonJS({
  "node_modules/source-map-resolve/source-map-resolve.js"(exports, module2) {
    void function(root, factory) {
      if (typeof define === "function" && define.amd) {
        define(["source-map-url", "resolve-url"], factory);
      } else if (typeof exports === "object") {
        var sourceMappingURL = require_source_map_url();
        var resolveUrl = require_resolve_url();
        module2.exports = factory(sourceMappingURL, resolveUrl);
      } else {
        root.sourceMapResolve = factory(root.sourceMappingURL, root.resolveUrl);
      }
    }(exports, function(sourceMappingURL, resolveUrl) {
      function callbackAsync(callback, error, result) {
        setImmediate(function() {
          callback(error, result);
        });
      }
      function parseMapToJSON(string, data) {
        try {
          return JSON.parse(string.replace(/^\)\]\}'/, ""));
        } catch (error) {
          error.sourceMapData = data;
          throw error;
        }
      }
      function readSync(read, url, data) {
        var readUrl = url;
        try {
          return String(read(readUrl));
        } catch (error) {
          error.sourceMapData = data;
          throw error;
        }
      }
      function resolveSourceMap(code, codeUrl, read, callback) {
        var mapData;
        try {
          mapData = resolveSourceMapHelper(code, codeUrl);
        } catch (error) {
          return callbackAsync(callback, error);
        }
        if (!mapData || mapData.map) {
          return callbackAsync(callback, null, mapData);
        }
        var readUrl = mapData.url;
        read(readUrl, function(error, result) {
          if (error) {
            error.sourceMapData = mapData;
            return callback(error);
          }
          mapData.map = String(result);
          try {
            mapData.map = parseMapToJSON(mapData.map, mapData);
          } catch (error2) {
            return callback(error2);
          }
          callback(null, mapData);
        });
      }
      function resolveSourceMapSync(code, codeUrl, read) {
        var mapData = resolveSourceMapHelper(code, codeUrl);
        if (!mapData || mapData.map) {
          return mapData;
        }
        mapData.map = readSync(read, mapData.url, mapData);
        mapData.map = parseMapToJSON(mapData.map, mapData);
        return mapData;
      }
      var dataUriRegex = /^data:([^,;]*)(;[^,;]*)*(?:,(.*))?$/;
      var jsonMimeTypeRegex = /^(?:application|text)\/json$/;
      var jsonCharacterEncoding = "utf-8";
      function base64ToBuf(b64) {
        var binStr = atob(b64);
        var len = binStr.length;
        var arr = new Uint8Array(len);
        for (var i = 0; i < len; i++) {
          arr[i] = binStr.charCodeAt(i);
        }
        return arr;
      }
      function decodeBase64String(b64) {
        if (typeof TextDecoder === "undefined" || typeof Uint8Array === "undefined") {
          return atob(b64);
        }
        var buf = base64ToBuf(b64);
        var decoder = new TextDecoder(jsonCharacterEncoding, { fatal: true });
        return decoder.decode(buf);
      }
      function resolveSourceMapHelper(code, codeUrl) {
        var url = sourceMappingURL.getFrom(code);
        if (!url) {
          return null;
        }
        var dataUri = url.match(dataUriRegex);
        if (dataUri) {
          var mimeType = dataUri[1] || "text/plain";
          var lastParameter = dataUri[2] || "";
          var encoded = dataUri[3] || "";
          var data = {
            sourceMappingURL: url,
            url: null,
            sourcesRelativeTo: codeUrl,
            map: encoded
          };
          if (!jsonMimeTypeRegex.test(mimeType)) {
            var error = new Error("Unuseful data uri mime type: " + mimeType);
            error.sourceMapData = data;
            throw error;
          }
          try {
            data.map = parseMapToJSON(lastParameter === ";base64" ? decodeBase64String(encoded) : decodeURIComponent(encoded), data);
          } catch (error2) {
            error2.sourceMapData = data;
            throw error2;
          }
          return data;
        }
        var mapUrl = resolveUrl(codeUrl, url);
        return {
          sourceMappingURL: url,
          url: mapUrl,
          sourcesRelativeTo: mapUrl,
          map: null
        };
      }
      function resolveSources(map, mapUrl, read, options, callback) {
        if (typeof options === "function") {
          callback = options;
          options = {};
        }
        var pending = map.sources ? map.sources.length : 0;
        var result = {
          sourcesResolved: [],
          sourcesContent: []
        };
        if (pending === 0) {
          callbackAsync(callback, null, result);
          return;
        }
        var done = function() {
          pending--;
          if (pending === 0) {
            callback(null, result);
          }
        };
        resolveSourcesHelper(map, mapUrl, options, function(fullUrl, sourceContent, index) {
          result.sourcesResolved[index] = fullUrl;
          if (typeof sourceContent === "string") {
            result.sourcesContent[index] = sourceContent;
            callbackAsync(done, null);
          } else {
            var readUrl = fullUrl;
            read(readUrl, function(error, source) {
              result.sourcesContent[index] = error ? error : String(source);
              done();
            });
          }
        });
      }
      function resolveSourcesSync(map, mapUrl, read, options) {
        var result = {
          sourcesResolved: [],
          sourcesContent: []
        };
        if (!map.sources || map.sources.length === 0) {
          return result;
        }
        resolveSourcesHelper(map, mapUrl, options, function(fullUrl, sourceContent, index) {
          result.sourcesResolved[index] = fullUrl;
          if (read !== null) {
            if (typeof sourceContent === "string") {
              result.sourcesContent[index] = sourceContent;
            } else {
              var readUrl = fullUrl;
              try {
                result.sourcesContent[index] = String(read(readUrl));
              } catch (error) {
                result.sourcesContent[index] = error;
              }
            }
          }
        });
        return result;
      }
      var endingSlash = /\/?$/;
      function resolveSourcesHelper(map, mapUrl, options, fn) {
        options = options || {};
        var fullUrl;
        var sourceContent;
        var sourceRoot;
        for (var index = 0, len = map.sources.length; index < len; index++) {
          sourceRoot = null;
          if (typeof options.sourceRoot === "string") {
            sourceRoot = options.sourceRoot;
          } else if (typeof map.sourceRoot === "string" && options.sourceRoot !== false) {
            sourceRoot = map.sourceRoot;
          }
          if (sourceRoot === null || sourceRoot === "") {
            fullUrl = resolveUrl(mapUrl, map.sources[index]);
          } else {
            fullUrl = resolveUrl(mapUrl, sourceRoot.replace(endingSlash, "/"), map.sources[index]);
          }
          sourceContent = (map.sourcesContent || [])[index];
          fn(fullUrl, sourceContent, index);
        }
      }
      function resolve(code, codeUrl, read, options, callback) {
        if (typeof options === "function") {
          callback = options;
          options = {};
        }
        if (code === null) {
          var mapUrl = codeUrl;
          var data = {
            sourceMappingURL: null,
            url: mapUrl,
            sourcesRelativeTo: mapUrl,
            map: null
          };
          var readUrl = mapUrl;
          read(readUrl, function(error, result) {
            if (error) {
              error.sourceMapData = data;
              return callback(error);
            }
            data.map = String(result);
            try {
              data.map = parseMapToJSON(data.map, data);
            } catch (error2) {
              return callback(error2);
            }
            _resolveSources(data);
          });
        } else {
          resolveSourceMap(code, codeUrl, read, function(error, mapData) {
            if (error) {
              return callback(error);
            }
            if (!mapData) {
              return callback(null, null);
            }
            _resolveSources(mapData);
          });
        }
        function _resolveSources(mapData) {
          resolveSources(mapData.map, mapData.sourcesRelativeTo, read, options, function(error, result) {
            if (error) {
              return callback(error);
            }
            mapData.sourcesResolved = result.sourcesResolved;
            mapData.sourcesContent = result.sourcesContent;
            callback(null, mapData);
          });
        }
      }
      function resolveSync(code, codeUrl, read, options) {
        var mapData;
        if (code === null) {
          var mapUrl = codeUrl;
          mapData = {
            sourceMappingURL: null,
            url: mapUrl,
            sourcesRelativeTo: mapUrl,
            map: null
          };
          mapData.map = readSync(read, mapUrl, mapData);
          mapData.map = parseMapToJSON(mapData.map, mapData);
        } else {
          mapData = resolveSourceMapSync(code, codeUrl, read);
          if (!mapData) {
            return null;
          }
        }
        var result = resolveSourcesSync(mapData.map, mapData.sourcesRelativeTo, read, options);
        mapData.sourcesResolved = result.sourcesResolved;
        mapData.sourcesContent = result.sourcesContent;
        return mapData;
      }
      return {
        resolveSourceMap,
        resolveSourceMapSync,
        resolveSources,
        resolveSourcesSync,
        resolve,
        resolveSync,
        parseMapToJSON
      };
    });
  }
});

// node_modules/snapdragon/lib/utils.js
var require_utils4 = __commonJS({
  "node_modules/snapdragon/lib/utils.js"(exports) {
    "use strict";
    exports.extend = require_extend_shallow4();
    exports.SourceMap = require_source_map2();
    exports.sourceMapResolve = require_source_map_resolve();
    exports.unixify = function(fp) {
      return fp.split(/\\+/).join("/");
    };
    exports.isString = function(str) {
      return str && typeof str === "string";
    };
    exports.arrayify = function(val) {
      if (typeof val === "string")
        return [val];
      return val ? Array.isArray(val) ? val : [val] : [];
    };
    exports.last = function(arr, n) {
      return arr[arr.length - (n || 1)];
    };
  }
});

// node_modules/snapdragon/lib/source-maps.js
var require_source_maps = __commonJS({
  "node_modules/snapdragon/lib/source-maps.js"(exports, module2) {
    "use strict";
    var fs = require("fs");
    var path = require("path");
    var define2 = require_define_property5();
    var utils = require_utils4();
    module2.exports = mixin;
    function mixin(compiler) {
      define2(compiler, "_comment", compiler.comment);
      compiler.map = new utils.SourceMap.SourceMapGenerator();
      compiler.position = { line: 1, column: 1 };
      compiler.content = {};
      compiler.files = {};
      for (var key in exports) {
        define2(compiler, key, exports[key]);
      }
    }
    exports.updatePosition = function(str) {
      var lines = str.match(/\n/g);
      if (lines)
        this.position.line += lines.length;
      var i = str.lastIndexOf("\n");
      this.position.column = ~i ? str.length - i : this.position.column + str.length;
    };
    exports.emit = function(str, node) {
      var position = node.position || {};
      var source = position.source;
      if (source) {
        if (position.filepath) {
          source = utils.unixify(position.filepath);
        }
        this.map.addMapping({
          source,
          generated: {
            line: this.position.line,
            column: Math.max(this.position.column - 1, 0)
          },
          original: {
            line: position.start.line,
            column: position.start.column - 1
          }
        });
        if (position.content) {
          this.addContent(source, position);
        }
        if (position.filepath) {
          this.addFile(source, position);
        }
        this.updatePosition(str);
        this.output += str;
      }
      return str;
    };
    exports.addFile = function(file, position) {
      if (typeof position.content !== "string")
        return;
      if (Object.prototype.hasOwnProperty.call(this.files, file))
        return;
      this.files[file] = position.content;
    };
    exports.addContent = function(source, position) {
      if (typeof position.content !== "string")
        return;
      if (Object.prototype.hasOwnProperty.call(this.content, source))
        return;
      this.map.setSourceContent(source, position.content);
    };
    exports.applySourceMaps = function() {
      Object.keys(this.files).forEach(function(file) {
        var content = this.files[file];
        this.map.setSourceContent(file, content);
        if (this.options.inputSourcemaps === true) {
          var originalMap = utils.sourceMapResolve.resolveSync(content, file, fs.readFileSync);
          if (originalMap) {
            var map = new utils.SourceMap.SourceMapConsumer(originalMap.map);
            var relativeTo = originalMap.sourcesRelativeTo;
            this.map.applySourceMap(map, file, utils.unixify(path.dirname(relativeTo)));
          }
        }
      }, this);
    };
    exports.comment = function(node) {
      if (/^# sourceMappingURL=/.test(node.comment)) {
        return this.emit("", node.position);
      }
      return this._comment(node);
    };
  }
});

// node_modules/snapdragon/lib/compiler.js
var require_compiler2 = __commonJS({
  "node_modules/snapdragon/lib/compiler.js"(exports, module2) {
    "use strict";
    var use = require_use();
    var define2 = require_define_property5();
    var debug = require_browser()("snapdragon:compiler");
    var utils = require_utils4();
    function Compiler(options, state) {
      debug("initializing", __filename);
      this.options = utils.extend({ source: "string" }, options);
      this.state = state || {};
      this.compilers = {};
      this.output = "";
      this.set("eos", function(node) {
        return this.emit(node.val, node);
      });
      this.set("noop", function(node) {
        return this.emit(node.val, node);
      });
      this.set("bos", function(node) {
        return this.emit(node.val, node);
      });
      use(this);
    }
    Compiler.prototype = {
      error: function(msg, node) {
        var pos = node.position || { start: { column: 0 } };
        var message = this.options.source + " column:" + pos.start.column + ": " + msg;
        var err = new Error(message);
        err.reason = msg;
        err.column = pos.start.column;
        err.source = this.pattern;
        if (this.options.silent) {
          this.errors.push(err);
        } else {
          throw err;
        }
      },
      define: function(key, val) {
        define2(this, key, val);
        return this;
      },
      emit: function(str, node) {
        this.output += str;
        return str;
      },
      set: function(name, fn) {
        this.compilers[name] = fn;
        return this;
      },
      get: function(name) {
        return this.compilers[name];
      },
      prev: function(n) {
        return this.ast.nodes[this.idx - (n || 1)] || { type: "bos", val: "" };
      },
      next: function(n) {
        return this.ast.nodes[this.idx + (n || 1)] || { type: "eos", val: "" };
      },
      visit: function(node, nodes, i) {
        var fn = this.compilers[node.type];
        this.idx = i;
        if (typeof fn !== "function") {
          throw this.error('compiler "' + node.type + '" is not registered', node);
        }
        return fn.call(this, node, nodes, i);
      },
      mapVisit: function(nodes) {
        if (!Array.isArray(nodes)) {
          throw new TypeError("expected an array");
        }
        var len = nodes.length;
        var idx = -1;
        while (++idx < len) {
          this.visit(nodes[idx], nodes, idx);
        }
        return this;
      },
      compile: function(ast, options) {
        var opts = utils.extend({}, this.options, options);
        this.ast = ast;
        this.parsingErrors = this.ast.errors;
        this.output = "";
        if (opts.sourcemap) {
          var sourcemaps = require_source_maps();
          sourcemaps(this);
          this.mapVisit(this.ast.nodes);
          this.applySourceMaps();
          this.map = opts.sourcemap === "generator" ? this.map : this.map.toJSON();
          return this;
        }
        this.mapVisit(this.ast.nodes);
        return this;
      }
    };
    module2.exports = Compiler;
  }
});

// node_modules/map-cache/index.js
var require_map_cache = __commonJS({
  "node_modules/map-cache/index.js"(exports, module2) {
    "use strict";
    var hasOwn = Object.prototype.hasOwnProperty;
    module2.exports = MapCache;
    function MapCache(data) {
      this.__data__ = data || {};
    }
    MapCache.prototype.set = function mapSet(key, value2) {
      if (key !== "__proto__") {
        this.__data__[key] = value2;
      }
      return this;
    };
    MapCache.prototype.get = function mapGet(key) {
      return key === "__proto__" ? void 0 : this.__data__[key];
    };
    MapCache.prototype.has = function mapHas(key) {
      return key !== "__proto__" && hasOwn.call(this.__data__, key);
    };
    MapCache.prototype.del = function mapDelete(key) {
      return this.has(key) && delete this.__data__[key];
    };
  }
});

// node_modules/snapdragon/lib/position.js
var require_position = __commonJS({
  "node_modules/snapdragon/lib/position.js"(exports, module2) {
    "use strict";
    var define2 = require_define_property5();
    module2.exports = function Position(start, parser) {
      this.start = start;
      this.end = { line: parser.line, column: parser.column };
      define2(this, "content", parser.orig);
      define2(this, "source", parser.options.source);
    };
  }
});

// node_modules/snapdragon/lib/parser.js
var require_parser2 = __commonJS({
  "node_modules/snapdragon/lib/parser.js"(exports, module2) {
    "use strict";
    var use = require_use();
    var util = require("util");
    var Cache = require_map_cache();
    var define2 = require_define_property5();
    var debug = require_browser()("snapdragon:parser");
    var Position = require_position();
    var utils = require_utils4();
    function Parser(options) {
      debug("initializing", __filename);
      this.options = utils.extend({ source: "string" }, options);
      this.init(this.options);
      use(this);
    }
    Parser.prototype = {
      constructor: Parser,
      init: function(options) {
        this.orig = "";
        this.input = "";
        this.parsed = "";
        this.column = 1;
        this.line = 1;
        this.regex = new Cache();
        this.errors = this.errors || [];
        this.parsers = this.parsers || {};
        this.types = this.types || [];
        this.sets = this.sets || {};
        this.fns = this.fns || [];
        this.currentType = "root";
        var pos = this.position();
        this.bos = pos({ type: "bos", val: "" });
        this.ast = {
          type: "root",
          errors: this.errors,
          nodes: [this.bos]
        };
        define2(this.bos, "parent", this.ast);
        this.nodes = [this.ast];
        this.count = 0;
        this.setCount = 0;
        this.stack = [];
      },
      error: function(msg, node) {
        var pos = node.position || { start: { column: 0, line: 0 } };
        var line = pos.start.line;
        var column = pos.start.column;
        var source = this.options.source;
        var message = source + " <line:" + line + " column:" + column + ">: " + msg;
        var err = new Error(message);
        err.source = source;
        err.reason = msg;
        err.pos = pos;
        if (this.options.silent) {
          this.errors.push(err);
        } else {
          throw err;
        }
      },
      define: function(key, val) {
        define2(this, key, val);
        return this;
      },
      position: function() {
        var start = { line: this.line, column: this.column };
        var self2 = this;
        return function(node) {
          define2(node, "position", new Position(start, self2));
          return node;
        };
      },
      set: function(type, fn) {
        if (this.types.indexOf(type) === -1) {
          this.types.push(type);
        }
        this.parsers[type] = fn.bind(this);
        return this;
      },
      get: function(name) {
        return this.parsers[name];
      },
      push: function(type, token) {
        this.sets[type] = this.sets[type] || [];
        this.count++;
        this.stack.push(token);
        return this.sets[type].push(token);
      },
      pop: function(type) {
        this.sets[type] = this.sets[type] || [];
        this.count--;
        this.stack.pop();
        return this.sets[type].pop();
      },
      isInside: function(type) {
        this.sets[type] = this.sets[type] || [];
        return this.sets[type].length > 0;
      },
      isType: function(node, type) {
        return node && node.type === type;
      },
      prev: function(n) {
        return this.stack.length > 0 ? utils.last(this.stack, n) : utils.last(this.nodes, n);
      },
      consume: function(len) {
        this.input = this.input.substr(len);
      },
      updatePosition: function(str, len) {
        var lines = str.match(/\n/g);
        if (lines)
          this.line += lines.length;
        var i = str.lastIndexOf("\n");
        this.column = ~i ? len - i : this.column + len;
        this.parsed += str;
        this.consume(len);
      },
      match: function(regex) {
        var m = regex.exec(this.input);
        if (m) {
          this.updatePosition(m[0], m[0].length);
          return m;
        }
      },
      capture: function(type, regex) {
        if (typeof regex === "function") {
          return this.set.apply(this, arguments);
        }
        this.regex.set(type, regex);
        this.set(type, function() {
          var parsed = this.parsed;
          var pos = this.position();
          var m = this.match(regex);
          if (!m || !m[0])
            return;
          var prev = this.prev();
          var node = pos({
            type,
            val: m[0],
            parsed,
            rest: this.input
          });
          if (m[1]) {
            node.inner = m[1];
          }
          define2(node, "inside", this.stack.length > 0);
          define2(node, "parent", prev);
          prev.nodes.push(node);
        }.bind(this));
        return this;
      },
      capturePair: function(type, openRegex, closeRegex, fn) {
        this.sets[type] = this.sets[type] || [];
        this.set(type + ".open", function() {
          var parsed = this.parsed;
          var pos = this.position();
          var m = this.match(openRegex);
          if (!m || !m[0])
            return;
          var val = m[0];
          this.setCount++;
          this.specialChars = true;
          var open = pos({
            type: type + ".open",
            val,
            rest: this.input
          });
          if (typeof m[1] !== "undefined") {
            open.inner = m[1];
          }
          var prev = this.prev();
          var node = pos({
            type,
            nodes: [open]
          });
          define2(node, "rest", this.input);
          define2(node, "parsed", parsed);
          define2(node, "prefix", m[1]);
          define2(node, "parent", prev);
          define2(open, "parent", node);
          if (typeof fn === "function") {
            fn.call(this, open, node);
          }
          this.push(type, node);
          prev.nodes.push(node);
        });
        this.set(type + ".close", function() {
          var pos = this.position();
          var m = this.match(closeRegex);
          if (!m || !m[0])
            return;
          var parent = this.pop(type);
          var node = pos({
            type: type + ".close",
            rest: this.input,
            suffix: m[1],
            val: m[0]
          });
          if (!this.isType(parent, type)) {
            if (this.options.strict) {
              throw new Error('missing opening "' + type + '"');
            }
            this.setCount--;
            node.escaped = true;
            return node;
          }
          if (node.suffix === "\\") {
            parent.escaped = true;
            node.escaped = true;
          }
          parent.nodes.push(node);
          define2(node, "parent", parent);
        });
        return this;
      },
      eos: function() {
        var pos = this.position();
        if (this.input)
          return;
        var prev = this.prev();
        while (prev.type !== "root" && !prev.visited) {
          if (this.options.strict === true) {
            throw new SyntaxError("invalid syntax:" + util.inspect(prev, null, 2));
          }
          if (!hasDelims(prev)) {
            prev.parent.escaped = true;
            prev.escaped = true;
          }
          visit(prev, function(node) {
            if (!hasDelims(node.parent)) {
              node.parent.escaped = true;
              node.escaped = true;
            }
          });
          prev = prev.parent;
        }
        var tok = pos({
          type: "eos",
          val: this.append || ""
        });
        define2(tok, "parent", this.ast);
        return tok;
      },
      next: function() {
        var parsed = this.parsed;
        var len = this.types.length;
        var idx = -1;
        var tok;
        while (++idx < len) {
          if (tok = this.parsers[this.types[idx]].call(this)) {
            define2(tok, "rest", this.input);
            define2(tok, "parsed", parsed);
            this.last = tok;
            return tok;
          }
        }
      },
      parse: function(input) {
        if (typeof input !== "string") {
          throw new TypeError("expected a string");
        }
        this.init(this.options);
        this.orig = input;
        this.input = input;
        var self2 = this;
        function parse() {
          input = self2.input;
          var node2 = self2.next();
          if (node2) {
            var prev = self2.prev();
            if (prev) {
              define2(node2, "parent", prev);
              if (prev.nodes) {
                prev.nodes.push(node2);
              }
            }
            if (self2.sets.hasOwnProperty(prev.type)) {
              self2.currentType = prev.type;
            }
          }
          if (self2.input && input === self2.input) {
            throw new Error('no parsers registered for: "' + self2.input.slice(0, 5) + '"');
          }
        }
        while (this.input)
          parse();
        if (this.stack.length && this.options.strict) {
          var node = this.stack.pop();
          throw this.error("missing opening " + node.type + ': "' + this.orig + '"');
        }
        var eos = this.eos();
        var tok = this.prev();
        if (tok.type !== "eos") {
          this.ast.nodes.push(eos);
        }
        return this.ast;
      }
    };
    function visit(node, fn) {
      if (!node.visited) {
        define2(node, "visited", true);
        return node.nodes ? mapVisit(node.nodes, fn) : fn(node);
      }
      return node;
    }
    function mapVisit(nodes, fn) {
      var len = nodes.length;
      var idx = -1;
      while (++idx < len) {
        visit(nodes[idx], fn);
      }
    }
    function hasOpen(node) {
      return node.nodes && node.nodes[0].type === node.type + ".open";
    }
    function hasClose(node) {
      return node.nodes && utils.last(node.nodes).type === node.type + ".close";
    }
    function hasDelims(node) {
      return hasOpen(node) && hasClose(node);
    }
    module2.exports = Parser;
  }
});

// node_modules/snapdragon/index.js
var require_snapdragon = __commonJS({
  "node_modules/snapdragon/index.js"(exports, module2) {
    "use strict";
    var Base = require_base3();
    var define2 = require_define_property5();
    var Compiler = require_compiler2();
    var Parser = require_parser2();
    var utils = require_utils4();
    function Snapdragon(options) {
      Base.call(this, null, options);
      this.options = utils.extend({ source: "string" }, this.options);
      this.compiler = new Compiler(this.options);
      this.parser = new Parser(this.options);
      Object.defineProperty(this, "compilers", {
        get: function() {
          return this.compiler.compilers;
        }
      });
      Object.defineProperty(this, "parsers", {
        get: function() {
          return this.parser.parsers;
        }
      });
      Object.defineProperty(this, "regex", {
        get: function() {
          return this.parser.regex;
        }
      });
    }
    Base.extend(Snapdragon);
    Snapdragon.prototype.capture = function() {
      return this.parser.capture.apply(this.parser, arguments);
    };
    Snapdragon.prototype.use = function(fn) {
      fn.call(this, this);
      return this;
    };
    Snapdragon.prototype.parse = function(str, options) {
      this.options = utils.extend({}, this.options, options);
      var parsed = this.parser.parse(str, this.options);
      define2(parsed, "parser", this.parser);
      return parsed;
    };
    Snapdragon.prototype.compile = function(ast, options) {
      this.options = utils.extend({}, this.options, options);
      var compiled = this.compiler.compile(ast, this.options);
      define2(compiled, "compiler", this.compiler);
      return compiled;
    };
    module2.exports = Snapdragon;
    module2.exports.Compiler = Compiler;
    module2.exports.Parser = Parser;
  }
});

// node_modules/braces/lib/braces.js
var require_braces = __commonJS({
  "node_modules/braces/lib/braces.js"(exports, module2) {
    "use strict";
    var extend = require_extend_shallow4();
    var Snapdragon = require_snapdragon();
    var compilers = require_compilers();
    var parsers = require_parsers();
    var utils = require_utils3();
    function Braces(options) {
      this.options = extend({}, options);
    }
    Braces.prototype.init = function(options) {
      if (this.isInitialized)
        return;
      this.isInitialized = true;
      var opts = utils.createOptions({}, this.options, options);
      this.snapdragon = this.options.snapdragon || new Snapdragon(opts);
      this.compiler = this.snapdragon.compiler;
      this.parser = this.snapdragon.parser;
      compilers(this.snapdragon, opts);
      parsers(this.snapdragon, opts);
      utils.define(this.snapdragon, "parse", function(pattern, options2) {
        var parsed = Snapdragon.prototype.parse.apply(this, arguments);
        this.parser.ast.input = pattern;
        var stack = this.parser.stack;
        while (stack.length) {
          addParent({ type: "brace.close", val: "" }, stack.pop());
        }
        function addParent(node, parent) {
          utils.define(node, "parent", parent);
          parent.nodes.push(node);
        }
        utils.define(parsed, "parser", this.parser);
        return parsed;
      });
    };
    Braces.prototype.parse = function(ast, options) {
      if (ast && typeof ast === "object" && ast.nodes)
        return ast;
      this.init(options);
      return this.snapdragon.parse(ast, options);
    };
    Braces.prototype.compile = function(ast, options) {
      if (typeof ast === "string") {
        ast = this.parse(ast, options);
      } else {
        this.init(options);
      }
      return this.snapdragon.compile(ast, options);
    };
    Braces.prototype.expand = function(pattern) {
      var ast = this.parse(pattern, { expand: true });
      return this.compile(ast, { expand: true });
    };
    Braces.prototype.optimize = function(pattern) {
      var ast = this.parse(pattern, { optimize: true });
      return this.compile(ast, { optimize: true });
    };
    module2.exports = Braces;
  }
});

// node_modules/braces/index.js
var require_braces2 = __commonJS({
  "node_modules/braces/index.js"(exports, module2) {
    "use strict";
    var toRegex = require_to_regex();
    var unique = require_array_unique();
    var extend = require_extend_shallow4();
    var compilers = require_compilers();
    var parsers = require_parsers();
    var Braces = require_braces();
    var utils = require_utils3();
    var MAX_LENGTH = 1024 * 64;
    var cache = {};
    function braces(pattern, options) {
      var key = utils.createKey(String(pattern), options);
      var arr = [];
      var disabled = options && options.cache === false;
      if (!disabled && cache.hasOwnProperty(key)) {
        return cache[key];
      }
      if (Array.isArray(pattern)) {
        for (var i = 0; i < pattern.length; i++) {
          arr.push.apply(arr, braces.create(pattern[i], options));
        }
      } else {
        arr = braces.create(pattern, options);
      }
      if (options && options.nodupes === true) {
        arr = unique(arr);
      }
      if (!disabled) {
        cache[key] = arr;
      }
      return arr;
    }
    braces.expand = function(pattern, options) {
      return braces.create(pattern, extend({}, options, { expand: true }));
    };
    braces.optimize = function(pattern, options) {
      return braces.create(pattern, options);
    };
    braces.create = function(pattern, options) {
      if (typeof pattern !== "string") {
        throw new TypeError("expected a string");
      }
      var maxLength = options && options.maxLength || MAX_LENGTH;
      if (pattern.length >= maxLength) {
        throw new Error("expected pattern to be less than " + maxLength + " characters");
      }
      function create() {
        if (pattern === "" || pattern.length < 3) {
          return [pattern];
        }
        if (utils.isEmptySets(pattern)) {
          return [];
        }
        if (utils.isQuotedString(pattern)) {
          return [pattern.slice(1, -1)];
        }
        var proto = new Braces(options);
        var result = !options || options.expand !== true ? proto.optimize(pattern, options) : proto.expand(pattern, options);
        var arr = result.output;
        if (options && options.noempty === true) {
          arr = arr.filter(Boolean);
        }
        if (options && options.nodupes === true) {
          arr = unique(arr);
        }
        Object.defineProperty(arr, "result", {
          enumerable: false,
          value: result
        });
        return arr;
      }
      return memoize("create", pattern, options, create);
    };
    braces.makeRe = function(pattern, options) {
      if (typeof pattern !== "string") {
        throw new TypeError("expected a string");
      }
      var maxLength = options && options.maxLength || MAX_LENGTH;
      if (pattern.length >= maxLength) {
        throw new Error("expected pattern to be less than " + maxLength + " characters");
      }
      function makeRe() {
        var arr = braces(pattern, options);
        var opts = extend({ strictErrors: false }, options);
        return toRegex(arr, opts);
      }
      return memoize("makeRe", pattern, options, makeRe);
    };
    braces.parse = function(pattern, options) {
      var proto = new Braces(options);
      return proto.parse(pattern, options);
    };
    braces.compile = function(ast, options) {
      var proto = new Braces(options);
      return proto.compile(ast, options);
    };
    braces.clearCache = function() {
      cache = braces.cache = {};
    };
    function memoize(type, pattern, options, fn) {
      var key = utils.createKey(type + ":" + pattern, options);
      var disabled = options && options.cache === false;
      if (disabled) {
        braces.clearCache();
        return fn(pattern, options);
      }
      if (cache.hasOwnProperty(key)) {
        return cache[key];
      }
      var res = fn(pattern, options);
      cache[key] = res;
      return res;
    }
    braces.Braces = Braces;
    braces.compilers = compilers;
    braces.parsers = parsers;
    braces.cache = cache;
    module2.exports = braces;
  }
});

// node_modules/micromatch/node_modules/is-extendable/index.js
var require_is_extendable7 = __commonJS({
  "node_modules/micromatch/node_modules/is-extendable/index.js"(exports, module2) {
    "use strict";
    var isPlainObject = require_is_plain_object();
    module2.exports = function isExtendable(val) {
      return isPlainObject(val) || typeof val === "function" || Array.isArray(val);
    };
  }
});

// node_modules/micromatch/node_modules/extend-shallow/index.js
var require_extend_shallow6 = __commonJS({
  "node_modules/micromatch/node_modules/extend-shallow/index.js"(exports, module2) {
    "use strict";
    var isExtendable = require_is_extendable7();
    var assignSymbols = require_assign_symbols();
    module2.exports = Object.assign || function(obj) {
      if (obj === null || typeof obj === "undefined") {
        throw new TypeError("Cannot convert undefined or null to object");
      }
      if (!isObject(obj)) {
        obj = {};
      }
      for (var i = 1; i < arguments.length; i++) {
        var val = arguments[i];
        if (isString(val)) {
          val = toObject(val);
        }
        if (isObject(val)) {
          assign(obj, val);
          assignSymbols(obj, val);
        }
      }
      return obj;
    };
    function assign(a, b) {
      for (var key in b) {
        if (hasOwn(b, key)) {
          a[key] = b[key];
        }
      }
    }
    function isString(val) {
      return val && typeof val === "string";
    }
    function toObject(str) {
      var obj = {};
      for (var i in str) {
        obj[i] = str[i];
      }
      return obj;
    }
    function isObject(val) {
      return val && typeof val === "object" || isExtendable(val);
    }
    function hasOwn(obj, key) {
      return Object.prototype.hasOwnProperty.call(obj, key);
    }
  }
});

// node_modules/nanomatch/node_modules/is-extendable/index.js
var require_is_extendable8 = __commonJS({
  "node_modules/nanomatch/node_modules/is-extendable/index.js"(exports, module2) {
    "use strict";
    var isPlainObject = require_is_plain_object();
    module2.exports = function isExtendable(val) {
      return isPlainObject(val) || typeof val === "function" || Array.isArray(val);
    };
  }
});

// node_modules/nanomatch/node_modules/extend-shallow/index.js
var require_extend_shallow7 = __commonJS({
  "node_modules/nanomatch/node_modules/extend-shallow/index.js"(exports, module2) {
    "use strict";
    var isExtendable = require_is_extendable8();
    var assignSymbols = require_assign_symbols();
    module2.exports = Object.assign || function(obj) {
      if (obj === null || typeof obj === "undefined") {
        throw new TypeError("Cannot convert undefined or null to object");
      }
      if (!isObject(obj)) {
        obj = {};
      }
      for (var i = 1; i < arguments.length; i++) {
        var val = arguments[i];
        if (isString(val)) {
          val = toObject(val);
        }
        if (isObject(val)) {
          assign(obj, val);
          assignSymbols(obj, val);
        }
      }
      return obj;
    };
    function assign(a, b) {
      for (var key in b) {
        if (hasOwn(b, key)) {
          a[key] = b[key];
        }
      }
    }
    function isString(val) {
      return val && typeof val === "string";
    }
    function toObject(str) {
      var obj = {};
      for (var i in str) {
        obj[i] = str[i];
      }
      return obj;
    }
    function isObject(val) {
      return val && typeof val === "object" || isExtendable(val);
    }
    function hasOwn(obj, key) {
      return Object.prototype.hasOwnProperty.call(obj, key);
    }
  }
});

// node_modules/nanomatch/lib/compilers.js
var require_compilers2 = __commonJS({
  "node_modules/nanomatch/lib/compilers.js"(exports, module2) {
    "use strict";
    module2.exports = function(nanomatch, options) {
      function slash() {
        if (options && typeof options.slash === "string") {
          return options.slash;
        }
        if (options && typeof options.slash === "function") {
          return options.slash.call(nanomatch);
        }
        return "\\\\/";
      }
      function star() {
        if (options && typeof options.star === "string") {
          return options.star;
        }
        if (options && typeof options.star === "function") {
          return options.star.call(nanomatch);
        }
        return "[^" + slash() + "]*?";
      }
      var ast = nanomatch.ast = nanomatch.parser.ast;
      ast.state = nanomatch.parser.state;
      nanomatch.compiler.state = ast.state;
      nanomatch.compiler.set("not", function(node) {
        var prev = this.prev();
        if (this.options.nonegate === true || prev.type !== "bos") {
          return this.emit("\\" + node.val, node);
        }
        return this.emit(node.val, node);
      }).set("escape", function(node) {
        if (this.options.unescape && /^[-\w_.]/.test(node.val)) {
          return this.emit(node.val, node);
        }
        return this.emit("\\" + node.val, node);
      }).set("quoted", function(node) {
        return this.emit(node.val, node);
      }).set("dollar", function(node) {
        if (node.parent.type === "bracket") {
          return this.emit(node.val, node);
        }
        return this.emit("\\" + node.val, node);
      }).set("dot", function(node) {
        if (node.dotfiles === true)
          this.dotfiles = true;
        return this.emit("\\" + node.val, node);
      }).set("backslash", function(node) {
        return this.emit(node.val, node);
      }).set("slash", function(node, nodes, i) {
        var val = "[" + slash() + "]";
        var parent = node.parent;
        var prev = this.prev();
        while (parent.type === "paren" && !parent.hasSlash) {
          parent.hasSlash = true;
          parent = parent.parent;
        }
        if (prev.addQmark) {
          val += "?";
        }
        if (node.rest.slice(0, 2) === "\\b") {
          return this.emit(val, node);
        }
        if (node.parsed === "**" || node.parsed === "./**") {
          this.output = "(?:" + this.output;
          return this.emit(val + ")?", node);
        }
        if (node.parsed === "!**" && this.options.nonegate !== true) {
          return this.emit(val + "?\\b", node);
        }
        return this.emit(val, node);
      }).set("bracket", function(node) {
        var close = node.close;
        var open = !node.escaped ? "[" : "\\[";
        var negated = node.negated;
        var inner = node.inner;
        var val = node.val;
        if (node.escaped === true) {
          inner = inner.replace(/\\?(\W)/g, "\\$1");
          negated = "";
        }
        if (inner === "]-") {
          inner = "\\]\\-";
        }
        if (negated && inner.indexOf(".") === -1) {
          inner += ".";
        }
        if (negated && inner.indexOf("/") === -1) {
          inner += "/";
        }
        val = open + negated + inner + close;
        return this.emit(val, node);
      }).set("square", function(node) {
        var val = (/^\W/.test(node.val) ? "\\" : "") + node.val;
        return this.emit(val, node);
      }).set("qmark", function(node) {
        var prev = this.prev();
        var val = "[^.\\\\/]";
        if (this.options.dot || prev.type !== "bos" && prev.type !== "slash") {
          val = "[^\\\\/]";
        }
        if (node.parsed.slice(-1) === "(") {
          var ch = node.rest.charAt(0);
          if (ch === "!" || ch === "=" || ch === ":") {
            return this.emit(node.val, node);
          }
        }
        if (node.val.length > 1) {
          val += "{" + node.val.length + "}";
        }
        return this.emit(val, node);
      }).set("plus", function(node) {
        var prev = node.parsed.slice(-1);
        if (prev === "]" || prev === ")") {
          return this.emit(node.val, node);
        }
        if (!this.output || /[?*+]/.test(ch) && node.parent.type !== "bracket") {
          return this.emit("\\+", node);
        }
        var ch = this.output.slice(-1);
        if (/\w/.test(ch) && !node.inside) {
          return this.emit("+\\+?", node);
        }
        return this.emit("+", node);
      }).set("globstar", function(node, nodes, i) {
        if (!this.output) {
          this.state.leadingGlobstar = true;
        }
        var prev = this.prev();
        var before = this.prev(2);
        var next = this.next();
        var after = this.next(2);
        var type = prev.type;
        var val = node.val;
        if (prev.type === "slash" && next.type === "slash") {
          if (before.type === "text") {
            this.output += "?";
            if (after.type !== "text") {
              this.output += "\\b";
            }
          }
        }
        var parsed = node.parsed;
        if (parsed.charAt(0) === "!") {
          parsed = parsed.slice(1);
        }
        var isInside = node.isInside.paren || node.isInside.brace;
        if (parsed && type !== "slash" && type !== "bos" && !isInside) {
          val = star();
        } else {
          val = this.options.dot !== true ? "(?:(?!(?:[" + slash() + "]|^)\\.).)*?" : "(?:(?!(?:[" + slash() + "]|^)(?:\\.{1,2})($|[" + slash() + "]))(?!\\.{2}).)*?";
        }
        if ((type === "slash" || type === "bos") && this.options.dot !== true) {
          val = "(?!\\.)" + val;
        }
        if (prev.type === "slash" && next.type === "slash" && before.type !== "text") {
          if (after.type === "text" || after.type === "star") {
            node.addQmark = true;
          }
        }
        if (this.options.capture) {
          val = "(" + val + ")";
        }
        return this.emit(val, node);
      }).set("star", function(node, nodes, i) {
        var prior = nodes[i - 2] || {};
        var prev = this.prev();
        var next = this.next();
        var type = prev.type;
        function isStart(n) {
          return n.type === "bos" || n.type === "slash";
        }
        if (this.output === "" && this.options.contains !== true) {
          this.output = "(?![" + slash() + "])";
        }
        if (type === "bracket" && this.options.bash === false) {
          var str = next && next.type === "bracket" ? star() : "*?";
          if (!prev.nodes || prev.nodes[1].type !== "posix") {
            return this.emit(str, node);
          }
        }
        var prefix = !this.dotfiles && type !== "text" && type !== "escape" ? this.options.dot ? "(?!(?:^|[" + slash() + "])\\.{1,2}(?:$|[" + slash() + "]))" : "(?!\\.)" : "";
        if (isStart(prev) || isStart(prior) && type === "not") {
          if (prefix !== "(?!\\.)") {
            prefix += "(?!(\\.{2}|\\.[" + slash() + "]))(?=.)";
          } else {
            prefix += "(?=.)";
          }
        } else if (prefix === "(?!\\.)") {
          prefix = "";
        }
        if (prev.type === "not" && prior.type === "bos" && this.options.dot === true) {
          this.output = "(?!\\.)" + this.output;
        }
        var output = prefix + star();
        if (this.options.capture) {
          output = "(" + output + ")";
        }
        return this.emit(output, node);
      }).set("text", function(node) {
        return this.emit(node.val, node);
      }).set("eos", function(node) {
        var prev = this.prev();
        var val = node.val;
        this.output = "(?:\\.[" + slash() + "](?=.))?" + this.output;
        if (this.state.metachar && prev.type !== "qmark" && prev.type !== "slash") {
          val += this.options.contains ? "[" + slash() + "]?" : "(?:[" + slash() + "]|$)";
        }
        return this.emit(val, node);
      });
      if (options && typeof options.compilers === "function") {
        options.compilers(nanomatch.compiler);
      }
    };
  }
});

// node_modules/nanomatch/lib/parsers.js
var require_parsers2 = __commonJS({
  "node_modules/nanomatch/lib/parsers.js"(exports, module2) {
    "use strict";
    var regexNot = require_regex_not();
    var toRegex = require_to_regex();
    var cached;
    var NOT_REGEX = `[\\[!*+?$^"'.\\\\/]+`;
    var not = createTextRegex(NOT_REGEX);
    module2.exports = function(nanomatch, options) {
      var parser = nanomatch.parser;
      var opts = parser.options;
      parser.state = {
        slashes: 0,
        paths: []
      };
      parser.ast.state = parser.state;
      parser.capture("prefix", function() {
        if (this.parsed)
          return;
        var m = this.match(/^\.[\\/]/);
        if (!m)
          return;
        this.state.strictOpen = !!this.options.strictOpen;
        this.state.addPrefix = true;
      }).capture("escape", function() {
        if (this.isInside("bracket"))
          return;
        var pos = this.position();
        var m = this.match(/^(?:\\(.)|([$^]))/);
        if (!m)
          return;
        return pos({
          type: "escape",
          val: m[2] || m[1]
        });
      }).capture("quoted", function() {
        var pos = this.position();
        var m = this.match(/^["']/);
        if (!m)
          return;
        var quote = m[0];
        if (this.input.indexOf(quote) === -1) {
          return pos({
            type: "escape",
            val: quote
          });
        }
        var tok = advanceTo(this.input, quote);
        this.consume(tok.len);
        return pos({
          type: "quoted",
          val: tok.esc
        });
      }).capture("not", function() {
        var parsed = this.parsed;
        var pos = this.position();
        var m = this.match(this.notRegex || /^!+/);
        if (!m)
          return;
        var val = m[0];
        var isNegated = val.length % 2 === 1;
        if (parsed === "" && !isNegated) {
          val = "";
        }
        if (parsed === "" && isNegated && this.options.nonegate !== true) {
          this.bos.val = "(?!^(?:";
          this.append = ")$).*";
          val = "";
        }
        return pos({
          type: "not",
          val
        });
      }).capture("dot", function() {
        var parsed = this.parsed;
        var pos = this.position();
        var m = this.match(/^\.+/);
        if (!m)
          return;
        var val = m[0];
        this.state.dot = val === "." && (parsed === "" || parsed.slice(-1) === "/");
        return pos({
          type: "dot",
          dotfiles: this.state.dot,
          val
        });
      }).capture("plus", /^\+(?!\()/).capture("qmark", function() {
        var parsed = this.parsed;
        var pos = this.position();
        var m = this.match(/^\?+(?!\()/);
        if (!m)
          return;
        this.state.metachar = true;
        this.state.qmark = true;
        return pos({
          type: "qmark",
          parsed,
          val: m[0]
        });
      }).capture("globstar", function() {
        var parsed = this.parsed;
        var pos = this.position();
        var m = this.match(/^\*{2}(?![*(])(?=[,)/]|$)/);
        if (!m)
          return;
        var type = opts.noglobstar !== true ? "globstar" : "star";
        var node = pos({ type, parsed });
        this.state.metachar = true;
        while (this.input.slice(0, 4) === "/**/") {
          this.input = this.input.slice(3);
        }
        node.isInside = {
          brace: this.isInside("brace"),
          paren: this.isInside("paren")
        };
        if (type === "globstar") {
          this.state.globstar = true;
          node.val = "**";
        } else {
          this.state.star = true;
          node.val = "*";
        }
        return node;
      }).capture("star", function() {
        var pos = this.position();
        var starRe = /^(?:\*(?![*(])|[*]{3,}(?!\()|[*]{2}(?![(/]|$)|\*(?=\*\())/;
        var m = this.match(starRe);
        if (!m)
          return;
        this.state.metachar = true;
        this.state.star = true;
        return pos({
          type: "star",
          val: m[0]
        });
      }).capture("slash", function() {
        var pos = this.position();
        var m = this.match(/^\//);
        if (!m)
          return;
        this.state.slashes++;
        return pos({
          type: "slash",
          val: m[0]
        });
      }).capture("backslash", function() {
        var pos = this.position();
        var m = this.match(/^\\(?![*+?(){}[\]'"])/);
        if (!m)
          return;
        var val = m[0];
        if (this.isInside("bracket")) {
          val = "\\";
        } else if (val.length > 1) {
          val = "\\\\";
        }
        return pos({
          type: "backslash",
          val
        });
      }).capture("square", function() {
        if (this.isInside("bracket"))
          return;
        var pos = this.position();
        var m = this.match(/^\[([^!^\\])\]/);
        if (!m)
          return;
        return pos({
          type: "square",
          val: m[1]
        });
      }).capture("bracket", function() {
        var pos = this.position();
        var m = this.match(/^(?:\[([!^]?)([^\]]+|\]-)(\]|[^*+?]+)|\[)/);
        if (!m)
          return;
        var val = m[0];
        var negated = m[1] ? "^" : "";
        var inner = (m[2] || "").replace(/\\\\+/, "\\\\");
        var close = m[3] || "";
        if (m[2] && inner.length < m[2].length) {
          val = val.replace(/\\\\+/, "\\\\");
        }
        var esc = this.input.slice(0, 2);
        if (inner === "" && esc === "\\]") {
          inner += esc;
          this.consume(2);
          var str = this.input;
          var idx = -1;
          var ch;
          while (ch = str[++idx]) {
            this.consume(1);
            if (ch === "]") {
              close = ch;
              break;
            }
            inner += ch;
          }
        }
        return pos({
          type: "bracket",
          val,
          escaped: close !== "]",
          negated,
          inner,
          close
        });
      }).capture("text", function() {
        if (this.isInside("bracket"))
          return;
        var pos = this.position();
        var m = this.match(not);
        if (!m || !m[0])
          return;
        return pos({
          type: "text",
          val: m[0]
        });
      });
      if (options && typeof options.parsers === "function") {
        options.parsers(nanomatch.parser);
      }
    };
    function advanceTo(input, endChar) {
      var ch = input.charAt(0);
      var tok = { len: 1, val: "", esc: "" };
      var idx = 0;
      function advance() {
        if (ch !== "\\") {
          tok.esc += "\\" + ch;
          tok.val += ch;
        }
        ch = input.charAt(++idx);
        tok.len++;
        if (ch === "\\") {
          advance();
          advance();
        }
      }
      while (ch && ch !== endChar) {
        advance();
      }
      return tok;
    }
    function createTextRegex(pattern) {
      if (cached)
        return cached;
      var opts = { contains: true, strictClose: false };
      var not2 = regexNot.create(pattern, opts);
      var re = toRegex("^(?:[*]\\((?=.)|" + not2 + ")", opts);
      return cached = re;
    }
    module2.exports.not = NOT_REGEX;
  }
});

// node_modules/fragment-cache/index.js
var require_fragment_cache = __commonJS({
  "node_modules/fragment-cache/index.js"(exports, module2) {
    "use strict";
    var MapCache = require_map_cache();
    function FragmentCache(caches) {
      this.caches = caches || {};
    }
    FragmentCache.prototype = {
      cache: function(cacheName) {
        return this.caches[cacheName] || (this.caches[cacheName] = new MapCache());
      },
      set: function(cacheName, key, val) {
        var cache = this.cache(cacheName);
        cache.set(key, val);
        return cache;
      },
      has: function(cacheName, key) {
        return typeof this.get(cacheName, key) !== "undefined";
      },
      get: function(name, key) {
        var cache = this.cache(name);
        if (typeof key === "string") {
          return cache.get(key);
        }
        return cache;
      }
    };
    exports = module2.exports = FragmentCache;
  }
});

// node_modules/nanomatch/lib/cache.js
var require_cache = __commonJS({
  "node_modules/nanomatch/lib/cache.js"(exports, module2) {
    module2.exports = new (require_fragment_cache())();
  }
});

// node_modules/is-windows/index.js
var require_is_windows = __commonJS({
  "node_modules/is-windows/index.js"(exports, module2) {
    (function(factory) {
      if (exports && typeof exports === "object" && typeof module2 !== "undefined") {
        module2.exports = factory();
      } else if (typeof define === "function" && define.amd) {
        define([], factory);
      } else if (typeof window !== "undefined") {
        window.isWindows = factory();
      } else if (typeof global !== "undefined") {
        global.isWindows = factory();
      } else if (typeof self !== "undefined") {
        self.isWindows = factory();
      } else {
        this.isWindows = factory();
      }
    })(function() {
      "use strict";
      return function isWindows() {
        return process && (process.platform === "win32" || /^(msys|cygwin)$/.test(process.env.OSTYPE));
      };
    });
  }
});

// node_modules/nanomatch/node_modules/define-property/index.js
var require_define_property6 = __commonJS({
  "node_modules/nanomatch/node_modules/define-property/index.js"(exports, module2) {
    "use strict";
    var isobject = require_isobject();
    var isDescriptor = require_is_descriptor();
    var define2 = typeof Reflect !== "undefined" && Reflect.defineProperty ? Reflect.defineProperty : Object.defineProperty;
    module2.exports = function defineProperty(obj, key, val) {
      if (!isobject(obj) && typeof obj !== "function" && !Array.isArray(obj)) {
        throw new TypeError("expected an object, function, or array");
      }
      if (typeof key !== "string") {
        throw new TypeError('expected "key" to be a string');
      }
      if (isDescriptor(val)) {
        define2(obj, key, val);
        return obj;
      }
      define2(obj, key, {
        configurable: true,
        enumerable: false,
        writable: true,
        value: val
      });
      return obj;
    };
  }
});

// node_modules/arr-diff/index.js
var require_arr_diff = __commonJS({
  "node_modules/arr-diff/index.js"(exports, module2) {
    "use strict";
    module2.exports = function diff(arr) {
      var len = arguments.length;
      var idx = 0;
      while (++idx < len) {
        arr = diffArray(arr, arguments[idx]);
      }
      return arr;
    };
    function diffArray(one, two) {
      if (!Array.isArray(two)) {
        return one.slice();
      }
      var tlen = two.length;
      var olen = one.length;
      var idx = -1;
      var arr = [];
      while (++idx < olen) {
        var ele = one[idx];
        var hasEle = false;
        for (var i = 0; i < tlen; i++) {
          var val = two[i];
          if (ele === val) {
            hasEle = true;
            break;
          }
        }
        if (hasEle === false) {
          arr.push(ele);
        }
      }
      return arr;
    }
  }
});

// node_modules/object.pick/index.js
var require_object2 = __commonJS({
  "node_modules/object.pick/index.js"(exports, module2) {
    "use strict";
    var isObject = require_isobject();
    module2.exports = function pick(obj, keys) {
      if (!isObject(obj) && typeof obj !== "function") {
        return {};
      }
      var res = {};
      if (typeof keys === "string") {
        if (keys in obj) {
          res[keys] = obj[keys];
        }
        return res;
      }
      var len = keys.length;
      var idx = -1;
      while (++idx < len) {
        var key = keys[idx];
        if (key in obj) {
          res[key] = obj[key];
        }
      }
      return res;
    };
  }
});

// node_modules/nanomatch/lib/utils.js
var require_utils5 = __commonJS({
  "node_modules/nanomatch/lib/utils.js"(exports, module2) {
    "use strict";
    var utils = module2.exports;
    var path = require("path");
    var isWindows = require_is_windows()();
    var Snapdragon = require_snapdragon();
    utils.define = require_define_property6();
    utils.diff = require_arr_diff();
    utils.extend = require_extend_shallow7();
    utils.pick = require_object2();
    utils.typeOf = require_kind_of();
    utils.unique = require_array_unique();
    utils.isEmptyString = function(val) {
      return String(val) === "" || String(val) === "./";
    };
    utils.isWindows = function() {
      return path.sep === "\\" || isWindows === true;
    };
    utils.last = function(arr, n) {
      return arr[arr.length - (n || 1)];
    };
    utils.instantiate = function(ast, options) {
      var snapdragon;
      if (utils.typeOf(ast) === "object" && ast.snapdragon) {
        snapdragon = ast.snapdragon;
      } else if (utils.typeOf(options) === "object" && options.snapdragon) {
        snapdragon = options.snapdragon;
      } else {
        snapdragon = new Snapdragon(options);
      }
      utils.define(snapdragon, "parse", function(str, options2) {
        var parsed = Snapdragon.prototype.parse.call(this, str, options2);
        parsed.input = str;
        var last = this.parser.stack.pop();
        if (last && this.options.strictErrors !== true) {
          var open = last.nodes[0];
          var inner = last.nodes[1];
          if (last.type === "bracket") {
            if (inner.val.charAt(0) === "[") {
              inner.val = "\\" + inner.val;
            }
          } else {
            open.val = "\\" + open.val;
            var sibling = open.parent.nodes[1];
            if (sibling.type === "star") {
              sibling.loose = true;
            }
          }
        }
        utils.define(parsed, "parser", this.parser);
        return parsed;
      });
      return snapdragon;
    };
    utils.createKey = function(pattern, options) {
      if (typeof options === "undefined") {
        return pattern;
      }
      var key = pattern;
      for (var prop in options) {
        if (options.hasOwnProperty(prop)) {
          key += ";" + prop + "=" + String(options[prop]);
        }
      }
      return key;
    };
    utils.arrayify = function(val) {
      if (typeof val === "string")
        return [val];
      return val ? Array.isArray(val) ? val : [val] : [];
    };
    utils.isString = function(val) {
      return typeof val === "string";
    };
    utils.isRegex = function(val) {
      return utils.typeOf(val) === "regexp";
    };
    utils.isObject = function(val) {
      return utils.typeOf(val) === "object";
    };
    utils.escapeRegex = function(str) {
      return str.replace(/[-[\]{}()^$|*+?.\\/\s]/g, "\\$&");
    };
    utils.combineDupes = function(input, patterns) {
      patterns = utils.arrayify(patterns).join("|").split("|");
      patterns = patterns.map(function(s) {
        return s.replace(/\\?([+*\\/])/g, "\\$1");
      });
      var substr = patterns.join("|");
      var regex = new RegExp("(" + substr + ")(?=\\1)", "g");
      return input.replace(regex, "");
    };
    utils.hasSpecialChars = function(str) {
      return /(?:(?:(^|\/)[!.])|[*?+()|[\]{}]|[+@]\()/.test(str);
    };
    utils.toPosixPath = function(str) {
      return str.replace(/\\+/g, "/");
    };
    utils.unescape = function(str) {
      return utils.toPosixPath(str.replace(/\\(?=[*+?!.])/g, ""));
    };
    utils.stripDrive = function(fp) {
      return utils.isWindows() ? fp.replace(/^[a-z]:[\\/]+?/i, "/") : fp;
    };
    utils.stripPrefix = function(str) {
      if (str.charAt(0) === "." && (str.charAt(1) === "/" || str.charAt(1) === "\\")) {
        return str.slice(2);
      }
      return str;
    };
    utils.isSimpleChar = function(str) {
      return str.trim() === "" || str === ".";
    };
    utils.isSlash = function(str) {
      return str === "/" || str === "\\/" || str === "\\" || str === "\\\\";
    };
    utils.matchPath = function(pattern, options) {
      return options && options.contains ? utils.containsPattern(pattern, options) : utils.equalsPattern(pattern, options);
    };
    utils._equals = function(filepath, unixPath, pattern) {
      return pattern === filepath || pattern === unixPath;
    };
    utils._contains = function(filepath, unixPath, pattern) {
      return filepath.indexOf(pattern) !== -1 || unixPath.indexOf(pattern) !== -1;
    };
    utils.equalsPattern = function(pattern, options) {
      var unixify = utils.unixify(options);
      options = options || {};
      return function fn(filepath) {
        var equal = utils._equals(filepath, unixify(filepath), pattern);
        if (equal === true || options.nocase !== true) {
          return equal;
        }
        var lower = filepath.toLowerCase();
        return utils._equals(lower, unixify(lower), pattern);
      };
    };
    utils.containsPattern = function(pattern, options) {
      var unixify = utils.unixify(options);
      options = options || {};
      return function(filepath) {
        var contains = utils._contains(filepath, unixify(filepath), pattern);
        if (contains === true || options.nocase !== true) {
          return contains;
        }
        var lower = filepath.toLowerCase();
        return utils._contains(lower, unixify(lower), pattern);
      };
    };
    utils.matchBasename = function(re) {
      return function(filepath) {
        return re.test(filepath) || re.test(path.basename(filepath));
      };
    };
    utils.identity = function(val) {
      return val;
    };
    utils.value = function(str, unixify, options) {
      if (options && options.unixify === false) {
        return str;
      }
      if (options && typeof options.unixify === "function") {
        return options.unixify(str);
      }
      return unixify(str);
    };
    utils.unixify = function(options) {
      var opts = options || {};
      return function(filepath) {
        if (opts.stripPrefix !== false) {
          filepath = utils.stripPrefix(filepath);
        }
        if (opts.unescape === true) {
          filepath = utils.unescape(filepath);
        }
        if (opts.unixify === true || utils.isWindows()) {
          filepath = utils.toPosixPath(filepath);
        }
        return filepath;
      };
    };
  }
});

// node_modules/nanomatch/index.js
var require_nanomatch = __commonJS({
  "node_modules/nanomatch/index.js"(exports, module2) {
    "use strict";
    var util = require("util");
    var toRegex = require_to_regex();
    var extend = require_extend_shallow7();
    var compilers = require_compilers2();
    var parsers = require_parsers2();
    var cache = require_cache();
    var utils = require_utils5();
    var MAX_LENGTH = 1024 * 64;
    function nanomatch(list, patterns, options) {
      patterns = utils.arrayify(patterns);
      list = utils.arrayify(list);
      var len = patterns.length;
      if (list.length === 0 || len === 0) {
        return [];
      }
      if (len === 1) {
        return nanomatch.match(list, patterns[0], options);
      }
      var negated = false;
      var omit = [];
      var keep = [];
      var idx = -1;
      while (++idx < len) {
        var pattern = patterns[idx];
        if (typeof pattern === "string" && pattern.charCodeAt(0) === 33) {
          omit.push.apply(omit, nanomatch.match(list, pattern.slice(1), options));
          negated = true;
        } else {
          keep.push.apply(keep, nanomatch.match(list, pattern, options));
        }
      }
      if (negated && keep.length === 0) {
        if (options && options.unixify === false) {
          keep = list.slice();
        } else {
          var unixify = utils.unixify(options);
          for (var i = 0; i < list.length; i++) {
            keep.push(unixify(list[i]));
          }
        }
      }
      var matches = utils.diff(keep, omit);
      if (!options || options.nodupes !== false) {
        return utils.unique(matches);
      }
      return matches;
    }
    nanomatch.match = function(list, pattern, options) {
      if (Array.isArray(pattern)) {
        throw new TypeError("expected pattern to be a string");
      }
      var unixify = utils.unixify(options);
      var isMatch = memoize("match", pattern, options, nanomatch.matcher);
      var matches = [];
      list = utils.arrayify(list);
      var len = list.length;
      var idx = -1;
      while (++idx < len) {
        var ele = list[idx];
        if (ele === pattern || isMatch(ele)) {
          matches.push(utils.value(ele, unixify, options));
        }
      }
      if (typeof options === "undefined") {
        return utils.unique(matches);
      }
      if (matches.length === 0) {
        if (options.failglob === true) {
          throw new Error('no matches found for "' + pattern + '"');
        }
        if (options.nonull === true || options.nullglob === true) {
          return [options.unescape ? utils.unescape(pattern) : pattern];
        }
      }
      if (options.ignore) {
        matches = nanomatch.not(matches, options.ignore, options);
      }
      return options.nodupes !== false ? utils.unique(matches) : matches;
    };
    nanomatch.isMatch = function(str, pattern, options) {
      if (typeof str !== "string") {
        throw new TypeError('expected a string: "' + util.inspect(str) + '"');
      }
      if (utils.isEmptyString(str) || utils.isEmptyString(pattern)) {
        return false;
      }
      var equals = utils.equalsPattern(options);
      if (equals(str)) {
        return true;
      }
      var isMatch = memoize("isMatch", pattern, options, nanomatch.matcher);
      return isMatch(str);
    };
    nanomatch.some = function(list, patterns, options) {
      if (typeof list === "string") {
        list = [list];
      }
      for (var i = 0; i < list.length; i++) {
        if (nanomatch(list[i], patterns, options).length === 1) {
          return true;
        }
      }
      return false;
    };
    nanomatch.every = function(list, patterns, options) {
      if (typeof list === "string") {
        list = [list];
      }
      for (var i = 0; i < list.length; i++) {
        if (nanomatch(list[i], patterns, options).length !== 1) {
          return false;
        }
      }
      return true;
    };
    nanomatch.any = function(str, patterns, options) {
      if (typeof str !== "string") {
        throw new TypeError('expected a string: "' + util.inspect(str) + '"');
      }
      if (utils.isEmptyString(str) || utils.isEmptyString(patterns)) {
        return false;
      }
      if (typeof patterns === "string") {
        patterns = [patterns];
      }
      for (var i = 0; i < patterns.length; i++) {
        if (nanomatch.isMatch(str, patterns[i], options)) {
          return true;
        }
      }
      return false;
    };
    nanomatch.all = function(str, patterns, options) {
      if (typeof str !== "string") {
        throw new TypeError('expected a string: "' + util.inspect(str) + '"');
      }
      if (typeof patterns === "string") {
        patterns = [patterns];
      }
      for (var i = 0; i < patterns.length; i++) {
        if (!nanomatch.isMatch(str, patterns[i], options)) {
          return false;
        }
      }
      return true;
    };
    nanomatch.not = function(list, patterns, options) {
      var opts = extend({}, options);
      var ignore = opts.ignore;
      delete opts.ignore;
      list = utils.arrayify(list);
      var matches = utils.diff(list, nanomatch(list, patterns, opts));
      if (ignore) {
        matches = utils.diff(matches, nanomatch(list, ignore));
      }
      return opts.nodupes !== false ? utils.unique(matches) : matches;
    };
    nanomatch.contains = function(str, patterns, options) {
      if (typeof str !== "string") {
        throw new TypeError('expected a string: "' + util.inspect(str) + '"');
      }
      if (typeof patterns === "string") {
        if (utils.isEmptyString(str) || utils.isEmptyString(patterns)) {
          return false;
        }
        var equals = utils.equalsPattern(patterns, options);
        if (equals(str)) {
          return true;
        }
        var contains = utils.containsPattern(patterns, options);
        if (contains(str)) {
          return true;
        }
      }
      var opts = extend({}, options, { contains: true });
      return nanomatch.any(str, patterns, opts);
    };
    nanomatch.matchBase = function(pattern, options) {
      if (pattern && pattern.indexOf("/") !== -1 || !options)
        return false;
      return options.basename === true || options.matchBase === true;
    };
    nanomatch.matchKeys = function(obj, patterns, options) {
      if (!utils.isObject(obj)) {
        throw new TypeError("expected the first argument to be an object");
      }
      var keys = nanomatch(Object.keys(obj), patterns, options);
      return utils.pick(obj, keys);
    };
    nanomatch.matcher = function matcher(pattern, options) {
      if (utils.isEmptyString(pattern)) {
        return function() {
          return false;
        };
      }
      if (Array.isArray(pattern)) {
        return compose(pattern, options, matcher);
      }
      if (pattern instanceof RegExp) {
        return test(pattern);
      }
      if (!utils.isString(pattern)) {
        throw new TypeError("expected pattern to be an array, string or regex");
      }
      if (!utils.hasSpecialChars(pattern)) {
        if (options && options.nocase === true) {
          pattern = pattern.toLowerCase();
        }
        return utils.matchPath(pattern, options);
      }
      var re = nanomatch.makeRe(pattern, options);
      if (nanomatch.matchBase(pattern, options)) {
        return utils.matchBasename(re, options);
      }
      function test(regex) {
        var equals = utils.equalsPattern(options);
        var unixify = utils.unixify(options);
        return function(str) {
          if (equals(str)) {
            return true;
          }
          if (regex.test(unixify(str))) {
            return true;
          }
          return false;
        };
      }
      var matcherFn = test(re);
      utils.define(matcherFn, "result", re.result);
      return matcherFn;
    };
    nanomatch.capture = function(pattern, str, options) {
      var re = nanomatch.makeRe(pattern, extend({ capture: true }, options));
      var unixify = utils.unixify(options);
      function match() {
        return function(string) {
          var match2 = re.exec(unixify(string));
          if (!match2) {
            return null;
          }
          return match2.slice(1);
        };
      }
      var capture = memoize("capture", pattern, options, match);
      return capture(str);
    };
    nanomatch.makeRe = function(pattern, options) {
      if (pattern instanceof RegExp) {
        return pattern;
      }
      if (typeof pattern !== "string") {
        throw new TypeError("expected pattern to be a string");
      }
      if (pattern.length > MAX_LENGTH) {
        throw new Error("expected pattern to be less than " + MAX_LENGTH + " characters");
      }
      function makeRe() {
        var opts = utils.extend({ wrap: false }, options);
        var result = nanomatch.create(pattern, opts);
        var regex = toRegex(result.output, opts);
        utils.define(regex, "result", result);
        return regex;
      }
      return memoize("makeRe", pattern, options, makeRe);
    };
    nanomatch.create = function(pattern, options) {
      if (typeof pattern !== "string") {
        throw new TypeError("expected a string");
      }
      function create() {
        return nanomatch.compile(nanomatch.parse(pattern, options), options);
      }
      return memoize("create", pattern, options, create);
    };
    nanomatch.parse = function(pattern, options) {
      if (typeof pattern !== "string") {
        throw new TypeError("expected a string");
      }
      function parse() {
        var snapdragon = utils.instantiate(null, options);
        parsers(snapdragon, options);
        var ast = snapdragon.parse(pattern, options);
        utils.define(ast, "snapdragon", snapdragon);
        ast.input = pattern;
        return ast;
      }
      return memoize("parse", pattern, options, parse);
    };
    nanomatch.compile = function(ast, options) {
      if (typeof ast === "string") {
        ast = nanomatch.parse(ast, options);
      }
      function compile() {
        var snapdragon = utils.instantiate(ast, options);
        compilers(snapdragon, options);
        return snapdragon.compile(ast, options);
      }
      return memoize("compile", ast.input, options, compile);
    };
    nanomatch.clearCache = function() {
      nanomatch.cache.__data__ = {};
    };
    function compose(patterns, options, matcher) {
      var matchers;
      return memoize("compose", String(patterns), options, function() {
        return function(file) {
          if (!matchers) {
            matchers = [];
            for (var i = 0; i < patterns.length; i++) {
              matchers.push(matcher(patterns[i], options));
            }
          }
          var len = matchers.length;
          while (len--) {
            if (matchers[len](file) === true) {
              return true;
            }
          }
          return false;
        };
      });
    }
    function memoize(type, pattern, options, fn) {
      var key = utils.createKey(type + "=" + pattern, options);
      if (options && options.cache === false) {
        return fn(pattern, options);
      }
      if (cache.has(type, key)) {
        return cache.get(type, key);
      }
      var val = fn(pattern, options);
      cache.set(type, key, val);
      return val;
    }
    nanomatch.compilers = compilers;
    nanomatch.parsers = parsers;
    nanomatch.cache = cache;
    module2.exports = nanomatch;
  }
});

// node_modules/posix-character-classes/index.js
var require_posix_character_classes = __commonJS({
  "node_modules/posix-character-classes/index.js"(exports, module2) {
    "use strict";
    module2.exports = {
      alnum: "a-zA-Z0-9",
      alpha: "a-zA-Z",
      ascii: "\\x00-\\x7F",
      blank: " \\t",
      cntrl: "\\x00-\\x1F\\x7F",
      digit: "0-9",
      graph: "\\x21-\\x7E",
      lower: "a-z",
      print: "\\x20-\\x7E ",
      punct: "\\-!\"#$%&'()\\*+,./:;<=>?@[\\]^_`{|}~",
      space: " \\t\\r\\n\\v\\f",
      upper: "A-Z",
      word: "A-Za-z0-9_",
      xdigit: "A-Fa-f0-9"
    };
  }
});

// node_modules/expand-brackets/lib/compilers.js
var require_compilers3 = __commonJS({
  "node_modules/expand-brackets/lib/compilers.js"(exports, module2) {
    "use strict";
    var posix = require_posix_character_classes();
    module2.exports = function(brackets) {
      brackets.compiler.set("escape", function(node) {
        return this.emit("\\" + node.val.replace(/^\\/, ""), node);
      }).set("text", function(node) {
        return this.emit(node.val.replace(/([{}])/g, "\\$1"), node);
      }).set("posix", function(node) {
        if (node.val === "[::]") {
          return this.emit("\\[::\\]", node);
        }
        var val = posix[node.inner];
        if (typeof val === "undefined") {
          val = "[" + node.inner + "]";
        }
        return this.emit(val, node);
      }).set("bracket", function(node) {
        return this.mapVisit(node.nodes);
      }).set("bracket.open", function(node) {
        return this.emit(node.val, node);
      }).set("bracket.inner", function(node) {
        var inner = node.val;
        if (inner === "[" || inner === "]") {
          return this.emit("\\" + node.val, node);
        }
        if (inner === "^]") {
          return this.emit("^\\]", node);
        }
        if (inner === "^") {
          return this.emit("^", node);
        }
        if (/-/.test(inner) && !/(\d-\d|\w-\w)/.test(inner)) {
          inner = inner.split("-").join("\\-");
        }
        var isNegated = inner.charAt(0) === "^";
        if (isNegated && inner.indexOf("/") === -1) {
          inner += "/";
        }
        if (isNegated && inner.indexOf(".") === -1) {
          inner += ".";
        }
        inner = inner.replace(/\\([1-9])/g, "$1");
        return this.emit(inner, node);
      }).set("bracket.close", function(node) {
        var val = node.val.replace(/^\\/, "");
        if (node.parent.escaped === true) {
          return this.emit("\\" + val, node);
        }
        return this.emit(val, node);
      });
    };
  }
});

// node_modules/expand-brackets/lib/utils.js
var require_utils6 = __commonJS({
  "node_modules/expand-brackets/lib/utils.js"(exports) {
    "use strict";
    var toRegex = require_to_regex();
    var regexNot = require_regex_not();
    var cached;
    exports.last = function(arr) {
      return arr[arr.length - 1];
    };
    exports.createRegex = function(pattern, include) {
      if (cached)
        return cached;
      var opts = { contains: true, strictClose: false };
      var not = regexNot.create(pattern, opts);
      var re;
      if (typeof include === "string") {
        re = toRegex("^(?:" + include + "|" + not + ")", opts);
      } else {
        re = toRegex(not, opts);
      }
      return cached = re;
    };
  }
});

// node_modules/expand-brackets/lib/parsers.js
var require_parsers3 = __commonJS({
  "node_modules/expand-brackets/lib/parsers.js"(exports, module2) {
    "use strict";
    var utils = require_utils6();
    var define2 = require_define_property5();
    var TEXT_REGEX = "(\\[(?=.*\\])|\\])+";
    var not = utils.createRegex(TEXT_REGEX);
    function parsers(brackets) {
      brackets.state = brackets.state || {};
      brackets.parser.sets.bracket = brackets.parser.sets.bracket || [];
      brackets.parser.capture("escape", function() {
        if (this.isInside("bracket"))
          return;
        var pos = this.position();
        var m = this.match(/^\\(.)/);
        if (!m)
          return;
        return pos({
          type: "escape",
          val: m[0]
        });
      }).capture("text", function() {
        if (this.isInside("bracket"))
          return;
        var pos = this.position();
        var m = this.match(not);
        if (!m || !m[0])
          return;
        return pos({
          type: "text",
          val: m[0]
        });
      }).capture("posix", function() {
        var pos = this.position();
        var m = this.match(/^\[:(.*?):\](?=.*\])/);
        if (!m)
          return;
        var inside = this.isInside("bracket");
        if (inside) {
          brackets.posix++;
        }
        return pos({
          type: "posix",
          insideBracket: inside,
          inner: m[1],
          val: m[0]
        });
      }).capture("bracket", function() {
      }).capture("bracket.open", function() {
        var parsed = this.parsed;
        var pos = this.position();
        var m = this.match(/^\[(?=.*\])/);
        if (!m)
          return;
        var prev = this.prev();
        var last = utils.last(prev.nodes);
        if (parsed.slice(-1) === "\\" && !this.isInside("bracket")) {
          last.val = last.val.slice(0, last.val.length - 1);
          return pos({
            type: "escape",
            val: m[0]
          });
        }
        var open = pos({
          type: "bracket.open",
          val: m[0]
        });
        if (last.type === "bracket.open" || this.isInside("bracket")) {
          open.val = "\\" + open.val;
          open.type = "bracket.inner";
          open.escaped = true;
          return open;
        }
        var node = pos({
          type: "bracket",
          nodes: [open]
        });
        define2(node, "parent", prev);
        define2(open, "parent", node);
        this.push("bracket", node);
        prev.nodes.push(node);
      }).capture("bracket.inner", function() {
        if (!this.isInside("bracket"))
          return;
        var pos = this.position();
        var m = this.match(not);
        if (!m || !m[0])
          return;
        var next = this.input.charAt(0);
        var val = m[0];
        var node = pos({
          type: "bracket.inner",
          val
        });
        if (val === "\\\\") {
          return node;
        }
        var first = val.charAt(0);
        var last = val.slice(-1);
        if (first === "!") {
          val = "^" + val.slice(1);
        }
        if (last === "\\" || val === "^" && next === "]") {
          val += this.input[0];
          this.consume(1);
        }
        node.val = val;
        return node;
      }).capture("bracket.close", function() {
        var parsed = this.parsed;
        var pos = this.position();
        var m = this.match(/^\]/);
        if (!m)
          return;
        var prev = this.prev();
        var last = utils.last(prev.nodes);
        if (parsed.slice(-1) === "\\" && !this.isInside("bracket")) {
          last.val = last.val.slice(0, last.val.length - 1);
          return pos({
            type: "escape",
            val: m[0]
          });
        }
        var node = pos({
          type: "bracket.close",
          rest: this.input,
          val: m[0]
        });
        if (last.type === "bracket.open") {
          node.type = "bracket.inner";
          node.escaped = true;
          return node;
        }
        var bracket = this.pop("bracket");
        if (!this.isType(bracket, "bracket")) {
          if (this.options.strict) {
            throw new Error('missing opening "["');
          }
          node.type = "bracket.inner";
          node.escaped = true;
          return node;
        }
        bracket.nodes.push(node);
        define2(node, "parent", bracket);
      });
    }
    module2.exports = parsers;
    module2.exports.TEXT_REGEX = TEXT_REGEX;
  }
});

// node_modules/expand-brackets/node_modules/ms/index.js
var require_ms2 = __commonJS({
  "node_modules/expand-brackets/node_modules/ms/index.js"(exports, module2) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isNaN(val) === false) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      if (ms >= d) {
        return Math.round(ms / d) + "d";
      }
      if (ms >= h) {
        return Math.round(ms / h) + "h";
      }
      if (ms >= m) {
        return Math.round(ms / m) + "m";
      }
      if (ms >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      return plural(ms, d, "day") || plural(ms, h, "hour") || plural(ms, m, "minute") || plural(ms, s, "second") || ms + " ms";
    }
    function plural(ms, n, name) {
      if (ms < n) {
        return;
      }
      if (ms < n * 1.5) {
        return Math.floor(ms / n) + " " + name;
      }
      return Math.ceil(ms / n) + " " + name + "s";
    }
  }
});

// node_modules/expand-brackets/node_modules/debug/src/debug.js
var require_debug2 = __commonJS({
  "node_modules/expand-brackets/node_modules/debug/src/debug.js"(exports, module2) {
    exports = module2.exports = createDebug.debug = createDebug["default"] = createDebug;
    exports.coerce = coerce;
    exports.disable = disable;
    exports.enable = enable;
    exports.enabled = enabled;
    exports.humanize = require_ms2();
    exports.names = [];
    exports.skips = [];
    exports.formatters = {};
    var prevTime;
    function selectColor(namespace) {
      var hash = 0, i;
      for (i in namespace) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return exports.colors[Math.abs(hash) % exports.colors.length];
    }
    function createDebug(namespace) {
      function debug() {
        if (!debug.enabled)
          return;
        var self2 = debug;
        var curr = +new Date();
        var ms = curr - (prevTime || curr);
        self2.diff = ms;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        args[0] = exports.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        var index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
          if (match === "%%")
            return match;
          index++;
          var formatter = exports.formatters[format];
          if (typeof formatter === "function") {
            var val = args[index];
            match = formatter.call(self2, val);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        exports.formatArgs.call(self2, args);
        var logFn = debug.log || exports.log || console.log.bind(console);
        logFn.apply(self2, args);
      }
      debug.namespace = namespace;
      debug.enabled = exports.enabled(namespace);
      debug.useColors = exports.useColors();
      debug.color = selectColor(namespace);
      if (typeof exports.init === "function") {
        exports.init(debug);
      }
      return debug;
    }
    function enable(namespaces) {
      exports.save(namespaces);
      exports.names = [];
      exports.skips = [];
      var split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      var len = split.length;
      for (var i = 0; i < len; i++) {
        if (!split[i])
          continue;
        namespaces = split[i].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          exports.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
        } else {
          exports.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
    }
    function disable() {
      exports.enable("");
    }
    function enabled(name) {
      var i, len;
      for (i = 0, len = exports.skips.length; i < len; i++) {
        if (exports.skips[i].test(name)) {
          return false;
        }
      }
      for (i = 0, len = exports.names.length; i < len; i++) {
        if (exports.names[i].test(name)) {
          return true;
        }
      }
      return false;
    }
    function coerce(val) {
      if (val instanceof Error)
        return val.stack || val.message;
      return val;
    }
  }
});

// node_modules/expand-brackets/node_modules/debug/src/browser.js
var require_browser2 = __commonJS({
  "node_modules/expand-brackets/node_modules/debug/src/browser.js"(exports, module2) {
    exports = module2.exports = require_debug2();
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = typeof chrome != "undefined" && typeof chrome.storage != "undefined" ? chrome.storage.local : localstorage();
    exports.colors = [
      "lightseagreen",
      "forestgreen",
      "goldenrod",
      "dodgerblue",
      "darkorchid",
      "crimson"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && window.process.type === "renderer") {
        return true;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    exports.formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (err) {
        return "[UnexpectedJSONParseError]: " + err.message;
      }
    };
    function formatArgs(args) {
      var useColors2 = this.useColors;
      args[0] = (useColors2 ? "%c" : "") + this.namespace + (useColors2 ? " %c" : " ") + args[0] + (useColors2 ? "%c " : " ") + "+" + exports.humanize(this.diff);
      if (!useColors2)
        return;
      var c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      var index = 0;
      var lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, function(match) {
        if (match === "%%")
          return;
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    function log() {
      return typeof console === "object" && console.log && Function.prototype.apply.call(console.log, console, arguments);
    }
    function save(namespaces) {
      try {
        if (namespaces == null) {
          exports.storage.removeItem("debug");
        } else {
          exports.storage.debug = namespaces;
        }
      } catch (e) {
      }
    }
    function load() {
      var r;
      try {
        r = exports.storage.debug;
      } catch (e) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    exports.enable(load());
    function localstorage() {
      try {
        return window.localStorage;
      } catch (e) {
      }
    }
  }
});

// node_modules/expand-brackets/index.js
var require_expand_brackets = __commonJS({
  "node_modules/expand-brackets/index.js"(exports, module2) {
    "use strict";
    var compilers = require_compilers3();
    var parsers = require_parsers3();
    var debug = require_browser2()("expand-brackets");
    var extend = require_extend_shallow4();
    var Snapdragon = require_snapdragon();
    var toRegex = require_to_regex();
    function brackets(pattern, options) {
      debug("initializing from <%s>", __filename);
      var res = brackets.create(pattern, options);
      return res.output;
    }
    brackets.match = function(arr, pattern, options) {
      arr = [].concat(arr);
      var opts = extend({}, options);
      var isMatch = brackets.matcher(pattern, opts);
      var len = arr.length;
      var idx = -1;
      var res = [];
      while (++idx < len) {
        var ele = arr[idx];
        if (isMatch(ele)) {
          res.push(ele);
        }
      }
      if (res.length === 0) {
        if (opts.failglob === true) {
          throw new Error('no matches found for "' + pattern + '"');
        }
        if (opts.nonull === true || opts.nullglob === true) {
          return [pattern.split("\\").join("")];
        }
      }
      return res;
    };
    brackets.isMatch = function(str, pattern, options) {
      return brackets.matcher(pattern, options)(str);
    };
    brackets.matcher = function(pattern, options) {
      var re = brackets.makeRe(pattern, options);
      return function(str) {
        return re.test(str);
      };
    };
    brackets.makeRe = function(pattern, options) {
      var res = brackets.create(pattern, options);
      var opts = extend({ strictErrors: false }, options);
      return toRegex(res.output, opts);
    };
    brackets.create = function(pattern, options) {
      var snapdragon = options && options.snapdragon || new Snapdragon(options);
      compilers(snapdragon);
      parsers(snapdragon);
      var ast = snapdragon.parse(pattern, options);
      ast.input = pattern;
      var res = snapdragon.compile(ast, options);
      res.input = pattern;
      return res;
    };
    brackets.compilers = compilers;
    brackets.parsers = parsers;
    module2.exports = brackets;
  }
});

// node_modules/extglob/lib/compilers.js
var require_compilers4 = __commonJS({
  "node_modules/extglob/lib/compilers.js"(exports, module2) {
    "use strict";
    var brackets = require_expand_brackets();
    module2.exports = function(extglob) {
      function star() {
        if (typeof extglob.options.star === "function") {
          return extglob.options.star.apply(this, arguments);
        }
        if (typeof extglob.options.star === "string") {
          return extglob.options.star;
        }
        return ".*?";
      }
      extglob.use(brackets.compilers);
      extglob.compiler.set("escape", function(node) {
        return this.emit(node.val, node);
      }).set("dot", function(node) {
        return this.emit("\\" + node.val, node);
      }).set("qmark", function(node) {
        var val = "[^\\\\/.]";
        var prev = this.prev();
        if (node.parsed.slice(-1) === "(") {
          var ch = node.rest.charAt(0);
          if (ch !== "!" && ch !== "=" && ch !== ":") {
            return this.emit(val, node);
          }
          return this.emit(node.val, node);
        }
        if (prev.type === "text" && prev.val) {
          return this.emit(val, node);
        }
        if (node.val.length > 1) {
          val += "{" + node.val.length + "}";
        }
        return this.emit(val, node);
      }).set("plus", function(node) {
        var prev = node.parsed.slice(-1);
        if (prev === "]" || prev === ")") {
          return this.emit(node.val, node);
        }
        var ch = this.output.slice(-1);
        if (!this.output || /[?*+]/.test(ch) && node.parent.type !== "bracket") {
          return this.emit("\\+", node);
        }
        if (/\w/.test(ch) && !node.inside) {
          return this.emit("+\\+?", node);
        }
        return this.emit("+", node);
      }).set("star", function(node) {
        var prev = this.prev();
        var prefix = prev.type !== "text" && prev.type !== "escape" ? "(?!\\.)" : "";
        return this.emit(prefix + star.call(this, node), node);
      }).set("paren", function(node) {
        return this.mapVisit(node.nodes);
      }).set("paren.open", function(node) {
        var capture = this.options.capture ? "(" : "";
        switch (node.parent.prefix) {
          case "!":
          case "^":
            return this.emit(capture + "(?:(?!(?:", node);
          case "*":
          case "+":
          case "?":
          case "@":
            return this.emit(capture + "(?:", node);
          default: {
            var val = node.val;
            if (this.options.bash === true) {
              val = "\\" + val;
            } else if (!this.options.capture && val === "(" && node.parent.rest[0] !== "?") {
              val += "?:";
            }
            return this.emit(val, node);
          }
        }
      }).set("paren.close", function(node) {
        var capture = this.options.capture ? ")" : "";
        switch (node.prefix) {
          case "!":
          case "^":
            var prefix = /^(\)|$)/.test(node.rest) ? "$" : "";
            var str = star.call(this, node);
            if (node.parent.hasSlash && !this.options.star && this.options.slash !== false) {
              str = ".*?";
            }
            return this.emit(prefix + ("))" + str + ")") + capture, node);
          case "*":
          case "+":
          case "?":
            return this.emit(")" + node.prefix + capture, node);
          case "@":
            return this.emit(")" + capture, node);
          default: {
            var val = (this.options.bash === true ? "\\" : "") + ")";
            return this.emit(val, node);
          }
        }
      }).set("text", function(node) {
        var val = node.val.replace(/[\[\]]/g, "\\$&");
        return this.emit(val, node);
      });
    };
  }
});

// node_modules/extglob/node_modules/define-property/index.js
var require_define_property7 = __commonJS({
  "node_modules/extglob/node_modules/define-property/index.js"(exports, module2) {
    "use strict";
    var isDescriptor = require_is_descriptor();
    module2.exports = function defineProperty(obj, prop, val) {
      if (typeof obj !== "object" && typeof obj !== "function") {
        throw new TypeError("expected an object or function.");
      }
      if (typeof prop !== "string") {
        throw new TypeError("expected `prop` to be a string.");
      }
      if (isDescriptor(val) && ("set" in val || "get" in val)) {
        return Object.defineProperty(obj, prop, val);
      }
      return Object.defineProperty(obj, prop, {
        configurable: true,
        enumerable: false,
        writable: true,
        value: val
      });
    };
  }
});

// node_modules/extglob/lib/utils.js
var require_utils7 = __commonJS({
  "node_modules/extglob/lib/utils.js"(exports, module2) {
    "use strict";
    var regex = require_regex_not();
    var Cache = require_fragment_cache();
    var utils = module2.exports;
    var cache = utils.cache = new Cache();
    utils.arrayify = function(val) {
      if (!Array.isArray(val)) {
        return [val];
      }
      return val;
    };
    utils.memoize = function(type, pattern, options, fn) {
      var key = utils.createKey(type + pattern, options);
      if (cache.has(type, key)) {
        return cache.get(type, key);
      }
      var val = fn(pattern, options);
      if (options && options.cache === false) {
        return val;
      }
      cache.set(type, key, val);
      return val;
    };
    utils.createKey = function(pattern, options) {
      var key = pattern;
      if (typeof options === "undefined") {
        return key;
      }
      for (var prop in options) {
        key += ";" + prop + "=" + String(options[prop]);
      }
      return key;
    };
    utils.createRegex = function(str) {
      var opts = { contains: true, strictClose: false };
      return regex(str, opts);
    };
  }
});

// node_modules/extglob/lib/parsers.js
var require_parsers4 = __commonJS({
  "node_modules/extglob/lib/parsers.js"(exports, module2) {
    "use strict";
    var brackets = require_expand_brackets();
    var define2 = require_define_property7();
    var utils = require_utils7();
    var TEXT_REGEX = "([!@*?+]?\\(|\\)|[*?.+\\\\]|\\[:?(?=.*\\])|:?\\])+";
    var not = utils.createRegex(TEXT_REGEX);
    function parsers(extglob) {
      extglob.state = extglob.state || {};
      extglob.use(brackets.parsers);
      extglob.parser.sets.paren = extglob.parser.sets.paren || [];
      extglob.parser.capture("paren.open", function() {
        var parsed = this.parsed;
        var pos = this.position();
        var m = this.match(/^([!@*?+])?\(/);
        if (!m)
          return;
        var prev = this.prev();
        var prefix = m[1];
        var val = m[0];
        var open = pos({
          type: "paren.open",
          parsed,
          val
        });
        var node = pos({
          type: "paren",
          prefix,
          nodes: [open]
        });
        if (prefix === "!" && prev.type === "paren" && prev.prefix === "!") {
          prev.prefix = "@";
          node.prefix = "@";
        }
        define2(node, "rest", this.input);
        define2(node, "parsed", parsed);
        define2(node, "parent", prev);
        define2(open, "parent", node);
        this.push("paren", node);
        prev.nodes.push(node);
      }).capture("paren.close", function() {
        var parsed = this.parsed;
        var pos = this.position();
        var m = this.match(/^\)/);
        if (!m)
          return;
        var parent = this.pop("paren");
        var node = pos({
          type: "paren.close",
          rest: this.input,
          parsed,
          val: m[0]
        });
        if (!this.isType(parent, "paren")) {
          if (this.options.strict) {
            throw new Error('missing opening paren: "("');
          }
          node.escaped = true;
          return node;
        }
        node.prefix = parent.prefix;
        parent.nodes.push(node);
        define2(node, "parent", parent);
      }).capture("escape", function() {
        var pos = this.position();
        var m = this.match(/^\\(.)/);
        if (!m)
          return;
        return pos({
          type: "escape",
          val: m[0],
          ch: m[1]
        });
      }).capture("qmark", function() {
        var parsed = this.parsed;
        var pos = this.position();
        var m = this.match(/^\?+(?!\()/);
        if (!m)
          return;
        extglob.state.metachar = true;
        return pos({
          type: "qmark",
          rest: this.input,
          parsed,
          val: m[0]
        });
      }).capture("star", /^\*(?!\()/).capture("plus", /^\+(?!\()/).capture("dot", /^\./).capture("text", not);
    }
    module2.exports.TEXT_REGEX = TEXT_REGEX;
    module2.exports = parsers;
  }
});

// node_modules/extglob/lib/extglob.js
var require_extglob = __commonJS({
  "node_modules/extglob/lib/extglob.js"(exports, module2) {
    "use strict";
    var Snapdragon = require_snapdragon();
    var define2 = require_define_property7();
    var extend = require_extend_shallow4();
    var compilers = require_compilers4();
    var parsers = require_parsers4();
    function Extglob(options) {
      this.options = extend({ source: "extglob" }, options);
      this.snapdragon = this.options.snapdragon || new Snapdragon(this.options);
      this.snapdragon.patterns = this.snapdragon.patterns || {};
      this.compiler = this.snapdragon.compiler;
      this.parser = this.snapdragon.parser;
      compilers(this.snapdragon);
      parsers(this.snapdragon);
      define2(this.snapdragon, "parse", function(str, options2) {
        var parsed = Snapdragon.prototype.parse.apply(this, arguments);
        parsed.input = str;
        var last = this.parser.stack.pop();
        if (last && this.options.strict !== true) {
          var node = last.nodes[0];
          node.val = "\\" + node.val;
          var sibling = node.parent.nodes[1];
          if (sibling.type === "star") {
            sibling.loose = true;
          }
        }
        define2(parsed, "parser", this.parser);
        return parsed;
      });
      define2(this, "parse", function(ast, options2) {
        return this.snapdragon.parse.apply(this.snapdragon, arguments);
      });
      define2(this, "compile", function(ast, options2) {
        return this.snapdragon.compile.apply(this.snapdragon, arguments);
      });
    }
    module2.exports = Extglob;
  }
});

// node_modules/extglob/index.js
var require_extglob2 = __commonJS({
  "node_modules/extglob/index.js"(exports, module2) {
    "use strict";
    var extend = require_extend_shallow4();
    var unique = require_array_unique();
    var toRegex = require_to_regex();
    var compilers = require_compilers4();
    var parsers = require_parsers4();
    var Extglob = require_extglob();
    var utils = require_utils7();
    var MAX_LENGTH = 1024 * 64;
    function extglob(pattern, options) {
      return extglob.create(pattern, options).output;
    }
    extglob.match = function(list, pattern, options) {
      if (typeof pattern !== "string") {
        throw new TypeError("expected pattern to be a string");
      }
      list = utils.arrayify(list);
      var isMatch = extglob.matcher(pattern, options);
      var len = list.length;
      var idx = -1;
      var matches = [];
      while (++idx < len) {
        var ele = list[idx];
        if (isMatch(ele)) {
          matches.push(ele);
        }
      }
      if (typeof options === "undefined") {
        return unique(matches);
      }
      if (matches.length === 0) {
        if (options.failglob === true) {
          throw new Error('no matches found for "' + pattern + '"');
        }
        if (options.nonull === true || options.nullglob === true) {
          return [pattern.split("\\").join("")];
        }
      }
      return options.nodupes !== false ? unique(matches) : matches;
    };
    extglob.isMatch = function(str, pattern, options) {
      if (typeof pattern !== "string") {
        throw new TypeError("expected pattern to be a string");
      }
      if (typeof str !== "string") {
        throw new TypeError("expected a string");
      }
      if (pattern === str) {
        return true;
      }
      if (pattern === "" || pattern === " " || pattern === ".") {
        return pattern === str;
      }
      var isMatch = utils.memoize("isMatch", pattern, options, extglob.matcher);
      return isMatch(str);
    };
    extglob.contains = function(str, pattern, options) {
      if (typeof str !== "string") {
        throw new TypeError("expected a string");
      }
      if (pattern === "" || pattern === " " || pattern === ".") {
        return pattern === str;
      }
      var opts = extend({}, options, { contains: true });
      opts.strictClose = false;
      opts.strictOpen = false;
      return extglob.isMatch(str, pattern, opts);
    };
    extglob.matcher = function(pattern, options) {
      if (typeof pattern !== "string") {
        throw new TypeError("expected pattern to be a string");
      }
      function matcher() {
        var re = extglob.makeRe(pattern, options);
        return function(str) {
          return re.test(str);
        };
      }
      return utils.memoize("matcher", pattern, options, matcher);
    };
    extglob.create = function(pattern, options) {
      if (typeof pattern !== "string") {
        throw new TypeError("expected pattern to be a string");
      }
      function create() {
        var ext = new Extglob(options);
        var ast = ext.parse(pattern, options);
        return ext.compile(ast, options);
      }
      return utils.memoize("create", pattern, options, create);
    };
    extglob.capture = function(pattern, str, options) {
      var re = extglob.makeRe(pattern, extend({ capture: true }, options));
      function match() {
        return function(string) {
          var match2 = re.exec(string);
          if (!match2) {
            return null;
          }
          return match2.slice(1);
        };
      }
      var capture = utils.memoize("capture", pattern, options, match);
      return capture(str);
    };
    extglob.makeRe = function(pattern, options) {
      if (pattern instanceof RegExp) {
        return pattern;
      }
      if (typeof pattern !== "string") {
        throw new TypeError("expected pattern to be a string");
      }
      if (pattern.length > MAX_LENGTH) {
        throw new Error("expected pattern to be less than " + MAX_LENGTH + " characters");
      }
      function makeRe() {
        var opts = extend({ strictErrors: false }, options);
        if (opts.strictErrors === true)
          opts.strict = true;
        var res = extglob.create(pattern, opts);
        return toRegex(res.output, opts);
      }
      var regex = utils.memoize("makeRe", pattern, options, makeRe);
      if (regex.source.length > MAX_LENGTH) {
        throw new SyntaxError("potentially malicious regex detected");
      }
      return regex;
    };
    extglob.cache = utils.cache;
    extglob.clearCache = function() {
      extglob.cache.__data__ = {};
    };
    extglob.Extglob = Extglob;
    extglob.compilers = compilers;
    extglob.parsers = parsers;
    module2.exports = extglob;
  }
});

// node_modules/micromatch/lib/compilers.js
var require_compilers5 = __commonJS({
  "node_modules/micromatch/lib/compilers.js"(exports, module2) {
    "use strict";
    var nanomatch = require_nanomatch();
    var extglob = require_extglob2();
    module2.exports = function(snapdragon) {
      var compilers = snapdragon.compiler.compilers;
      var opts = snapdragon.options;
      snapdragon.use(nanomatch.compilers);
      var escape = compilers.escape;
      var qmark = compilers.qmark;
      var slash = compilers.slash;
      var star = compilers.star;
      var text = compilers.text;
      var plus = compilers.plus;
      var dot = compilers.dot;
      if (opts.extglob === false || opts.noext === true) {
        snapdragon.compiler.use(escapeExtglobs);
      } else {
        snapdragon.use(extglob.compilers);
      }
      snapdragon.use(function() {
        this.options.star = this.options.star || function() {
          return "[^\\\\/]*?";
        };
      });
      snapdragon.compiler.set("dot", dot).set("escape", escape).set("plus", plus).set("slash", slash).set("qmark", qmark).set("star", star).set("text", text);
    };
    function escapeExtglobs(compiler) {
      compiler.set("paren", function(node) {
        var val = "";
        visit(node, function(tok) {
          if (tok.val)
            val += (/^\W/.test(tok.val) ? "\\" : "") + tok.val;
        });
        return this.emit(val, node);
      });
      function visit(node, fn) {
        return node.nodes ? mapVisit(node.nodes, fn) : fn(node);
      }
      function mapVisit(nodes, fn) {
        var len = nodes.length;
        var idx = -1;
        while (++idx < len) {
          visit(nodes[idx], fn);
        }
      }
    }
  }
});

// node_modules/micromatch/lib/parsers.js
var require_parsers5 = __commonJS({
  "node_modules/micromatch/lib/parsers.js"(exports, module2) {
    "use strict";
    var extglob = require_extglob2();
    var nanomatch = require_nanomatch();
    var regexNot = require_regex_not();
    var toRegex = require_to_regex();
    var not;
    var TEXT = "([!@*?+]?\\(|\\)|\\[:?(?=.*?:?\\])|:?\\]|[*+?!^$.\\\\/])+";
    var createNotRegex = function(opts) {
      return not || (not = textRegex(TEXT));
    };
    module2.exports = function(snapdragon) {
      var parsers = snapdragon.parser.parsers;
      snapdragon.use(nanomatch.parsers);
      var escape = parsers.escape;
      var slash = parsers.slash;
      var qmark = parsers.qmark;
      var plus = parsers.plus;
      var star = parsers.star;
      var dot = parsers.dot;
      snapdragon.use(extglob.parsers);
      snapdragon.parser.use(function() {
        this.notRegex = /^\!+(?!\()/;
      }).capture("escape", escape).capture("slash", slash).capture("qmark", qmark).capture("star", star).capture("plus", plus).capture("dot", dot).capture("text", function() {
        if (this.isInside("bracket"))
          return;
        var pos = this.position();
        var m = this.match(createNotRegex(this.options));
        if (!m || !m[0])
          return;
        var val = m[0].replace(/([[\]^$])/g, "\\$1");
        return pos({
          type: "text",
          val
        });
      });
    };
    function textRegex(pattern) {
      var notStr = regexNot.create(pattern, { contains: true, strictClose: false });
      var prefix = "(?:[\\^]|\\\\|";
      return toRegex(prefix + notStr + ")", { strictClose: false });
    }
  }
});

// node_modules/micromatch/lib/cache.js
var require_cache2 = __commonJS({
  "node_modules/micromatch/lib/cache.js"(exports, module2) {
    module2.exports = new (require_fragment_cache())();
  }
});

// node_modules/micromatch/node_modules/define-property/index.js
var require_define_property8 = __commonJS({
  "node_modules/micromatch/node_modules/define-property/index.js"(exports, module2) {
    "use strict";
    var isobject = require_isobject();
    var isDescriptor = require_is_descriptor();
    var define2 = typeof Reflect !== "undefined" && Reflect.defineProperty ? Reflect.defineProperty : Object.defineProperty;
    module2.exports = function defineProperty(obj, key, val) {
      if (!isobject(obj) && typeof obj !== "function" && !Array.isArray(obj)) {
        throw new TypeError("expected an object, function, or array");
      }
      if (typeof key !== "string") {
        throw new TypeError('expected "key" to be a string');
      }
      if (isDescriptor(val)) {
        define2(obj, key, val);
        return obj;
      }
      define2(obj, key, {
        configurable: true,
        enumerable: false,
        writable: true,
        value: val
      });
      return obj;
    };
  }
});

// node_modules/micromatch/lib/utils.js
var require_utils8 = __commonJS({
  "node_modules/micromatch/lib/utils.js"(exports, module2) {
    "use strict";
    var utils = module2.exports;
    var path = require("path");
    var Snapdragon = require_snapdragon();
    utils.define = require_define_property8();
    utils.diff = require_arr_diff();
    utils.extend = require_extend_shallow6();
    utils.pick = require_object2();
    utils.typeOf = require_kind_of();
    utils.unique = require_array_unique();
    utils.isWindows = function() {
      return path.sep === "\\" || process.platform === "win32";
    };
    utils.instantiate = function(ast, options) {
      var snapdragon;
      if (utils.typeOf(ast) === "object" && ast.snapdragon) {
        snapdragon = ast.snapdragon;
      } else if (utils.typeOf(options) === "object" && options.snapdragon) {
        snapdragon = options.snapdragon;
      } else {
        snapdragon = new Snapdragon(options);
      }
      utils.define(snapdragon, "parse", function(str, options2) {
        var parsed = Snapdragon.prototype.parse.apply(this, arguments);
        parsed.input = str;
        var last = this.parser.stack.pop();
        if (last && this.options.strictErrors !== true) {
          var open = last.nodes[0];
          var inner = last.nodes[1];
          if (last.type === "bracket") {
            if (inner.val.charAt(0) === "[") {
              inner.val = "\\" + inner.val;
            }
          } else {
            open.val = "\\" + open.val;
            var sibling = open.parent.nodes[1];
            if (sibling.type === "star") {
              sibling.loose = true;
            }
          }
        }
        utils.define(parsed, "parser", this.parser);
        return parsed;
      });
      return snapdragon;
    };
    utils.createKey = function(pattern, options) {
      if (utils.typeOf(options) !== "object") {
        return pattern;
      }
      var val = pattern;
      var keys = Object.keys(options);
      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        val += ";" + key + "=" + String(options[key]);
      }
      return val;
    };
    utils.arrayify = function(val) {
      if (typeof val === "string")
        return [val];
      return val ? Array.isArray(val) ? val : [val] : [];
    };
    utils.isString = function(val) {
      return typeof val === "string";
    };
    utils.isObject = function(val) {
      return utils.typeOf(val) === "object";
    };
    utils.hasSpecialChars = function(str) {
      return /(?:(?:(^|\/)[!.])|[*?+()|\[\]{}]|[+@]\()/.test(str);
    };
    utils.escapeRegex = function(str) {
      return str.replace(/[-[\]{}()^$|*+?.\\\/\s]/g, "\\$&");
    };
    utils.toPosixPath = function(str) {
      return str.replace(/\\+/g, "/");
    };
    utils.unescape = function(str) {
      return utils.toPosixPath(str.replace(/\\(?=[*+?!.])/g, ""));
    };
    utils.stripPrefix = function(str) {
      if (str.charAt(0) !== ".") {
        return str;
      }
      var ch = str.charAt(1);
      if (utils.isSlash(ch)) {
        return str.slice(2);
      }
      return str;
    };
    utils.isSlash = function(str) {
      return str === "/" || str === "\\/" || str === "\\" || str === "\\\\";
    };
    utils.matchPath = function(pattern, options) {
      return options && options.contains ? utils.containsPattern(pattern, options) : utils.equalsPattern(pattern, options);
    };
    utils._equals = function(filepath, unixPath, pattern) {
      return pattern === filepath || pattern === unixPath;
    };
    utils._contains = function(filepath, unixPath, pattern) {
      return filepath.indexOf(pattern) !== -1 || unixPath.indexOf(pattern) !== -1;
    };
    utils.equalsPattern = function(pattern, options) {
      var unixify = utils.unixify(options);
      options = options || {};
      return function fn(filepath) {
        var equal = utils._equals(filepath, unixify(filepath), pattern);
        if (equal === true || options.nocase !== true) {
          return equal;
        }
        var lower = filepath.toLowerCase();
        return utils._equals(lower, unixify(lower), pattern);
      };
    };
    utils.containsPattern = function(pattern, options) {
      var unixify = utils.unixify(options);
      options = options || {};
      return function(filepath) {
        var contains = utils._contains(filepath, unixify(filepath), pattern);
        if (contains === true || options.nocase !== true) {
          return contains;
        }
        var lower = filepath.toLowerCase();
        return utils._contains(lower, unixify(lower), pattern);
      };
    };
    utils.matchBasename = function(re) {
      return function(filepath) {
        return re.test(path.basename(filepath));
      };
    };
    utils.value = function(str, unixify, options) {
      if (options && options.unixify === false) {
        return str;
      }
      return unixify(str);
    };
    utils.unixify = function(options) {
      options = options || {};
      return function(filepath) {
        if (utils.isWindows() || options.unixify === true) {
          filepath = utils.toPosixPath(filepath);
        }
        if (options.stripPrefix !== false) {
          filepath = utils.stripPrefix(filepath);
        }
        if (options.unescape === true) {
          filepath = utils.unescape(filepath);
        }
        return filepath;
      };
    };
  }
});

// node_modules/micromatch/index.js
var require_micromatch = __commonJS({
  "node_modules/micromatch/index.js"(exports, module2) {
    "use strict";
    var util = require("util");
    var braces = require_braces2();
    var toRegex = require_to_regex();
    var extend = require_extend_shallow6();
    var compilers = require_compilers5();
    var parsers = require_parsers5();
    var cache = require_cache2();
    var utils = require_utils8();
    var MAX_LENGTH = 1024 * 64;
    function micromatch(list, patterns, options) {
      patterns = utils.arrayify(patterns);
      list = utils.arrayify(list);
      var len = patterns.length;
      if (list.length === 0 || len === 0) {
        return [];
      }
      if (len === 1) {
        return micromatch.match(list, patterns[0], options);
      }
      var omit = [];
      var keep = [];
      var idx = -1;
      while (++idx < len) {
        var pattern = patterns[idx];
        if (typeof pattern === "string" && pattern.charCodeAt(0) === 33) {
          omit.push.apply(omit, micromatch.match(list, pattern.slice(1), options));
        } else {
          keep.push.apply(keep, micromatch.match(list, pattern, options));
        }
      }
      var matches = utils.diff(keep, omit);
      if (!options || options.nodupes !== false) {
        return utils.unique(matches);
      }
      return matches;
    }
    micromatch.match = function(list, pattern, options) {
      if (Array.isArray(pattern)) {
        throw new TypeError("expected pattern to be a string");
      }
      var unixify = utils.unixify(options);
      var isMatch = memoize("match", pattern, options, micromatch.matcher);
      var matches = [];
      list = utils.arrayify(list);
      var len = list.length;
      var idx = -1;
      while (++idx < len) {
        var ele = list[idx];
        if (ele === pattern || isMatch(ele)) {
          matches.push(utils.value(ele, unixify, options));
        }
      }
      if (typeof options === "undefined") {
        return utils.unique(matches);
      }
      if (matches.length === 0) {
        if (options.failglob === true) {
          throw new Error('no matches found for "' + pattern + '"');
        }
        if (options.nonull === true || options.nullglob === true) {
          return [options.unescape ? utils.unescape(pattern) : pattern];
        }
      }
      if (options.ignore) {
        matches = micromatch.not(matches, options.ignore, options);
      }
      return options.nodupes !== false ? utils.unique(matches) : matches;
    };
    micromatch.isMatch = function(str, pattern, options) {
      if (typeof str !== "string") {
        throw new TypeError('expected a string: "' + util.inspect(str) + '"');
      }
      if (isEmptyString(str) || isEmptyString(pattern)) {
        return false;
      }
      var equals = utils.equalsPattern(options);
      if (equals(str)) {
        return true;
      }
      var isMatch = memoize("isMatch", pattern, options, micromatch.matcher);
      return isMatch(str);
    };
    micromatch.some = function(list, patterns, options) {
      if (typeof list === "string") {
        list = [list];
      }
      for (var i = 0; i < list.length; i++) {
        if (micromatch(list[i], patterns, options).length === 1) {
          return true;
        }
      }
      return false;
    };
    micromatch.every = function(list, patterns, options) {
      if (typeof list === "string") {
        list = [list];
      }
      for (var i = 0; i < list.length; i++) {
        if (micromatch(list[i], patterns, options).length !== 1) {
          return false;
        }
      }
      return true;
    };
    micromatch.any = function(str, patterns, options) {
      if (typeof str !== "string") {
        throw new TypeError('expected a string: "' + util.inspect(str) + '"');
      }
      if (isEmptyString(str) || isEmptyString(patterns)) {
        return false;
      }
      if (typeof patterns === "string") {
        patterns = [patterns];
      }
      for (var i = 0; i < patterns.length; i++) {
        if (micromatch.isMatch(str, patterns[i], options)) {
          return true;
        }
      }
      return false;
    };
    micromatch.all = function(str, patterns, options) {
      if (typeof str !== "string") {
        throw new TypeError('expected a string: "' + util.inspect(str) + '"');
      }
      if (typeof patterns === "string") {
        patterns = [patterns];
      }
      for (var i = 0; i < patterns.length; i++) {
        if (!micromatch.isMatch(str, patterns[i], options)) {
          return false;
        }
      }
      return true;
    };
    micromatch.not = function(list, patterns, options) {
      var opts = extend({}, options);
      var ignore = opts.ignore;
      delete opts.ignore;
      var unixify = utils.unixify(opts);
      list = utils.arrayify(list).map(unixify);
      var matches = utils.diff(list, micromatch(list, patterns, opts));
      if (ignore) {
        matches = utils.diff(matches, micromatch(list, ignore));
      }
      return opts.nodupes !== false ? utils.unique(matches) : matches;
    };
    micromatch.contains = function(str, patterns, options) {
      if (typeof str !== "string") {
        throw new TypeError('expected a string: "' + util.inspect(str) + '"');
      }
      if (typeof patterns === "string") {
        if (isEmptyString(str) || isEmptyString(patterns)) {
          return false;
        }
        var equals = utils.equalsPattern(patterns, options);
        if (equals(str)) {
          return true;
        }
        var contains = utils.containsPattern(patterns, options);
        if (contains(str)) {
          return true;
        }
      }
      var opts = extend({}, options, { contains: true });
      return micromatch.any(str, patterns, opts);
    };
    micromatch.matchBase = function(pattern, options) {
      if (pattern && pattern.indexOf("/") !== -1 || !options)
        return false;
      return options.basename === true || options.matchBase === true;
    };
    micromatch.matchKeys = function(obj, patterns, options) {
      if (!utils.isObject(obj)) {
        throw new TypeError("expected the first argument to be an object");
      }
      var keys = micromatch(Object.keys(obj), patterns, options);
      return utils.pick(obj, keys);
    };
    micromatch.matcher = function matcher(pattern, options) {
      if (Array.isArray(pattern)) {
        return compose(pattern, options, matcher);
      }
      if (pattern instanceof RegExp) {
        return test(pattern);
      }
      if (!utils.isString(pattern)) {
        throw new TypeError("expected pattern to be an array, string or regex");
      }
      if (!utils.hasSpecialChars(pattern)) {
        if (options && options.nocase === true) {
          pattern = pattern.toLowerCase();
        }
        return utils.matchPath(pattern, options);
      }
      var re = micromatch.makeRe(pattern, options);
      if (micromatch.matchBase(pattern, options)) {
        return utils.matchBasename(re, options);
      }
      function test(regex) {
        var equals = utils.equalsPattern(options);
        var unixify = utils.unixify(options);
        return function(str) {
          if (equals(str)) {
            return true;
          }
          if (regex.test(unixify(str))) {
            return true;
          }
          return false;
        };
      }
      var fn = test(re);
      Object.defineProperty(fn, "result", {
        configurable: true,
        enumerable: false,
        value: re.result
      });
      return fn;
    };
    micromatch.capture = function(pattern, str, options) {
      var re = micromatch.makeRe(pattern, extend({ capture: true }, options));
      var unixify = utils.unixify(options);
      function match() {
        return function(string) {
          var match2 = re.exec(unixify(string));
          if (!match2) {
            return null;
          }
          return match2.slice(1);
        };
      }
      var capture = memoize("capture", pattern, options, match);
      return capture(str);
    };
    micromatch.makeRe = function(pattern, options) {
      if (typeof pattern !== "string") {
        throw new TypeError("expected pattern to be a string");
      }
      if (pattern.length > MAX_LENGTH) {
        throw new Error("expected pattern to be less than " + MAX_LENGTH + " characters");
      }
      function makeRe() {
        var result = micromatch.create(pattern, options);
        var ast_array = [];
        var output = result.map(function(obj) {
          obj.ast.state = obj.state;
          ast_array.push(obj.ast);
          return obj.output;
        });
        var regex = toRegex(output.join("|"), options);
        Object.defineProperty(regex, "result", {
          configurable: true,
          enumerable: false,
          value: ast_array
        });
        return regex;
      }
      return memoize("makeRe", pattern, options, makeRe);
    };
    micromatch.braces = function(pattern, options) {
      if (typeof pattern !== "string" && !Array.isArray(pattern)) {
        throw new TypeError("expected pattern to be an array or string");
      }
      function expand() {
        if (options && options.nobrace === true || !/\{.*\}/.test(pattern)) {
          return utils.arrayify(pattern);
        }
        return braces(pattern, options);
      }
      return memoize("braces", pattern, options, expand);
    };
    micromatch.braceExpand = function(pattern, options) {
      var opts = extend({}, options, { expand: true });
      return micromatch.braces(pattern, opts);
    };
    micromatch.create = function(pattern, options) {
      return memoize("create", pattern, options, function() {
        function create(str, opts) {
          return micromatch.compile(micromatch.parse(str, opts), opts);
        }
        pattern = micromatch.braces(pattern, options);
        var len = pattern.length;
        var idx = -1;
        var res = [];
        while (++idx < len) {
          res.push(create(pattern[idx], options));
        }
        return res;
      });
    };
    micromatch.parse = function(pattern, options) {
      if (typeof pattern !== "string") {
        throw new TypeError("expected a string");
      }
      function parse() {
        var snapdragon = utils.instantiate(null, options);
        parsers(snapdragon, options);
        var ast = snapdragon.parse(pattern, options);
        utils.define(ast, "snapdragon", snapdragon);
        ast.input = pattern;
        return ast;
      }
      return memoize("parse", pattern, options, parse);
    };
    micromatch.compile = function(ast, options) {
      if (typeof ast === "string") {
        ast = micromatch.parse(ast, options);
      }
      return memoize("compile", ast.input, options, function() {
        var snapdragon = utils.instantiate(ast, options);
        compilers(snapdragon, options);
        return snapdragon.compile(ast, options);
      });
    };
    micromatch.clearCache = function() {
      micromatch.cache.caches = {};
    };
    function isEmptyString(val) {
      return String(val) === "" || String(val) === "./";
    }
    function compose(patterns, options, matcher) {
      var matchers;
      return memoize("compose", String(patterns), options, function() {
        return function(file) {
          if (!matchers) {
            matchers = [];
            for (var i = 0; i < patterns.length; i++) {
              matchers.push(matcher(patterns[i], options));
            }
          }
          var len = matchers.length;
          while (len--) {
            if (matchers[len](file) === true) {
              return true;
            }
          }
          return false;
        };
      });
    }
    function memoize(type, pattern, options, fn) {
      var key = utils.createKey(type + "=" + pattern, options);
      if (options && options.cache === false) {
        return fn(pattern, options);
      }
      if (cache.has(type, key)) {
        return cache.get(type, key);
      }
      var val = fn(pattern, options);
      cache.set(type, key, val);
      return val;
    }
    micromatch.compilers = compilers;
    micromatch.parsers = parsers;
    micromatch.caches = cache.caches;
    module2.exports = micromatch;
  }
});

// node_modules/@budibase/handlebars-helpers/lib/match.js
var require_match = __commonJS({
  "node_modules/@budibase/handlebars-helpers/lib/match.js"(exports, module2) {
    "use strict";
    var util = require_handlebars_utils();
    var helpers = module2.exports;
    var micromatch = require_micromatch();
    helpers.match = function(files, patterns, locals, options) {
      var opts = util.options(this, locals, options);
      if (typeof patterns === "string") {
        patterns = patterns.split(/, */);
      }
      return micromatch(files, patterns, opts);
    };
    helpers.isMatch = function(files, patterns, locals, options) {
      var opts = util.options(this, locals, options);
      return micromatch.isMatch(files, patterns, opts);
    };
    helpers.mm = function() {
      console.log("the {{mm}} helper is depcrecated and will be removed");
      console.log("in handlebars-helpers v1.0.0, please use the {{match}}");
      console.log("helper instead.");
      return helpers.match.apply(this, arguments);
    };
  }
});

// node_modules/@budibase/handlebars-helpers/lib/math.js
var require_math = __commonJS({
  "node_modules/@budibase/handlebars-helpers/lib/math.js"(exports, module2) {
    "use strict";
    var utils = require_utils2();
    var helpers = module2.exports;
    helpers.abs = function(num) {
      if (isNaN(num)) {
        throw new TypeError("expected a number");
      }
      return Math.abs(num);
    };
    helpers.add = function(a, b) {
      if (!isNaN(a) && !isNaN(b)) {
        return Number(a) + Number(b);
      }
      if (typeof a === "string" && typeof b === "string") {
        return a + b;
      }
      return "";
    };
    helpers.avg = function() {
      const args = [].concat.apply([], arguments);
      args.pop();
      return helpers.sum(args) / args.length;
    };
    helpers.ceil = function(num) {
      if (isNaN(num)) {
        throw new TypeError("expected a number");
      }
      return Math.ceil(num);
    };
    helpers.divide = function(a, b) {
      if (isNaN(a)) {
        throw new TypeError("expected the first argument to be a number");
      }
      if (isNaN(b)) {
        throw new TypeError("expected the second argument to be a number");
      }
      return Number(a) / Number(b);
    };
    helpers.floor = function(num) {
      if (isNaN(num)) {
        throw new TypeError("expected a number");
      }
      return Math.floor(num);
    };
    helpers.minus = function(a, b) {
      if (isNaN(a)) {
        throw new TypeError("expected the first argument to be a number");
      }
      if (isNaN(b)) {
        throw new TypeError("expected the second argument to be a number");
      }
      return Number(a) - Number(b);
    };
    helpers.modulo = function(a, b) {
      if (isNaN(a)) {
        throw new TypeError("expected the first argument to be a number");
      }
      if (isNaN(b)) {
        throw new TypeError("expected the second argument to be a number");
      }
      return Number(a) % Number(b);
    };
    helpers.multiply = function(a, b) {
      if (isNaN(a)) {
        throw new TypeError("expected the first argument to be a number");
      }
      if (isNaN(b)) {
        throw new TypeError("expected the second argument to be a number");
      }
      return Number(a) * Number(b);
    };
    helpers.plus = function(a, b) {
      if (isNaN(a)) {
        throw new TypeError("expected the first argument to be a number");
      }
      if (isNaN(b)) {
        throw new TypeError("expected the second argument to be a number");
      }
      return Number(a) + Number(b);
    };
    helpers.random = function(min, max) {
      if (isNaN(min)) {
        throw new TypeError("expected minimum to be a number");
      }
      if (isNaN(max)) {
        throw new TypeError("expected maximum to be a number");
      }
      return utils.random(min, max);
    };
    helpers.remainder = function(a, b) {
      return a % b;
    };
    helpers.round = function(num) {
      if (isNaN(num)) {
        throw new TypeError("expected a number");
      }
      return Math.round(num);
    };
    helpers.subtract = function(a, b) {
      if (isNaN(a)) {
        throw new TypeError("expected the first argument to be a number");
      }
      if (isNaN(b)) {
        throw new TypeError("expected the second argument to be a number");
      }
      return Number(a) - Number(b);
    };
    helpers.sum = function() {
      var args = [].concat.apply([], arguments);
      var len = args.length;
      var sum = 0;
      while (len--) {
        if (!isNaN(args[len])) {
          sum += Number(args[len]);
        }
      }
      return sum;
    };
    helpers.times = function() {
      return helpers.multiply.apply(this, arguments);
    };
  }
});

// node_modules/@budibase/handlebars-helpers/lib/misc.js
var require_misc = __commonJS({
  "node_modules/@budibase/handlebars-helpers/lib/misc.js"(exports, module2) {
    "use strict";
    var util = require_handlebars_utils();
    var helpers = module2.exports;
    var getValue = require_get_value2();
    var createFrame = require_createFrame();
    helpers.frame = function(context, options) {
      if (typeof context === "object" && context.hash) {
        options = context;
        context = options.data;
      }
      var frame = createFrame(context);
      if (typeof options !== "object") {
        options = {};
      }
      frame.extend(options.hash);
      return options.fn(this, { data: frame });
    };
    helpers.option = function(prop, locals, options) {
      return getValue(util.options(this, locals, options), prop);
    };
    helpers.noop = function(options) {
      return options.fn(this);
    };
    helpers.typeOf = require_kind_of();
    helpers.withHash = function(options) {
      if (options.hash && Object.keys(options.hash).length) {
        return options.fn(options.hash);
      } else {
        return options.inverse(this);
      }
    };
  }
});

// node_modules/@budibase/handlebars-helpers/lib/number.js
var require_number = __commonJS({
  "node_modules/@budibase/handlebars-helpers/lib/number.js"(exports, module2) {
    "use strict";
    var util = require_handlebars_utils();
    var helpers = module2.exports;
    helpers.bytes = function(number, precision, options) {
      if (number == null)
        return "0 B";
      if (isNaN(number)) {
        number = number.length;
        if (!number)
          return "0 B";
      }
      if (isNaN(precision)) {
        precision = 2;
      }
      var abbr = ["B", "kB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"];
      precision = Math.pow(10, precision);
      number = Number(number);
      var len = abbr.length - 1;
      while (len-- >= 0) {
        var size = Math.pow(10, len * 3);
        if (size <= number + 1) {
          number = Math.round(number * precision / size) / precision;
          number += " " + abbr[len];
          break;
        }
      }
      return number;
    };
    helpers.addCommas = function(num) {
      return num.toString().replace(/(\d)(?=(\d\d\d)+(?!\d))/g, "$1,");
    };
    helpers.phoneNumber = function(num) {
      num = num.toString();
      return "(" + num.substr(0, 3) + ") " + num.substr(3, 3) + "-" + num.substr(6, 4);
    };
    helpers.toAbbr = function(number, precision) {
      if (isNaN(number)) {
        number = 0;
      }
      if (util.isUndefined(precision)) {
        precision = 2;
      }
      number = Number(number);
      precision = Math.pow(10, precision);
      var abbr = ["k", "m", "b", "t", "q"];
      var len = abbr.length - 1;
      while (len >= 0) {
        var size = Math.pow(10, (len + 1) * 3);
        if (size <= number + 1) {
          number = Math.round(number * precision / size) / precision;
          number += abbr[len];
          break;
        }
        len--;
      }
      return number;
    };
    helpers.toExponential = function(number, digits) {
      if (isNaN(number)) {
        number = 0;
      }
      if (util.isUndefined(digits)) {
        digits = 0;
      }
      return Number(number).toExponential(digits);
    };
    helpers.toFixed = function(number, digits) {
      if (isNaN(number)) {
        number = 0;
      }
      if (isNaN(digits)) {
        digits = 0;
      }
      return Number(number).toFixed(digits);
    };
    helpers.toFloat = function(number) {
      return parseFloat(number);
    };
    helpers.toInt = function(number) {
      return parseInt(number, 10);
    };
    helpers.toPrecision = function(number, precision) {
      if (isNaN(number)) {
        number = 0;
      }
      if (isNaN(precision)) {
        precision = 1;
      }
      return Number(number).toPrecision(precision);
    };
  }
});

// node_modules/relative/node_modules/isobject/index.js
var require_isobject3 = __commonJS({
  "node_modules/relative/node_modules/isobject/index.js"(exports, module2) {
    "use strict";
    var isArray = require_isarray();
    module2.exports = function isObject(val) {
      return val != null && typeof val === "object" && isArray(val) === false;
    };
  }
});

// node_modules/relative/index.js
var require_relative = __commonJS({
  "node_modules/relative/index.js"(exports, module2) {
    "use strict";
    var isObject = require_isobject3();
    var path = require("path");
    var fs = require("fs");
    module2.exports = relative;
    function relative(a, b, stat) {
      if (typeof a !== "string") {
        throw new TypeError("relative expects a string.");
      }
      if (a == "" && !b)
        return a;
      var len = arguments.length;
      if (len === 1) {
        b = a;
        a = process.cwd();
        stat = null;
      }
      if (len === 2 && typeof b === "boolean") {
        b = a;
        a = process.cwd();
        stat = true;
      }
      if (len === 2 && typeof b === "object") {
        stat = b;
        b = a;
        a = process.cwd();
      }
      var origB = b;
      var slashA = endsWith(a, "/");
      var slashB = endsWith(b, "/");
      a = unixify(a);
      b = unixify(b);
      if (slashA) {
        a = a + "/";
      }
      if (isFile(a, stat)) {
        a = path.dirname(a);
      }
      var res = path.relative(a, b);
      if (res === "") {
        return ".";
      }
      var noslash = trimEnd(origB, "/");
      if (slashB && (res === noslash || endsWith(res, noslash))) {
        res = res + "/";
      }
      return res;
    }
    relative.toBase = function toBase(base, fp) {
      base = unixify(base);
      fp = unixify(fp);
      var res = fp.slice(base.length);
      if (res.charAt(0) === "/") {
        res = res.slice(1);
      }
      return res;
    };
    function unixify(str) {
      return str.replace(/[\\\/]+/g, "/");
    }
    function trimEnd(fp, ch) {
      return fp.slice(0, fp.length - ch.length);
    }
    function endsWith(fp, ch) {
      return fp.slice(-ch.length)[0] === ch;
    }
    function tryStats(fp) {
      try {
        return fs.statSync(fp);
      } catch (err) {
      }
      return null;
    }
    function isDir(fp, stat) {
      if (endsWith(fp, "/")) {
        return true;
      }
      if (stat === null) {
        stat = tryStats(fp);
      }
      if (isObject(stat) && typeof stat.isDirectory === "function") {
        return stat.isDirectory();
      }
      var segs = fp.split("/");
      var last = segs[segs.length - 1];
      if (last && last.indexOf(".") !== -1) {
        return false;
      }
      return true;
    }
    function isFile(fp, stat) {
      if (stat === true) {
        stat = tryStats(fp);
      }
      return !isDir(fp, stat);
    }
  }
});

// node_modules/@budibase/handlebars-helpers/lib/path.js
var require_path = __commonJS({
  "node_modules/@budibase/handlebars-helpers/lib/path.js"(exports, module2) {
    "use strict";
    var util = require_handlebars_utils();
    var path = require("path");
    var relative = require_relative();
    var helpers = module2.exports;
    helpers.absolute = function(filepath, options) {
      options = options || { data: {} };
      var context = util.options(this, options);
      var ctx = Object.assign({}, options.data.root, context);
      var cwd = ctx.cwd || process.cwd();
      return path.resolve(cwd, filepath);
    };
    helpers.dirname = function(filepath, options) {
      if (typeof filepath !== "string") {
        throw new TypeError(util.expectedType("filepath", "string", filepath));
      }
      return path.dirname(filepath);
    };
    helpers.relative = function(a, b) {
      if (typeof a !== "string") {
        throw new TypeError(util.expectedType("first path", "string", a));
      }
      if (typeof b !== "string") {
        throw new TypeError(util.expectedType("second path", "string", b));
      }
      return relative(a, b);
    };
    helpers.basename = function(filepath) {
      if (typeof filepath !== "string") {
        throw new TypeError(util.expectedType("filepath", "string", filepath));
      }
      return path.basename(filepath);
    };
    helpers.stem = function(filepath) {
      if (typeof filepath !== "string") {
        throw new TypeError(util.expectedType("filepath", "string", filepath));
      }
      return path.basename(filepath, path.extname(filepath));
    };
    helpers.extname = function(filepath) {
      if (typeof filepath !== "string") {
        throw new TypeError(util.expectedType("filepath", "string", filepath));
      }
      return path.extname(filepath);
    };
    helpers.resolve = function(filepath) {
      var args = [].slice.call(arguments);
      var opts = util.options(this, args.pop());
      var cwd = path.resolve(opts.cwd || process.cwd());
      args.unshift(cwd);
      return path.resolve.apply(path, args);
    };
    helpers.segments = function(filepath, a, b) {
      if (typeof filepath !== "string") {
        throw new TypeError(util.expectedType("filepath", "string", filepath));
      }
      var segments = filepath.split(/[\\\/]+/);
      return segments.slice(a, b).join("/");
    };
  }
});

// node_modules/@budibase/handlebars-helpers/lib/regex.js
var require_regex = __commonJS({
  "node_modules/@budibase/handlebars-helpers/lib/regex.js"(exports, module2) {
    "use strict";
    var util = require_handlebars_utils();
    var helpers = module2.exports;
    var kindOf = require_kind_of();
    helpers.toRegex = function(str, locals, options) {
      var opts = util.options({}, locals, options);
      return new RegExp(str, opts.flags);
    };
    helpers.test = function(str, regex) {
      if (typeof str !== "string") {
        return false;
      }
      if (kindOf(regex) !== "regexp") {
        throw new TypeError("expected a regular expression");
      }
      return regex.test(str);
    };
  }
});

// node_modules/@budibase/handlebars-helpers/lib/string.js
var require_string = __commonJS({
  "node_modules/@budibase/handlebars-helpers/lib/string.js"(exports, module2) {
    "use strict";
    var util = require_handlebars_utils();
    var utils = require_utils2();
    var helpers = module2.exports;
    helpers.append = function(str, suffix) {
      if (typeof str === "string" && typeof suffix === "string") {
        return str + suffix;
      }
      return str;
    };
    helpers.camelcase = function(str) {
      if (typeof str !== "string")
        return "";
      return utils.changecase(str, function(ch) {
        return ch.toUpperCase();
      });
    };
    helpers.capitalize = function(str) {
      if (typeof str !== "string")
        return "";
      return str.charAt(0).toUpperCase() + str.slice(1);
    };
    helpers.capitalizeAll = function(str) {
      if (typeof str !== "string")
        return "";
      if (util.isString(str)) {
        return str.replace(/\w\S*/g, function(word) {
          return helpers.capitalize(word);
        });
      }
    };
    helpers.center = function(str, spaces) {
      if (typeof str !== "string")
        return "";
      var space = "";
      var i = 0;
      while (i < spaces) {
        space += "&nbsp;";
        i++;
      }
      return space + str + space;
    };
    helpers.chop = function(str) {
      if (typeof str !== "string")
        return "";
      return utils.chop(str);
    };
    helpers.dashcase = function(str) {
      if (typeof str !== "string")
        return "";
      return utils.changecase(str, function(ch) {
        return "-" + ch;
      });
    };
    helpers.dotcase = function(str) {
      if (typeof str !== "string")
        return "";
      return utils.changecase(str, function(ch) {
        return "." + ch;
      });
    };
    helpers.downcase = function() {
      return helpers.lowercase.apply(this, arguments);
    };
    helpers.ellipsis = function(str, limit) {
      if (util.isString(str)) {
        if (str.length <= limit) {
          return str;
        }
        return helpers.truncate(str, limit) + "\u2026";
      }
    };
    helpers.hyphenate = function(str) {
      if (typeof str !== "string")
        return "";
      return str.split(" ").join("-");
    };
    helpers.isString = function(value2) {
      return typeof value2 === "string";
    };
    helpers.lowercase = function(str) {
      if (util.isObject(str) && str.fn) {
        return str.fn(this).toLowerCase();
      }
      if (typeof str !== "string")
        return "";
      return str.toLowerCase();
    };
    helpers.occurrences = function(str, substring) {
      if (typeof str !== "string")
        return "";
      var len = substring.length;
      var pos = 0;
      var n = 0;
      while ((pos = str.indexOf(substring, pos)) > -1) {
        n++;
        pos += len;
      }
      return n;
    };
    helpers.pascalcase = function(str) {
      if (typeof str !== "string")
        return "";
      str = utils.changecase(str, function(ch) {
        return ch.toUpperCase();
      });
      return str.charAt(0).toUpperCase() + str.slice(1);
    };
    helpers.pathcase = function(str) {
      if (typeof str !== "string")
        return "";
      return utils.changecase(str, function(ch) {
        return "/" + ch;
      });
    };
    helpers.plusify = function(str, ch) {
      if (typeof str !== "string")
        return "";
      if (!util.isString(ch))
        ch = " ";
      return str.split(ch).join("+");
    };
    helpers.prepend = function(str, prefix) {
      return typeof str === "string" && typeof prefix === "string" ? prefix + str : str;
    };
    helpers.raw = function(options) {
      var str = options.fn();
      var opts = util.options(this, options);
      if (opts.escape !== false) {
        var idx = 0;
        while ((idx = str.indexOf("{{", idx)) !== -1) {
          if (str[idx - 1] !== "\\") {
            str = str.slice(0, idx) + "\\" + str.slice(idx);
          }
          idx += 3;
        }
      }
      return str;
    };
    helpers.remove = function(str, ch) {
      if (typeof str !== "string")
        return "";
      if (!util.isString(ch))
        return str;
      return str.split(ch).join("");
    };
    helpers.removeFirst = function(str, ch) {
      if (typeof str !== "string")
        return "";
      if (!util.isString(ch))
        return str;
      return str.replace(ch, "");
    };
    helpers.replace = function(str, a, b) {
      if (typeof str !== "string")
        return "";
      if (!util.isString(a))
        return str;
      if (!util.isString(b))
        b = "";
      return str.split(a).join(b);
    };
    helpers.replaceFirst = function(str, a, b) {
      if (typeof str !== "string")
        return "";
      if (!util.isString(a))
        return str;
      if (!util.isString(b))
        b = "";
      return str.replace(a, b);
    };
    helpers.reverse = function(str) {
      if (typeof str !== "string")
        return "";
      return str.split("").reverse().join("");
    };
    helpers.sentence = function(str) {
      if (typeof str !== "string")
        return "";
      return str.replace(/((?:\S[^\.\?\!]*)[\.\?\!]*)/g, function(txt) {
        return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();
      });
    };
    helpers.snakecase = function(str) {
      if (typeof str !== "string")
        return "";
      return utils.changecase(str, function(ch) {
        return "_" + ch;
      });
    };
    helpers.split = function(str, ch) {
      if (typeof str !== "string")
        return "";
      if (!util.isString(ch))
        ch = ",";
      return str.split(ch);
    };
    helpers.startsWith = function(prefix, str, options) {
      var args = [].slice.call(arguments);
      options = args.pop();
      if (util.isString(str) && str.indexOf(prefix) === 0) {
        return options.fn(this);
      }
      if (typeof options.inverse === "function") {
        return options.inverse(this);
      }
      return "";
    };
    helpers.titleize = function(str) {
      if (typeof str !== "string")
        return "";
      var title = str.replace(/[- _]+/g, " ");
      var words = title.split(" ");
      var len = words.length;
      var res = [];
      var i = 0;
      while (len--) {
        var word = words[i++];
        res.push(exports.capitalize(word));
      }
      return res.join(" ");
    };
    helpers.trim = function(str) {
      return typeof str === "string" ? str.trim() : "";
    };
    helpers.trimLeft = function(str) {
      if (util.isString(str)) {
        return str.replace(/^\s+/, "");
      }
    };
    helpers.trimRight = function(str) {
      if (util.isString(str)) {
        return str.replace(/\s+$/, "");
      }
    };
    helpers.truncate = function(str, limit, suffix) {
      if (util.isString(str)) {
        if (typeof suffix !== "string") {
          suffix = "";
        }
        if (str.length > limit) {
          return str.slice(0, limit - suffix.length) + suffix;
        }
        return str;
      }
    };
    helpers.truncateWords = function(str, count, suffix) {
      if (util.isString(str) && !isNaN(count)) {
        if (typeof suffix !== "string") {
          suffix = "\u2026";
        }
        var num = Number(count);
        var arr = str.split(/[ \t]/);
        if (num > arr.length) {
          arr = arr.slice(0, num);
        }
        var val = arr.join(" ").trim();
        return val + suffix;
      }
    };
    helpers.upcase = function() {
      return helpers.uppercase.apply(this, arguments);
    };
    helpers.uppercase = function(str) {
      if (util.isObject(str) && str.fn) {
        return str.fn(this).toUpperCase();
      }
      if (typeof str !== "string")
        return "";
      return str.toUpperCase();
    };
  }
});

// node_modules/@budibase/handlebars-helpers/lib/url.js
var require_url = __commonJS({
  "node_modules/@budibase/handlebars-helpers/lib/url.js"(exports, module2) {
    "use strict";
    var url = require("url");
    var util = require_handlebars_utils();
    var querystring = require("querystring");
    var helpers = module2.exports;
    helpers.encodeURI = function(str) {
      if (util.isString(str)) {
        return encodeURIComponent(str);
      }
    };
    helpers.escape = function(str) {
      if (util.isString(str)) {
        return querystring.escape(str);
      }
    };
    helpers.decodeURI = function(str) {
      if (util.isString(str)) {
        return decodeURIComponent(str);
      }
    };
    helpers.url_encode = function() {
      return helpers.encodeURI.apply(this, arguments);
    };
    helpers.url_decode = function(val) {
      return helpers.decodeURI.apply(this, arguments);
    };
    helpers.urlResolve = function(base, href) {
      return url.resolve(base, href);
    };
    helpers.urlParse = function(str) {
      return url.parse(str);
    };
    helpers.stripQuerystring = function(str) {
      if (util.isString(str)) {
        return str.split("?")[0];
      }
    };
    helpers.stripProtocol = function(str) {
      if (util.isString(str)) {
        var parsed = url.parse(str);
        parsed.protocol = "";
        return parsed.format();
      }
    };
  }
});

// node_modules/@budibase/handlebars-helpers/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/@budibase/handlebars-helpers/lib/index.js"(exports, module2) {
    "use strict";
    module2.exports = {
      array: require_array(),
      code: require_code(),
      collection: require_collection(),
      comparison: require_comparison(),
      html: require_html2(),
      i18n: require_i18n(),
      inflection: require_inflection(),
      match: require_match(),
      math: require_math(),
      misc: require_misc(),
      number: require_number(),
      object: require_object(),
      path: require_path(),
      regex: require_regex(),
      string: require_string(),
      url: require_url()
    };
  }
});

// node_modules/@budibase/handlebars-helpers/index.js
var require_handlebars_helpers = __commonJS({
  "node_modules/@budibase/handlebars-helpers/index.js"(exports, module2) {
    "use strict";
    var forIn = require_for_in();
    var define2 = require_define_property();
    var lib = require_lib3();
    module2.exports = function helpers(groups, options) {
      if (typeof groups === "string") {
        groups = [groups];
      } else if (!Array.isArray(groups)) {
        options = groups;
        groups = null;
      }
      options = options || {};
      var hbs = options.handlebars || options.hbs || require_lib();
      define2(module2.exports, "handlebars", hbs);
      if (groups) {
        groups.forEach(function(key) {
          hbs.registerHelper(lib[key]);
        });
      } else {
        forIn(lib, function(group, key) {
          hbs.registerHelper(group);
        });
      }
      return hbs.helpers;
    };
    forIn(lib, function(group, key) {
      define2(module2.exports, key, function(options) {
        options = options || {};
        var hbs = options.handlebars || options.hbs || require_lib();
        define2(module2.exports, "handlebars", hbs);
        hbs.registerHelper(group);
        return hbs.helpers;
      });
    });
    module2.exports.utils = require_utils2();
  }
});

// main.ts
__export(exports, {
  default: () => JsonImport
});
var import_obsidian = __toModule(require("obsidian"));
var Papa = require_papaparse_min();
var handlebars = require_lib();
var hb_helpers = require_handlebars_helpers()({ handlebars });
var hb_utils = require_handlebars_utils();
var ExistingNotes;
(function(ExistingNotes2) {
  ExistingNotes2[ExistingNotes2["KEEP_EXISTING"] = 0] = "KEEP_EXISTING";
  ExistingNotes2[ExistingNotes2["REPLACE_EXISTING"] = 1] = "REPLACE_EXISTING";
  ExistingNotes2[ExistingNotes2["APPEND_TO_EXISTING"] = 2] = "APPEND_TO_EXISTING";
})(ExistingNotes || (ExistingNotes = {}));
var DEFAULT_SETTINGS = {
  jsonName: "name",
  jsonNamePath: false,
  folderName: "Rewards",
  topField: "",
  notePrefix: "",
  noteSuffix: "",
  handleExistingNote: 0,
  forceArray: true
};
function convertCsv(source) {
  var _a;
  let csv = Papa.parse(source, { header: true, skipEmptyLines: true });
  if ((_a = csv.errors) == null ? void 0 : _a.length) {
    console.warn(JSON.stringify(csv.errors, null, 2));
  }
  console.log(JSON.stringify(csv.meta, null, 2));
  return csv.data;
}
function objfield(srcobj, field) {
  if (!field)
    return srcobj;
  for (let part of field.split(".")) {
    srcobj = srcobj[part];
    if (srcobj === void 0)
      break;
  }
  return srcobj;
}
var JsonImport = class extends import_obsidian.Plugin {
  startApp() {
    const modal = new FileSelectionModal(this.app);
    modal.setHandler(this, this.generateNotes);
    modal.setDefaults(this.settings);
    modal.open();
  }
  onload() {
    return __async(this, null, function* () {
      yield this.loadSettings();
      const ribbonIconEl = this.addRibbonIcon("magnifying-glass", "JSON/CSV Importer", (evt) => this.startApp());
      ribbonIconEl.addClass("json-import-ribbon-class");
      this.addCommand({
        id: "import-json",
        name: "Import JSON/CSV file",
        callback: () => this.startApp()
      });
    });
  }
  onunload() {
  }
  loadSettings() {
    return __async(this, null, function* () {
      this.settings = Object.assign({}, DEFAULT_SETTINGS, yield this.loadData());
    });
  }
  saveSettings() {
    return __async(this, null, function* () {
      yield this.saveData(this.settings);
    });
  }
  validFilename(name) {
    const regexp = this.namepath ? /[<>:"\\|?\*]/g : /[<>:"/\\|?\*]/g;
    return name.replace(regexp, "_");
  }
  hb_table() {
    if (arguments.length < 4)
      return "";
    if (arguments[0] == void 0 || arguments[0] == null)
      return arguments[0];
    let len = arguments.length - 1;
    let options = arguments[len];
    let value2 = arguments[0].toString();
    for (let i = 1; i < len; i += 2) {
      let result = value2.match(RegExp(`^${arguments[i]}$`, "u"));
      if (result) {
        value2 = arguments[i + 1];
        if (result.length > 1) {
          console.info(JSON.stringify(result.groups, null, 2));
          value2 = value2.replaceAll(/\$(\d+)/g, (match, p1) => {
            let param = +p1;
            if (param < result.length)
              return result[param];
            else
              return match;
          });
        }
      }
    }
    return hb_utils.value(value2, this, options);
  }
  hb_substring() {
    let len = arguments.length - 1;
    let options = arguments[len];
    let value2 = arguments[0];
    if (len === 3) {
      let beginPos = arguments[1];
      let length = arguments[2];
      if (typeof value2 === "string" && typeof beginPos === "number" && typeof length === "number")
        value2 = value2.slice(beginPos, beginPos + length);
    }
    return hb_utils.value(value2, this, options);
  }
  hb_strarray() {
    let len = arguments.length - 1;
    let options = arguments[len];
    let orig = arguments[0];
    if (arguments.length != 2 || typeof orig !== "string")
      return hb_utils.value(orig, this, options);
    return hb_utils.value([...orig], this, options);
  }
  hb_replacereg() {
    if (arguments.length != 4)
      return arguments[0];
    let orig = arguments[0];
    let pattern = RegExp(arguments[1], "g");
    let replacement = arguments[2];
    let options = arguments[3];
    let result = pattern[Symbol.replace](orig, replacement);
    return hb_utils.value(result, this, options);
  }
  hb_strsplit() {
    if (arguments.length != 3)
      return arguments[0];
    let orig = arguments[0];
    let pattern = arguments[1];
    let options = arguments[2];
    let result = orig.split(pattern);
    return hb_utils.value(result, this, options);
  }
  hb_setvar() {
    if (arguments.length != 3)
      return arguments[0];
    let varName = arguments[0];
    let varValue = arguments[1];
    let options = arguments[2];
    options.data.root[varName] = varValue;
    return hb_utils.value("");
  }
  checkPath(filename) {
    return __async(this, null, function* () {
      let pos = filename.lastIndexOf("/");
      if (pos < 0)
        return true;
      let path = filename.slice(0, pos);
      if (this.knownpaths.has(path))
        return true;
      let exists = this.app.vault.getAbstractFileByPath(path);
      if (!exists) {
        console.log(`Creating folder for ${path}`);
        yield this.app.vault.createFolder(path).catch((err) => console.log(`app.vault.checkPath: ${err}`));
      }
      this.knownpaths.add(path);
    });
  }
  generateNotes(objdata, sourcefilename, templatefile, helperfile, settings) {
    return __async(this, null, function* () {
      console.log(`generateNotes('${templatefile}', '${helperfile}', ${settings} )`);
      this.knownpaths = new Set();
      this.namepath = settings.jsonNamePath;
      const compileoptions = { noEscape: true };
      let templatetext = yield templatefile.text();
      let template = handlebars.compile(templatetext);
      handlebars.registerHelper("table", this.hb_table);
      handlebars.registerHelper("substring", this.hb_substring);
      handlebars.registerHelper("strarray", this.hb_strarray);
      handlebars.registerHelper("replacereg", this.hb_replacereg);
      handlebars.registerHelper("strsplit", this.hb_strsplit);
      handlebars.registerHelper("setvar", this.hb_setvar);
      if (helperfile) {
        let initJsonHelpers = new Function("handlebars", yield helperfile.text());
        if (initJsonHelpers)
          initJsonHelpers(handlebars);
      }
      let topobj = void 0;
      if (settings.topField) {
        topobj = objfield(objdata, settings.topField);
        if (!topobj) {
          new import_obsidian.Notice(`Key '${settings.topField}' does not exist in the source file`);
          return;
        }
      } else
        topobj = objdata;
      if (!Array.isArray(topobj) && settings.forceArray)
        topobj = [topobj];
      this.settings = settings;
      this.saveSettings();
      let entries = Array.isArray(topobj) ? topobj.entries() : Object.entries(topobj);
      for (const [index, row] of entries) {
        row.SourceIndex = index;
        if (sourcefilename)
          row.SourceFilename = sourcefilename;
        let notefile = objfield(row, settings.jsonName);
        if (typeof notefile === "number")
          notefile = notefile.toString();
        if (!notefile || notefile.length == 0)
          continue;
        notefile = settings.notePrefix + notefile + settings.noteSuffix;
        let body;
        try {
          body = template(row);
        } catch (err) {
          console.error(`${err.message}
FOR ROW:
${row}`);
          continue;
        }
        if (body.contains("[object Object]")) {
          console.log(`[object Object] appears in '${notefile}'`);
          new import_obsidian.Notice(`Incomplete conversion for '${notefile}'. Look for '[object Object]' (also reported in console)`);
        }
        let filename = settings.folderName + "/" + this.validFilename(notefile) + ".md";
        yield this.checkPath(filename);
        let file = this.app.vault.getAbstractFileByPath(filename);
        if (!file)
          yield this.app.vault.create(filename, body).catch((err) => console.log(`app.vault.create: ${err}`));
        else
          switch (settings.handleExistingNote) {
            case 1:
              yield this.app.vault.modify(file, body).catch((err) => console.log(`app.vault.modify: ${err}`));
              break;
            case 2:
              yield this.app.vault.append(file, body).catch((err) => console.log(`app.vault.append: ${err}`));
              break;
            default:
              new import_obsidian.Notice(`Note already exists for '${filename}' - ignoring entry in data file`);
              break;
          }
      }
    });
  }
};
var FileSelectionModal = class extends import_obsidian.Modal {
  constructor(app) {
    super(app);
  }
  setHandler(caller, handler) {
    this.caller = caller;
    this.handler = handler;
  }
  setDefaults(settings) {
    this.default_settings = settings;
  }
  onOpen() {
    const setting1 = new import_obsidian.Setting(this.contentEl).setName("Choose JSON/CSV File").setDesc("Choose JSON/CSV data file to import, or paste text into the text box");
    const inputDataFile = setting1.controlEl.createEl("input", {
      attr: {
        type: "file",
        multiple: true,
        accept: ".json,.csv,.tsv"
      }
    });
    const inputJsonText = setting1.controlEl.createEl("textarea", {
      attr: {
        rows: "5",
        columns: "20"
      }
    });
    const setting2 = new import_obsidian.Setting(this.contentEl).setName("Choose TEMPLATE File").setDesc("Choose the Template (Handlebars) file");
    const inputTemplateFile = setting2.controlEl.createEl("input", {
      attr: {
        type: "file",
        accept: ".md",
        required: true
      }
    });
    const setting2a = new import_obsidian.Setting(this.contentEl).setName("Choose HELPERS File").setDesc("Optionally select a file containing some Handlebars Helpers functions");
    const inputHelperFile = setting2a.controlEl.createEl("input", {
      attr: {
        type: "file",
        accept: ".js"
      }
    });
    const setting3b = new import_obsidian.Setting(this.contentEl).setName("Field containing the data").setDesc("The field containing the array of data (leave blank to use entire file)");
    const inputTopField = setting3b.controlEl.createEl("input", {
      attr: {
        type: "string"
      }
    });
    inputTopField.value = this.default_settings.topField;
    const setting3c = new import_obsidian.Setting(this.contentEl).setName("Each subfield is a separate note").setDesc("Select this option if 'Field containing the data' is a single object and a separate note should be created for each field of that object.");
    const inputForceArray = setting3c.controlEl.createEl("input", {
      attr: {
        type: "checkbox"
      }
    });
    inputForceArray.checked = !this.default_settings.forceArray;
    const setting3 = new import_obsidian.Setting(this.contentEl).setName("Field to use as Note name").setDesc("Field in each row of the JSON/CSV data to be used for the note name");
    const inputJsonName = setting3.controlEl.createEl("input", {
      attr: {
        type: "string",
        required: true
      }
    });
    inputJsonName.value = this.default_settings.jsonName;
    const settingPrefix = new import_obsidian.Setting(this.contentEl).setName("Note name prefix/suffix").setDesc("Optional prefix/suffix to be added either side of the value from the above Note name field");
    const inputNotePrefix = settingPrefix.controlEl.createEl("input", {
      attr: {
        type: "string",
        placeholder: "prefix",
        size: 10
      }
    });
    inputNotePrefix.value = this.default_settings.notePrefix;
    const inputNoteSuffix = settingPrefix.controlEl.createEl("input", {
      attr: {
        type: "string",
        placeholder: "suffix",
        size: 10
      }
    });
    inputNoteSuffix.value = this.default_settings.noteSuffix;
    const setting3a = new import_obsidian.Setting(this.contentEl).setName("Allow paths in Note name").setDesc("Allow / in the Note name field to be used to create folders (when not selected / will be replaced by _ as part of note name)");
    const inputJsonNamePath = setting3a.controlEl.createEl("input", {
      attr: {
        type: "checkbox"
      }
    });
    inputJsonNamePath.checked = this.default_settings.jsonNamePath;
    const settingOverwrite = new import_obsidian.Setting(this.contentEl).setName("How to handle existing Notes").setDesc("REPLACE: Replace the existing note with the newly generated note; APPEND: Append the new note contents to the end of the existing note; KEEP: Leave the original note untouched and generate a warning");
    const inputHandleExisting = settingOverwrite.controlEl.createEl("select");
    inputHandleExisting.add(new Option("KEEP", 0 .toString()));
    inputHandleExisting.add(new Option("REPLACE", 1 .toString()));
    inputHandleExisting.add(new Option("APPEND", 2 .toString()));
    inputHandleExisting.selectedIndex = this.default_settings.handleExistingNote;
    const setting4 = new import_obsidian.Setting(this.contentEl).setName("Name of Destination Folder in Vault").setDesc("The name of the folder in your Obsidian Vault, which will be created if required");
    const inputFolderName = setting4.controlEl.createEl("input", {
      attr: {
        type: "string"
      }
    });
    inputFolderName.value = this.default_settings.folderName;
    const setting5 = new import_obsidian.Setting(this.contentEl).setName("Import").setDesc("Press to start the Import Process");
    const input5 = setting5.controlEl.createEl("button");
    input5.textContent = "IMPORT";
    input5.onclick = () => __async(this, null, function* () {
      const { files: templatefiles } = inputTemplateFile;
      if (!templatefiles.length) {
        new import_obsidian.Notice("No Template file selected");
        return;
      }
      const { files: helperfile } = inputHelperFile;
      const settings = {
        jsonName: inputJsonName.value,
        jsonNamePath: inputJsonNamePath.checked,
        folderName: inputFolderName.value,
        topField: inputTopField.value,
        notePrefix: inputNotePrefix.value,
        noteSuffix: inputNoteSuffix.value,
        handleExistingNote: parseInt(inputHandleExisting.value),
        forceArray: !inputForceArray.checked
      };
      let srctext = inputJsonText.value;
      if (srctext.length == 0) {
        const { files: datafiles } = inputDataFile;
        if (!datafiles.length) {
          new import_obsidian.Notice("No JSON file selected");
          return;
        }
        for (let i = 0; i < datafiles.length; i++) {
          console.log(`Processing input file ${datafiles[i].name}`);
          srctext = yield datafiles[i].text();
          let is_json = datafiles[i].name.endsWith(".json");
          let objdata = is_json ? JSON.parse(srctext) : convertCsv(srctext);
          yield this.handler.call(this.caller, objdata, datafiles[i].name, templatefiles[0], helperfile == null ? void 0 : helperfile[0], settings);
        }
      } else {
        let is_json = srctext.startsWith("{") && srctext.endsWith("}");
        let objdata = is_json ? JSON.parse(srctext) : convertCsv(srctext);
        yield this.handler.call(this.caller, objdata, null, templatefiles[0], helperfile == null ? void 0 : helperfile[0], settings);
      }
      new import_obsidian.Notice("Import Finished");
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
/* @license
Papa Parse
v5.3.2
https://github.com/mholt/PapaParse
License: MIT
*/
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/*!
 * arr-diff <https://github.com/jonschlinkert/arr-diff>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
/*!
 * arr-flatten <https://github.com/jonschlinkert/arr-flatten>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
/*!
 * array-sort <https://github.com/jonschlinkert/array-sort>
 *
 * Copyright (c) 2015-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
/*!
 * array-unique <https://github.com/jonschlinkert/array-unique>
 *
 * Copyright (c) 2014-2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */
/*!
 * assign-symbols <https://github.com/jonschlinkert/assign-symbols>
 *
 * Copyright (c) 2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */
/*!
 * collection-visit <https://github.com/jonschlinkert/collection-visit>
 *
 * Copyright (c) 2015, 2017, Jon Schlinkert.
 * Released under the MIT License.
 */
/*!
 * copy-descriptor <https://github.com/jonschlinkert/copy-descriptor>
 *
 * Copyright (c) 2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */
/*!
 * define-property <https://github.com/jonschlinkert/define-property>
 *
 * Copyright (c) 2015, 2017, Jon Schlinkert.
 * Released under the MIT License.
 */
/*!
 * define-property <https://github.com/jonschlinkert/define-property>
 *
 * Copyright (c) 2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */
/*!
 * define-property <https://github.com/jonschlinkert/define-property>
 *
 * Copyright (c) 2015-2018, Jon Schlinkert.
 * Released under the MIT License.
 */
/*!
 * fill-range <https://github.com/jonschlinkert/fill-range>
 *
 * Copyright (c) 2014-2015, 2017, Jon Schlinkert.
 * Released under the MIT License.
 */
/*!
 * for-in <https://github.com/jonschlinkert/for-in>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
/*!
 * fragment-cache <https://github.com/jonschlinkert/fragment-cache>
 *
 * Copyright (c) 2016-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
/*!
 * get-object <https://github.com/jonschlinkert/get-object>
 *
 * Copyright (c) 2014 Jon Schlinkert, contributors.
 * Licensed under the MIT License
 */
/*!
 * get-value <https://github.com/jonschlinkert/get-value>
 *
 * Copyright (c) 2014-2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */
/*!
 * get-value <https://github.com/jonschlinkert/get-value>
 *
 * Copyright (c) 2014-2018, Jon Schlinkert.
 * Released under the MIT License.
 */
/*!
 * handlebars-helpers <https://github.com/helpers/handlebars-helpers>
 *
 * Copyright (c) 2013-2017, Jon Schlinkert, Brian Woodward.
 * Released under the MIT License.
 */
/*!
 * has-value <https://github.com/jonschlinkert/has-value>
 *
 * Copyright (c) 2014-2016, Jon Schlinkert.
 * Licensed under the MIT License.
 */
/*!
 * has-value <https://github.com/jonschlinkert/has-value>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Licensed under the MIT License.
 */
/*!
 * has-value <https://github.com/jonschlinkert/has-value>
 *
 * Copyright (c) 2014-2018, Jon Schlinkert.
 * Released under the MIT License.
 */
/*!
 * has-values <https://github.com/jonschlinkert/has-values>
 *
 * Copyright (c) 2014-2015, 2017, Jon Schlinkert.
 * Released under the MIT License.
 */
/*!
 * has-values <https://github.com/jonschlinkert/has-values>
 *
 * Copyright (c) 2014-2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */
/*!
 * has-values <https://github.com/jonschlinkert/has-values>
 *
 * Copyright (c) 2014-2018, Jon Schlinkert.
 * Released under the MIT License.
 */
/*!
 * html-tag <https://github.com/jonschlinkert/html-tag>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
/*!
 * is-accessor-descriptor <https://github.com/jonschlinkert/is-accessor-descriptor>
 *
 * Copyright (c) 2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */
/*!
 * is-accessor-descriptor <https://github.com/jonschlinkert/is-accessor-descriptor>
 *
 * Copyright (c) 2015-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
/*!
 * is-data-descriptor <https://github.com/jonschlinkert/is-data-descriptor>
 *
 * Copyright (c) 2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */
/*!
 * is-data-descriptor <https://github.com/jonschlinkert/is-data-descriptor>
 *
 * Copyright (c) 2015-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
/*!
 * is-descriptor <https://github.com/jonschlinkert/is-descriptor>
 *
 * Copyright (c) 2015-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
/*!
 * is-extendable <https://github.com/jonschlinkert/is-extendable>
 *
 * Copyright (c) 2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */
/*!
 * is-extendable <https://github.com/jonschlinkert/is-extendable>
 *
 * Copyright (c) 2015-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
/*!
 * is-number <https://github.com/jonschlinkert/is-number>
 *
 * Copyright (c) 2014-2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
/*!
 * is-windows <https://github.com/jonschlinkert/is-windows>
 *
 * Copyright  2015-2018, Jon Schlinkert.
 * Released under the MIT License.
 */
/*!
 * isobject <https://github.com/jonschlinkert/isobject>
 *
 * Copyright (c) 2014-2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */
/*!
 * isobject <https://github.com/jonschlinkert/isobject>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
/*!
 * map-cache <https://github.com/jonschlinkert/map-cache>
 *
 * Copyright (c) 2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */
/*!
 * object-visit <https://github.com/jonschlinkert/object-visit>
 *
 * Copyright (c) 2015, 2017, Jon Schlinkert.
 * Released under the MIT License.
 */
/*!
 * object.pick <https://github.com/jonschlinkert/object.pick>
 *
 * Copyright (c) 2014-2015 Jon Schlinkert, contributors.
 * Licensed under the MIT License
 */
/*!
 * pascalcase <https://github.com/jonschlinkert/pascalcase>
 *
 * Copyright (c) 2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */
/*!
 * repeat-element <https://github.com/jonschlinkert/repeat-element>
 *
 * Copyright (c) 2015-present, Jon Schlinkert.
 * Licensed under the MIT license.
 */
/*!
 * repeat-string <https://github.com/jonschlinkert/repeat-string>
 *
 * Copyright (c) 2014-2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */
/*!
 * set-value <https://github.com/jonschlinkert/set-value>
 *
 * Copyright (c) 2014-2015, 2017, Jon Schlinkert.
 * Released under the MIT License.
 */
/*!
 * split-string <https://github.com/jonschlinkert/split-string>
 *
 * Copyright (c) 2015-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
/*!
 * static-extend <https://github.com/jonschlinkert/static-extend>
 *
 * Copyright (c) 2016, Jon Schlinkert.
 * Licensed under the MIT License.
 */
/*!
 * to-gfm-code-block <https://github.com/jonschlinkert/to-gfm-code-block>
 *
 * Copyright (c) 2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */
/*!
 * to-object-path <https://github.com/jonschlinkert/to-object-path>
 *
 * Copyright (c) 2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */
/*!
 * to-regex-range <https://github.com/jonschlinkert/to-regex-range>
 *
 * Copyright (c) 2015, 2017, Jon Schlinkert.
 * Released under the MIT License.
 */
/*!
 * unset-value <https://github.com/jonschlinkert/unset-value>
 *
 * Copyright (c) 2015, 2017, Jon Schlinkert.
 * Released under the MIT License.
 */
/*!
 * use <https://github.com/jonschlinkert/use>
 *
 * Copyright (c) 2015-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
